# 独立提示词聚合方案设计

## 文档说明

本文档描述将现有多Agent流程（medical_agent_v3）改造为独立提示词聚合方案的详细设计。

**文档版本**：V1.0  
**创建时间**：2025-01-XX  
**对应流程**：`config/flows/medical_agent_v3 copy`

---

## 目录

1. [方案概述](#一方案概述)
2. [节点1：快速意图识别节点设计](#二节点1快速意图识别节点设计)
3. [节点2：向量库检索与用户信息查询节点](#三节点2向量库检索与用户信息查询节点)
4. [节点3：核心Agent节点设计](#四节点3核心agent节点设计)
5. [LangGraph流程设计要点](#五langgraph流程设计要点)
6. [向量库设计方案](#六向量库设计方案)
7. [数据流转与状态管理](#七数据流转与状态管理)

---

## 一、方案概述

### 1.1 当前流程结构

当前 `medical_agent_v3` 流程采用多Agent分离设计：

```
意图识别Agent
    ↓
    ├─→ 记录Agent (record_agent)
    │       ↓
    │   记录后处理Agent (after_record_agent)
    │
    ├─→ 查询Agent (query_agent)
    │
    ├─→ QA Agent (qa_agent)
    │
    └─→ 不明确意图Agent (unclear_agent)
```

**特点**：
- 每个功能模块有独立的提示词文件
- 意图识别后直接路由到对应Agent
- 各Agent提示词中包含大量示例和规则

### 1.2 新流程设计目标

新流程采用**提示词聚合 + RAG增强**的设计：

```
节点1：快速意图识别
    ↓
节点2：向量库检索 + 用户信息查询
    ↓
节点3：核心Agent（聚合所有功能）
```

**设计目标**：
1. **节点1**：快速理解用户意图，提取核心信息，为向量库检索提供查询关键词
2. **节点2**：基于节点1的优化问题，从向量库检索相关历史问答和科普资料；同时查询用户基础信息
3. **节点3**：统一的Agent，整合记录、查询、QA、greeting等功能，使用节点2检索的示例作为上下文

**核心优势**：
- 提示词精简：节点3只保留核心流程逻辑，问答示例通过RAG动态获取
- 知识库可扩展：优秀的历史问答和科普资料可随时更新到向量库
- 个性化增强：结合用户基础信息，提供更精准的回答

---

## 二、节点1：快速意图识别节点设计

### 2.1 节点职责

节点1负责：
1. **快速识别用户意图**：record、query、qa、greeting
2. **提取核心信息**：从用户输入中提取关键实体和问题要点
3. **生成检索查询**：将用户问题优化为适合向量库检索的查询文本

### 2.2 提示词设计要点

#### 2.2.1 精简意图识别

相比原 `00-intent_recognition_agent.md`，节点1的提示词应该：

**保留内容**：
- 支持的意图类型定义（record、query、qa、greeting）
- 意图识别的核心规则
- 输出格式要求（JSON格式）

**简化内容**：
- 减少示例数量（只保留典型示例）
- 移除详细的场景说明（这些会在节点3中通过RAG获取）
- 移除复杂的置信度判断逻辑（简化为高/中/低三档）

#### 2.2.2 新增核心信息提取

节点1需要额外输出：

```json
{
    "intent": "qa",
    "confidence": 0.9,
    "need_clarification": false,
    "reasoning": "用户询问高血压注意事项",
    "core_info": {
        "entities": ["高血压", "注意事项"],
        "query_text": "高血压患者日常注意事项有哪些",
        "question_type": "健康咨询"
    }
}
```

**字段说明**：
- `entities`：提取的关键实体（疾病名、症状、药物等）
- `query_text`：优化后的查询文本，用于向量库检索
- `question_type`：问题类型（健康咨询、用药咨询、症状咨询等）

#### 2.2.3 查询文本优化原则

节点1需要将用户原始问题优化为更适合向量库检索的文本：

**优化策略**：
1. **去除口语化表达**：将"我最近血压有点高，怎么办？"优化为"血压偏高如何处理"
2. **补充关键词**：识别领域关键词，如"高血压"、"降压药"等
3. **标准化表达**：统一术语表达，如"血压高"→"高血压"
4. **保留核心问题**：提取问题的核心，去除冗余信息

**示例**：
- 用户输入："医生，我吃了降压药但是血压还是有点高，是不是药量不够？"
- 优化后查询文本："服用降压药后血压仍然偏高，是否需要调整用药剂量"

### 2.3 提示词结构建议

```markdown
# 角色定义
你是一个专业的意图识别助手。你的任务是快速识别用户意图，并提取核心信息用于后续检索。

# 支持的意图类型
[保留原意图类型定义，但简化示例]

# 核心任务
1. 识别用户意图（record、query、qa、greeting）
2. 提取关键实体和问题要点
3. 生成优化的查询文本，用于向量库检索

# 查询文本优化原则
[上述优化策略]

# 输出格式
{
    "intent": "qa",
    "confidence": 0.9,
    "need_clarification": false,
    "reasoning": "...",
    "core_info": {
        "entities": [...],
        "query_text": "...",
        "question_type": "..."
    }
}
```

---

## 三、节点2：向量库检索与用户信息查询节点

### 3.1 节点职责

节点2负责：
1. **向量库检索**：基于节点1的 `query_text`，从向量库检索相关历史问答和科普资料
2. **用户信息查询**：查询用户基础信息（作为节点3提示词的占位符）
3. **结果整合**：将检索结果和用户信息整合，传递给节点3

### 3.2 向量库检索流程

#### 3.2.1 检索策略

**多路检索**（根据意图类型选择）：

1. **QA意图**：
   - 检索历史问答库（相似问题的最佳回答）
   - 检索科普资料库（相关医学知识）
   - Top-K：各取3-5条

2. **Record意图**：
   - 检索记录示例库（优秀的数据记录对话示例）
   - Top-K：3-5条

3. **Query意图**：
   - 检索查询示例库（优秀的数据查询对话示例）
   - Top-K：3-5条

4. **Greeting意图**：
   - 可跳过向量库检索，或检索通用对话示例
   - Top-K：2-3条

#### 3.2.2 检索实现要点

**查询文本处理**：
- 直接使用节点1输出的 `query_text`
- 如果 `query_text` 为空，回退到用户原始输入
- 对查询文本进行向量化（使用与存储时相同的embedding模型）

**相似度阈值**：
- 设置最低相似度阈值（如0.7），低于阈值的结果不返回
- 如果检索结果不足，降低阈值或返回空结果

**结果排序**：
- 按相似度降序排列
- 可考虑时间权重（较新的问答优先）

### 3.3 用户信息查询

查询用户基础信息，包括：
- 用户基本信息（姓名、年龄、性别等）
- 疾病诊断信息（如：高血压、糖尿病等）
- 用药信息（当前用药方案）
- 目标值设定（如：血压目标值）

**用途**：
- 作为节点3提示词中的占位符（如：`{user_name}`、`{diagnosis}`、`{target_blood_pressure}`）
- 提供个性化回答的上下文

### 3.4 输出格式

节点2输出格式：

```json
{
    "retrieved_examples": [
        {
            "content": "问答示例内容...",
            "similarity": 0.85,
            "source": "历史问答库",
            "metadata": {...}
        },
        ...
    ],
    "user_info": {
        "name": "张先生",
        "age": 55,
        "diagnosis": ["高血压"],
        "medications": [...],
        "target_blood_pressure": {"systolic": 130, "diastolic": 80}
    }
}
```

---

## 四、节点3：核心Agent节点设计

### 4.1 节点职责

节点3是统一的Agent，整合所有功能：
- **数据记录**：血压、症状、用药、健康事件
- **数据查询**：各类健康数据查询
- **健康问答**：基于检索的示例和用户信息回答
- **日常问候**：greeting相关处理

### 4.2 提示词设计原则

#### 4.2.1 核心流程保留

从原各Agent提示词中提取**核心流程逻辑**：

**从 record_agent.md 提取**：
- 数据记录的工作流程
- 工具调用规则
- 数据完整性检查规则
- 澄清机制

**从 query_agent.md 提取**：
- 查询需求理解规则
- 查询工具使用规则
- 结果展示规则

**从 qa_agent.md 提取**：
- 安全边界场景定义
- 场景匹配规则
- 回复话术框架（但不包含具体示例）

**从 unclear_agent.md 提取**：
- 不明确意图的处理规则

#### 4.2.2 问答示例动态注入

**不保留的内容**：
- 原提示词中的大量问答示例
- 具体的场景示例（这些通过RAG获取）

**动态注入的内容**：
- 节点2检索到的历史问答示例
- 节点2检索到的科普资料
- 用户基础信息（作为占位符）

**注入方式**：
在提示词中设置专门的章节：

```markdown
# 参考示例（来自知识库）

以下是从知识库中检索到的相关示例，供你参考：

{retrieved_examples}

# 用户信息

当前用户信息：
- 姓名：{user_name}
- 年龄：{user_age}
- 诊断：{diagnosis}
- 目标血压：{target_blood_pressure}

在回答时，请结合用户的具体情况，提供个性化建议。
```

#### 4.2.3 提示词结构建议

```markdown
# 角色定义
你是一个专业的医疗健康助手，负责帮助用户记录数据、查询数据、回答健康问题。

# 核心任务
根据用户意图，执行相应任务：
1. 数据记录（血压、症状、用药、健康事件）
2. 数据查询
3. 健康问答
4. 日常问候

# 用户信息
{user_info_section}

# 参考示例（来自知识库）
{retrieved_examples_section}

# 数据记录规则
[从 record_agent.md 提取的核心规则]

# 数据查询规则
[从 query_agent.md 提取的核心规则]

# 健康问答规则
[从 qa_agent.md 提取的安全边界和场景匹配规则，但不包含具体示例]

# 工具说明
[工具列表和使用说明]

# 输出格式要求
{end_llm_response}
```

### 4.3 功能整合策略

#### 4.3.1 意图路由逻辑

节点3需要根据节点1识别的意图，执行相应功能：

**实现方式**：
- 在提示词中明确说明：根据 `intent` 字段执行对应任务
- 或者在LangGraph中通过条件边，但考虑到要聚合为一个Agent，建议在提示词中处理

**推荐方案**：在提示词中处理
- 优点：简化流程，减少节点数量
- 缺点：Agent需要理解多种任务

#### 4.3.2 工具选择

节点3需要支持所有工具：
- 记录工具：`record_blood_pressure`、`record_medication`、`record_symptom`、`record_health_event`
- 查询工具：`query_blood_pressure`、`query_medication`、`query_symptom`、`query_health_event`

**工具配置**：
在 `flow.yaml` 中为节点3配置所有工具。

---

## 五、LangGraph流程设计要点

### 5.1 流程结构

```yaml
nodes:
  - name: intent_recognition
    type: agent
    config:
      prompt: prompts/01-intent_recognition.md
      # 快速模式，关闭深度思考
  
  - name: retrieval_node
    type: function  # 函数节点，非Agent
    config:
      # 向量库检索 + 用户信息查询
  
  - name: core_agent
    type: agent
    config:
      prompt: prompts/03-core_agent.md
      # 支持所有工具

edges:
  - from: intent_recognition
    to: retrieval_node
    condition: always
  
  - from: retrieval_node
    to: core_agent
    condition: always
  
  - from: core_agent
    to: END
    condition: always

entry_node: intent_recognition
```

### 5.2 状态管理

#### 5.2.1 状态字段设计

需要在 `RouterState` 中新增字段：

```python
class RouterState(TypedDict):
    # 原有字段
    messages: List[BaseMessage]
    current_intent: Optional[str]
    current_agent: Optional[str]
    
    # 新增字段
    core_info: Optional[Dict]  # 节点1提取的核心信息
    retrieved_examples: Optional[List[Dict]]  # 节点2检索的示例
    user_info: Optional[Dict]  # 节点2查询的用户信息
```

#### 5.2.2 状态流转

```
初始状态
  ↓
节点1：更新 current_intent、core_info
  ↓
节点2：更新 retrieved_examples、user_info
  ↓
节点3：使用所有状态信息，生成回复
  ↓
结束
```

### 5.3 节点2实现方式

节点2是**函数节点**（非Agent），实现方式：

```python
def retrieval_node(state: RouterState) -> RouterState:
    """
    向量库检索 + 用户信息查询节点
    """
    # 1. 获取节点1的输出
    core_info = state.get("core_info", {})
    query_text = core_info.get("query_text", "")
    intent = state.get("current_intent", "")
    
    # 2. 向量库检索
    retrieved_examples = vector_db_search(
        query_text=query_text,
        intent=intent,
        top_k=5
    )
    
    # 3. 查询用户信息
    user_id = state.get("user_id")
    user_info = query_user_info(user_id)
    
    # 4. 更新状态
    state["retrieved_examples"] = retrieved_examples
    state["user_info"] = user_info
    
    return state
```

### 5.4 节点3提示词注入

节点3的提示词需要在运行时动态构建：

```python
def build_core_agent_prompt(
    base_prompt: str,
    retrieved_examples: List[Dict],
    user_info: Dict
) -> str:
    """
    构建节点3的提示词
    """
    # 格式化检索示例
    examples_text = format_examples(retrieved_examples)
    
    # 格式化用户信息
    user_info_text = format_user_info(user_info)
    
    # 替换占位符
    prompt = base_prompt.replace(
        "{retrieved_examples_section}",
        examples_text
    ).replace(
        "{user_info_section}",
        user_info_text
    )
    
    return prompt
```

**实现位置**：
- 在 `GraphBuilder` 中，创建节点3时动态构建提示词
- 或者在节点3执行前，通过 `StateGraph` 的节点函数动态注入

### 5.5 错误处理

**节点2检索失败**：
- 如果向量库检索失败，返回空列表
- 如果用户信息查询失败，返回默认值或空字典
- 节点3需要能够处理这些情况（提示词中说明：如果没有检索到示例，使用通用规则）

**节点3执行失败**：
- 按照现有错误处理机制
- 可以考虑回退到 unclear_agent

---

## 六、向量库设计方案

### 6.1 向量库结构设计

#### 6.1.1 表结构设计

建议设计多个表，按内容类型分类：

**1. 历史问答库（qa_examples）**

```sql
CREATE TABLE qa_examples (
    id SERIAL PRIMARY KEY,
    question TEXT NOT NULL,  -- 用户问题
    answer TEXT NOT NULL,    -- 医生回答
    intent_type VARCHAR(50),  -- 意图类型（qa）
    question_type VARCHAR(100),  -- 问题类型（健康咨询、用药咨询等）
    entities TEXT[],  -- 关键实体（疾病、症状、药物等）
    embedding vector(768),  -- 问题+答案的向量
    similarity_score FLOAT,  -- 相似度分数（用于排序）
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 创建向量索引
CREATE INDEX qa_examples_embedding_idx 
ON qa_examples 
USING hnsw (embedding vector_cosine_ops);
```

**2. 科普资料库（knowledge_base）**

```sql
CREATE TABLE knowledge_base (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,  -- 标题
    content TEXT NOT NULL,  -- 内容
    category VARCHAR(100),  -- 分类（高血压、糖尿病等）
    tags TEXT[],  -- 标签
    embedding vector(768),  -- 内容向量
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX knowledge_base_embedding_idx 
ON knowledge_base 
USING hnsw (embedding vector_cosine_ops);
```

**3. 记录示例库（record_examples）**

```sql
CREATE TABLE record_examples (
    id SERIAL PRIMARY KEY,
    user_input TEXT NOT NULL,  -- 用户输入
    agent_response TEXT NOT NULL,  -- Agent回复
    record_type VARCHAR(50),  -- 记录类型（blood_pressure、medication等）
    embedding vector(768),  -- 用户输入+回复的向量
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX record_examples_embedding_idx 
ON record_examples 
USING hnsw (embedding vector_cosine_ops);
```

**4. 查询示例库（query_examples）**

```sql
CREATE TABLE query_examples (
    id SERIAL PRIMARY KEY,
    user_input TEXT NOT NULL,
    agent_response TEXT NOT NULL,
    query_type VARCHAR(50),  -- 查询类型
    embedding vector(768),
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX query_examples_embedding_idx 
ON query_examples 
USING hnsw (embedding vector_cosine_ops);
```

#### 6.1.2 向量化策略

**文本组合方式**：

1. **QA示例**：
   - 向量化文本 = `question + " " + answer`
   - 这样检索时，相似的问题和答案都能被找到

2. **科普资料**：
   - 向量化文本 = `title + " " + content`
   - 或者分段向量化（长文本分段）

3. **记录/查询示例**：
   - 向量化文本 = `user_input + " " + agent_response`

**Embedding模型**：
- 使用与项目一致的模型（如：`moka-ai/m3e-base`，768维）
- 确保存储和检索使用相同的模型

### 6.2 检索实现

#### 6.2.1 检索函数设计

```python
def vector_db_search(
    query_text: str,
    intent: str,
    top_k: int = 5,
    similarity_threshold: float = 0.7
) -> List[Dict]:
    """
    向量库检索
    
    Args:
        query_text: 查询文本（来自节点1）
        intent: 意图类型
        top_k: 返回数量
        similarity_threshold: 相似度阈值
    
    Returns:
        检索结果列表
    """
    # 1. 对查询文本向量化
    query_embedding = embed_text(query_text)
    
    # 2. 根据意图选择表
    table_name = get_table_by_intent(intent)
    
    # 3. 执行向量相似度查询
    results = execute_vector_search(
        table=table_name,
        query_embedding=query_embedding,
        top_k=top_k,
        threshold=similarity_threshold
    )
    
    # 4. 格式化结果
    formatted_results = [
        {
            "content": format_example_content(row),
            "similarity": row["similarity_score"],
            "source": table_name,
            "metadata": extract_metadata(row)
        }
        for row in results
    ]
    
    return formatted_results
```

#### 6.2.2 SQL查询示例

```sql
-- 向量相似度查询（使用余弦相似度）
SELECT 
    id,
    question,
    answer,
    1 - (embedding <=> %s::vector) AS similarity_score
FROM qa_examples
WHERE 1 - (embedding <=> %s::vector) >= %s
ORDER BY embedding <=> %s::vector
LIMIT %s;
```

**说明**：
- `<=>` 是 pgvector 的余弦距离操作符
- `1 - distance` 得到相似度分数（0-1之间）
- 使用 `ORDER BY` 按距离排序，取 Top-K

### 6.3 数据来源与更新

#### 6.3.1 初始数据来源

1. **历史问答库**：
   - 从现有对话记录中筛选优秀问答
   - 人工审核后入库

2. **科普资料**：
   - 医学知识文档
   - 健康科普文章

3. **记录/查询示例**：
   - 从现有对话记录中筛选优秀示例
   - 人工审核后入库

#### 6.3.2 数据更新策略

**定期更新**：
- 每周/每月从新对话中筛选优秀示例
- 人工审核后批量入库

**实时更新**（可选）：
- 对于特别优秀的问答，可以实时入库
- 需要设置审核机制

### 6.4 与节点1的配合

#### 6.4.1 查询文本提取

节点1输出的 `query_text` 直接用于向量库检索：

```python
# 节点2中
core_info = state.get("core_info", {})
query_text = core_info.get("query_text")

if not query_text:
    # 回退到用户原始输入
    last_message = state["messages"][-1]
    query_text = last_message.content

# 执行检索
results = vector_db_search(query_text, intent)
```

#### 6.4.2 实体过滤（可选增强）

节点1提取的 `entities` 可以用于过滤：

```python
# 如果检索结果过多，可以使用实体过滤
entities = core_info.get("entities", [])
if entities:
    results = filter_by_entities(results, entities)
```

---

## 七、数据流转与状态管理

### 7.1 完整数据流转

```
用户输入
  ↓
节点1：意图识别
  ├─ 输出：intent, confidence, core_info
  └─ 更新状态：current_intent, core_info
  ↓
节点2：检索与查询
  ├─ 输入：core_info.query_text, current_intent
  ├─ 向量库检索 → retrieved_examples
  ├─ 用户信息查询 → user_info
  └─ 更新状态：retrieved_examples, user_info
  ↓
节点3：核心Agent
  ├─ 输入：所有状态信息
  ├─ 动态构建提示词（注入 retrieved_examples, user_info）
  ├─ LLM推理 + 工具调用
  └─ 输出：回复内容
  ↓
返回用户
```

### 7.2 状态字段完整定义

```python
class RouterState(TypedDict):
    # 基础字段
    messages: List[BaseMessage]
    session_id: str
    user_id: str
    
    # 意图识别结果（节点1）
    current_intent: Optional[str]  # record, query, qa, greeting
    intent_confidence: Optional[float]
    need_clarification: Optional[bool]
    core_info: Optional[Dict]  # {entities, query_text, question_type}
    
    # 检索结果（节点2）
    retrieved_examples: Optional[List[Dict]]  # 向量库检索结果
    user_info: Optional[Dict]  # 用户基础信息
    
    # Agent执行结果（节点3）
    current_agent: Optional[str]  # 固定为 "core_agent"
    record_success: Optional[bool]  # 记录是否成功（用于路由判断）
```

### 7.3 提示词占位符替换

节点3的提示词模板需要支持占位符：

```markdown
# 用户信息
姓名：{user_name}
年龄：{user_age}
诊断：{diagnosis}
目标血压：{target_blood_pressure}

# 参考示例
{retrieved_examples_list}
```

**替换实现**：

```python
def format_user_info(user_info: Dict) -> str:
    """格式化用户信息"""
    if not user_info:
        return "用户信息未获取"
    
    lines = []
    if user_info.get("name"):
        lines.append(f"姓名：{user_info['name']}")
    if user_info.get("age"):
        lines.append(f"年龄：{user_info['age']}")
    if user_info.get("diagnosis"):
        diagnosis_str = "、".join(user_info["diagnosis"])
        lines.append(f"诊断：{diagnosis_str}")
    # ... 其他字段
    
    return "\n".join(lines) if lines else "用户信息未获取"


def format_examples(examples: List[Dict]) -> str:
    """格式化检索示例"""
    if not examples:
        return "未检索到相关示例，请使用通用规则回答。"
    
    formatted = []
    for i, example in enumerate(examples, 1):
        content = example.get("content", "")
        similarity = example.get("similarity", 0)
        source = example.get("source", "")
        
        formatted.append(
            f"示例{i}（相似度：{similarity:.2f}，来源：{source}）：\n{content}\n"
        )
    
    return "\n".join(formatted)
```

### 7.4 错误处理与降级

#### 7.4.1 节点1失败

- 如果意图识别失败，可以设置默认意图（如：greeting）
- 或者直接进入 unclear_agent

#### 7.4.2 节点2失败

- **向量库检索失败**：返回空列表，节点3使用通用规则
- **用户信息查询失败**：返回默认值或空字典，节点3提示词中说明如何处理

**降级策略**：
```python
# 节点2中
try:
    retrieved_examples = vector_db_search(...)
except Exception as e:
    logger.error(f"向量库检索失败: {e}")
    retrieved_examples = []  # 降级：返回空列表

try:
    user_info = query_user_info(user_id)
except Exception as e:
    logger.error(f"用户信息查询失败: {e}")
    user_info = {}  # 降级：返回空字典
```

#### 7.4.3 节点3失败

- 按照现有错误处理机制
- 可以考虑回退到 unclear_agent 或返回友好错误提示

---

## 八、实施建议

### 8.1 分阶段实施

**阶段一：基础数据抽取**

目标：将原有提示词中的案例抽取为Excel文档，按照类别进行分类，为后续向量库建设做准备。

**任务清单**：
1. **数据源分析**
   - 分析 `config/flows/medical_agent_v3 copy/prompts/` 下所有提示词文件
   - 识别所有包含示例、案例、问答对的内容

2. **案例分类标准**
   - **QA示例**：从 `50-QA_agent.md` 中提取问答对、场景示例
   - **记录示例**：从 `11-record_agent.md` 中提取数据记录对话示例
   - **查询示例**：从 `20-query_agent.md` 中提取数据查询对话示例
   - **意图识别示例**：从 `00-intent_recognition_agent.md` 中提取意图识别示例
   - **安全边界示例**：从 `50-QA_agent.md` 中提取安全边界场景示例

3. **Excel文档结构设计**
   - 每个类别创建一个Sheet
   - 字段设计：
     - **QA示例表**：问题、答案、场景类型、关键词、安全边界分类
     - **记录示例表**：用户输入、Agent回复、记录类型、数据完整性示例
     - **查询示例表**：用户输入、Agent回复、查询类型、时间范围示例
     - **意图识别示例表**：用户输入、识别意图、置信度、关键词匹配
     - **安全边界示例表**：场景描述、触发条件、回复话术、风险等级

4. **数据抽取与整理**
   - 人工抽取或使用脚本辅助提取
   - 确保示例的完整性和准确性
   - 标注示例的质量等级（优秀/良好/一般）

5. **输出交付物**
   - Excel文档：`提示词案例库.xlsx`（按类别分Sheet）
   - 数据统计报告：各类别示例数量、质量分布

**阶段二：重构提示词和LangGraph流程**

目标：基于阶段一抽取的数据，重构提示词和LangGraph流程，处理 `config/flows/medical_agent_v3 copy` 的内容。

**任务清单**：
1. **节点1提示词重构**
   - 基于 `00-intent_recognition_agent.md` 精简意图识别逻辑
   - 新增核心信息提取和查询文本优化功能
   - 创建新提示词文件：`prompts/01-intent_recognition.md`

2. **节点3提示词重构**
   - 从各Agent提示词中提取核心流程逻辑：
     - 从 `11-record_agent.md` 提取数据记录规则
     - 从 `20-query_agent.md` 提取数据查询规则
     - 从 `50-QA_agent.md` 提取安全边界规则（不含示例）
     - 从 `90-unclear-agent.md` 提取不明确意图处理规则
   - 设计占位符机制：`{retrieved_examples}`、`{user_info}`
   - 创建新提示词文件：`prompts/03-core_agent.md`

3. **LangGraph流程重构**
   - 设计新的 `flow.yaml` 结构：
     - 节点1：`intent_recognition`（Agent节点）
     - 节点2：`retrieval_node`（函数节点）
     - 节点3：`core_agent`（Agent节点）
   - 定义状态字段：`core_info`、`retrieved_examples`、`user_info`
   - 设计边条件：节点1→节点2→节点3→END

4. **流程验证**
   - 验证流程结构是否正确
   - 验证状态流转是否正常
   - 验证占位符替换机制

**阶段三：Python代码改造与功能测试**

目标：实现节点2的向量库检索功能，完成整体流程的代码实现和功能测试。

**任务清单**：
1. **向量库基础建设**
   - 设计数据库表结构（qa_examples、knowledge_base、record_examples、query_examples）
   - 实现表创建脚本
   - 实现向量索引创建

2. **数据导入功能**
   - 开发Excel数据导入脚本
   - 实现文本向量化（使用moka-ai/m3e-base模型）
   - 实现批量数据入库功能
   - 验证数据导入的准确性

3. **节点2实现（retrieval_node）**
   - 实现向量库检索函数：
     - `vector_db_search()`：根据意图类型选择表，执行向量相似度查询
     - 支持多路检索（QA、记录、查询等）
     - 实现相似度阈值过滤
   - 实现用户信息查询函数：
     - `query_user_info()`：查询用户基础信息
   - 实现节点2函数：整合检索和查询结果，更新状态

4. **节点3提示词动态构建**
   - 实现提示词格式化函数：
     - `format_user_info()`：格式化用户信息
     - `format_examples()`：格式化检索示例
   - 在GraphBuilder中实现动态提示词构建
   - 验证占位符替换是否正确

5. **错误处理与降级**
   - 实现节点2的错误处理（检索失败、查询失败）
   - 实现降级策略（返回空列表/默认值）
   - 实现节点3的错误处理

6. **功能测试**
   - **单元测试**：
     - 节点1意图识别准确性测试
     - 节点2向量库检索功能测试
     - 节点3提示词构建测试
   - **集成测试**：
     - 完整流程端到端测试
     - 各意图类型（record、query、qa、greeting）测试
   - **性能测试**：
     - 响应时间测试
     - 向量库检索性能测试
   - **质量测试**：
     - 回答质量对比（新方案 vs 原方案）
     - 检索相关性评估

7. **测试报告**
   - 测试用例执行结果
   - 性能指标报告
   - 问题清单和修复记录

**阶段四：未来规划，持续管理向量库**

目标：建立向量库的持续管理机制，确保知识库的持续更新和优化。

**任务清单**：
1. **数据更新机制设计**
   - 设计定期更新流程：
     - 从新对话记录中筛选优秀示例
     - 人工审核机制
     - 批量入库流程
   - 设计实时更新机制（可选）：
     - 优秀问答实时入库
     - 自动审核规则

2. **数据质量监控**
   - 设计数据质量评估指标：
     - 示例完整性
     - 示例准确性
     - 示例时效性
   - 实现数据质量检查脚本
   - 建立数据质量报告机制

3. **检索效果优化**
   - 建立检索效果评估机制：
     - 检索命中率
     - 相似度分数分布
     - 用户反馈收集
   - 优化检索策略：
     - 调整相似度阈值
     - 优化向量化策略
     - 优化查询文本处理

4. **知识库扩展规划**
   - 科普资料库建设：
     - 医学知识文档整理
     - 健康科普文章收集
     - 定期更新机制
   - 多领域扩展：
     - 其他疾病领域的知识库
     - 多语言支持（如需要）

5. **运营维护流程**
   - 建立运营文档：
     - 数据更新操作手册
     - 问题排查指南
     - 性能优化建议
   - 建立定期review机制：
     - 每周/每月数据review
     - 检索效果分析
     - 用户反馈分析

6. **技术演进规划**
   - Embedding模型升级：
     - 评估新模型效果
     - 模型切换方案
   - 检索算法优化：
     - 混合检索（向量+关键词）
     - 重排序机制
   - 多模态支持（如需要）：
     - 图片、视频等多媒体内容

### 8.2 测试要点

1. **意图识别准确性**：节点1的意图识别准确率
2. **检索相关性**：节点2检索的示例是否相关
3. **回答质量**：节点3的回答质量是否提升
4. **性能**：整体流程的响应时间

### 8.3 监控指标

1. **节点1**：意图识别准确率、置信度分布
2. **节点2**：检索命中率、相似度分数分布
3. **节点3**：回答质量、工具调用成功率

---

## 九、总结

本方案通过**提示词聚合 + RAG增强**的设计，实现了：

1. **提示词精简**：节点3只保留核心流程，问答示例通过RAG动态获取
2. **知识库可扩展**：优秀的历史问答和科普资料可随时更新
3. **个性化增强**：结合用户基础信息，提供更精准的回答
4. **流程简化**：从多Agent分离改为三节点流程，更易维护

**关键设计点**：
- 节点1：快速意图识别 + 核心信息提取 + 查询文本优化
- 节点2：向量库检索 + 用户信息查询（函数节点）
- 节点3：统一Agent，动态注入检索示例和用户信息
- 向量库：多表设计，按内容类型分类，支持高效检索

---

**文档版本**：V1.0  
**创建时间**：2025-01-XX  
**最后更新**：2025-01-XX
