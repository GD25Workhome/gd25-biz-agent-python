# 动态流程总体设计文档

## 文档说明

本文档描述V7.2版本动态流程系统的总体设计思路和核心架构。相对于V7.1方案的改造，本方案对整个代码结构进行了系统性的升级和重构。

**文档版本**：V1.0 
**创建时间**：2026-01-04

---

## 一、设计目标与核心思想

### 1.1 设计目标

1. **流程配置化**：通过YAML配置文件定义完整的工作流程，实现流程的动态构建
2. **模块解耦**：各功能模块职责清晰，相互独立，便于维护和扩展
3. **统一管理**：提示词、模型配置、上下文等关键资源统一管理
4. **可扩展性**：支持多流程、多版本、热更新等高级特性
5. **标准化**：遵循LangGraph标准设计，减少定制化代码

### 1.2 核心设计思想

**配置驱动 + 模块化 + 标准化**

- **配置驱动**：流程结构、Agent配置、模型参数等均通过配置文件定义
- **模块化设计**：各功能模块独立，通过清晰的接口交互
- **标准化实现**：尽可能使用LangGraph标准机制，避免过度定制

---

## 二、核心架构概览

### 2.1 系统分层架构

```
┌─────────────────────────────────────────────────────────────┐
│                      应用层 (app/)                           │
│  - API路由                                                   │
│  - 配置管理                                                   │
└──────────────────────┬────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                    领域层 (domain/)                          │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │           流程管理模块 (flows/)                       │  │
│  │  - 流程定义（YAML解析）                               │  │
│  │  - 图构建（LangGraph）                                │  │
│  │  - 节点工厂（NodeFactory）                            │  │
│  │  - 流程管理器（FlowManager）                          │  │
│  └──────────────────────┬───────────────────────────────┘  │
│                         │                                    │
│  ┌──────────────────────┴───────────────────────────────┐  │
│  │          Agent系统 (agents/)                          │  │
│  │  - Agent工厂（支持模型参数配置）                       │  │
│  │  - Agent注册表                                        │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │          工具系统 (tools/)                            │  │
│  │  - 工具注册表（标准LangGraph工具机制）                │  │
│  │  - 工具包装器（TokenContext注入）                     │  │
│  │  - 业务工具实现                                       │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │          上下文管理 (context/)                        │  │
│  │  - 流程上下文（FlowContext）                          │  │
│  │  - 用户上下文（UserContext）                          │  │
│  │  - 上下文管理器（ContextManager）                     │  │
│  └──────────────────────────────────────────────────────┘  │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────┐
│                基础设施层 (infrastructure/)                   │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │        提示词管理 (prompts/)                          │  │
│  │  - 提示词管理器（启动时预加载，支持缓存）             │  │
│  │  - 提示词转换器（占位符替换）                         │  │
│  │  - 提示词加载器（本地/Langfuse/Nacos）                │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │        可观测性 (observability/)                      │  │
│  │  - Langfuse集成（唯一可观测性方案）                   │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │        模型供应商管理 (llm/providers/)                │  │
│  │  - 模型供应商配置管理                                 │  │
│  │  - 供应商注册表                                       │  │
│  │  - API密钥和Base URL管理                             │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │        LLM客户端 (llm/)                               │  │
│  │  - LLM客户端（支持多厂商、多模型）                    │  │
│  │  - 根据供应商配置创建LLM实例                          │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │        数据库层 (database/)                           │  │
│  │  - 数据模型（公共模块）                               │  │
│  │  - Repository（供前端CRUD和Tool使用）                 │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心模块说明

#### 2.2.1 流程管理模块（domain/flows/）

**职责**：流程定义、解析、构建和管理

**核心组件**：
- `FlowDefinition`：流程定义对象（采用方案一的类设计）
- `FlowParser`：YAML流程文件解析器
- `NodeFactory`：节点工厂（根据节点类型创建节点函数）
- `GraphBuilder`：图构建器（构建LangGraph图）
- `FlowManager`：流程管理器（流程加载、缓存、热更新）

**关键特性**：
- 支持YAML格式的流程定义
- 每个Agent节点可配置模型参数（模型名称、温度、厂商等）
- 支持流程热更新
- **延迟加载策略**：启动时只解析流程定义，不构建图；首次使用时才构建和编译图
- **预加载配置**：支持配置哪些流程需要预加载（常用流程），哪些按需加载（不常用流程）

#### 2.2.2 提示词管理模块（infrastructure/prompts/）

**职责**：提示词的统一管理和转换

**核心组件**：
- `PromptManager`：提示词管理器（被动加载，提供缓存）
- `PromptRenderer`：提示词转换器（从上下文取属性替换占位符）
- `PromptLoader`：提示词加载器（当前仅支持本地目录，后续扩展Langfuse/Nacos）

**关键特性**：
- **被动加载策略**：不在系统启动时预加载，只在流程加载时按需加载
- **流程关联加载**：流程预加载或首次使用时，根据流程配置中指定的提示词进行加载
- **缓存管理**：加载后的提示词缓存在内存中，后续直接使用
- 支持占位符替换（从流程上下文获取属性值）
- 为后续热更新、远程加载预留接口

#### 2.2.3 上下文管理模块（domain/context/）

**职责**：流程执行过程中的上下文管理

**核心组件**：
- `FlowContext`：流程上下文（流程级别的共享数据）
- `UserContext`：用户上下文（用户相关信息）
- `ContextManager`：上下文管理器（上下文生命周期管理）

**关键特性**：
- 流程上下文：存储流程执行过程中的共享数据，用于Agent间数据传递
- 用户上下文：存储用户信息、历史记录等
- 上下文作为提示词占位符替换的数据源

#### 2.2.4 模型供应商管理模块（infrastructure/llm/providers/）

**职责**：模型供应商的统一管理和配置

**核心组件**：
- `ProviderManager`：模型供应商管理器（加载和管理供应商配置）
- `ProviderRegistry`：供应商注册表（缓存供应商配置信息）
- `ProviderConfig`：供应商配置对象（API密钥、Base URL等）

**关键特性**：
- **配置化管理**：通过YAML配置文件定义模型供应商信息
- **供应商信息**：包含provider名称、api_key、base_url等
- **启动时加载**：系统启动时加载所有供应商配置
- **按需获取**：Agent创建时根据provider名称获取对应的供应商配置

**配置示例**：
```yaml
# config/model_providers.yaml
providers:
  - provider: "openai"
    api_key: "${OPENAI_API_KEY}"  # 支持环境变量
    base_url: "https://api.openai.com/v1"
  
  - provider: "doubao"
    api_key: "${DOUBAO_API_KEY}"
    base_url: "https://ark.cn-beijing.volces.com/api/v3"
  
  - provider: "deepseek"
    api_key: "${DEEPSEEK_API_KEY}"
    base_url: "https://api.deepseek.com"
```

#### 2.2.5 Agent系统（domain/agents/）

**职责**：Agent的创建和管理

**关键改造**：
- Agent节点配置支持模型参数（在流程YAML中配置）
- 模型参数包括：provider（引用供应商配置）、模型名称、温度等
- Agent创建时根据provider从ProviderManager获取供应商配置，然后初始化LLM客户端

#### 2.2.6 工具系统（domain/tools/）

**职责**：工具的统一管理和调用

**设计原则**：
- 保持现有工具系统设计（与LangGraph标准机制一致）
- 工具注册表：统一管理所有工具
- 工具包装器：自动注入TokenContext
- 业务工具：标准LangChain工具实现

**与LangGraph的关系**：
- 工具系统完全遵循LangGraph标准机制
- 使用LangChain的`BaseTool`和`@tool`装饰器
- 工具通过注册表管理，Agent从注册表获取工具
- 无需定制化改造

#### 2.2.7 可观测性模块（infrastructure/observability/）

**职责**：系统可观测性（仅保留Langfuse）

**关键改造**：
- **仅保留Langfuse**：作为唯一的可观测性方案
- **移除数据库日志**：不再将LLM调用日志写入数据库
- Langfuse负责：Trace追踪、Span记录、LLM调用日志

#### 2.2.8 数据库层（infrastructure/database/）

**职责**：数据持久化和数据访问（公共模块）

**设计定位**：
- **公共模块**：可供前端API和Tool工具使用
- **前端CRUD**：前端API通过Repository进行数据操作
- **Tool使用**：业务工具通过Repository访问数据库
- **统一接口**：Repository提供统一的数据访问接口

#### 2.2.9 外部服务集成（移除）

**移除内容**：
- `infrastructure/external/java_service.py`：不再需要Java服务集成

---

## 三、关键设计决策

### 3.1 流程配置化

**设计**：采用YAML格式定义流程，使用方案一的类设计（FlowDefinition、NodeDefinition、EdgeDefinition）

**模型供应商配置**（`config/model_providers.yaml`）：
```yaml
providers:
  - provider: "openai"
    api_key: "${OPENAI_API_KEY}"  # 支持环境变量
    base_url: "https://api.openai.com/v1"
  
  - provider: "doubao"
    api_key: "${DOUBAO_API_KEY}"
    base_url: "https://ark.cn-beijing.volces.com/api/v3"
  
  - provider: "deepseek"
    api_key: "${DEEPSEEK_API_KEY}"
    base_url: "https://api.deepseek.com"
```

**Agent节点模型参数配置**（在流程YAML中）：
```yaml
nodes:
  - name: "blood_pressure_agent"
    type: "agent"
    config:
      agent_key: "blood_pressure_agent"
      model:
        provider: "doubao"              # 引用模型供应商配置中的provider名称
        name: "doubao-seed-1-6-251015"  # 模型名称
        temperature: 0.7                # 温度参数
        # 其他模型参数...
```

**配置关系说明**：
- `provider`字段引用`config/model_providers.yaml`中定义的供应商配置
- 系统启动时加载所有供应商配置到ProviderManager
- Agent创建时，根据`provider`名称从ProviderManager获取对应的api_key和base_url
- 然后使用这些信息创建LLM客户端实例

**优势**：
- 流程结构可配置，无需修改代码
- 支持多流程、多版本
- Agent模型参数可灵活配置

### 3.2 流程加载策略（延迟加载 + 预加载）

**问题背景**：
- 如果系统有10个、100个流程，全部一次性加载会严重影响启动时间
- 构建LangGraph图需要创建节点、编译图等操作，耗时较长
- 不是所有流程都会立即使用，很多流程可能很少被调用

**设计策略**：延迟加载 + 预加载混合策略

**策略说明**：

1. **延迟加载（Lazy Loading）**
   - **启动时**：只解析YAML流程文件，生成`FlowDefinition`对象（不构建图）
   - **运行时**：首次使用流程时，才构建和编译`CompiledGraph`
   - **优势**：
     - 启动时间可控：解析YAML速度快，即使100个流程也很快
     - 内存占用小：只缓存流程定义，不缓存编译后的图
     - 按需编译：只编译实际使用的流程

2. **预加载（Preloading）**
   - **配置化**：通过配置文件指定需要预加载的流程（如主路由流程）
   - **启动时预加载**：常用流程在启动时构建和编译，确保首次请求快速响应
   - **适用场景**：
     - 主路由流程（高频使用）
     - 核心业务流程（高频使用）
     - 需要快速响应的流程

3. **混合策略**
   ```
   启动时：
   - 扫描所有流程文件（快速）
   - 解析所有流程定义（快速，只生成FlowDefinition对象）
   - 预加载常用流程（根据配置，只预加载指定流程的CompiledGraph）
   
   运行时：
   - 请求使用流程时，检查是否已编译
   - 如果未编译，立即构建和编译（按需加载）
   - 编译后的图缓存，后续直接使用
   ```

**FlowManager设计**：
```python
class FlowManager:
    """流程管理器：支持延迟加载和预加载"""
    
    # 缓存流程定义（启动时加载）
    _flow_definitions: Dict[str, FlowDefinition] = {}
    
    # 缓存编译后的图（按需或预加载）
    _compiled_graphs: Dict[str, CompiledGraph] = {}
    
    @classmethod
    def scan_flows(cls, flows_dir: str):
        """扫描流程文件，解析流程定义（不构建图）"""
        # 只解析YAML，生成FlowDefinition
        pass
    
    @classmethod
    def preload_flows(cls, flow_names: List[str]):
        """预加载指定流程（构建和编译图）"""
        # 构建和编译图
        pass
    
    @classmethod
    def get_flow(cls, flow_name: str) -> CompiledGraph:
        """获取流程图（按需加载）"""
        # 如果未编译，立即构建和编译
        if flow_name not in cls._compiled_graphs:
            cls._compile_flow(flow_name)
        return cls._compiled_graphs[flow_name]
```

**配置示例**：
```yaml
# config/flow_loader.yaml
flows:
  preload:  # 需要预加载的流程（启动时编译）
    - main_router_flow
    - blood_pressure_flow
  
  lazy_load:  # 按需加载的流程（首次使用时编译）
    - health_event_flow
    - medication_flow
    # ... 其他流程
```

**性能影响分析**：
- **启动时间**：
  - 解析100个流程定义：~1-2秒（只解析YAML）
  - 预加载2个常用流程：~2-3秒（构建和编译图）
  - 总启动时间：~3-5秒（可控）
  
- **运行时性能**：
  - 首次使用流程：需要编译，耗时~1-2秒（一次性）
  - 后续使用：直接从缓存获取，无额外耗时

**优势总结**：
- ✅ 启动时间可控，即使有100个流程也能快速启动
- ✅ 内存占用优化，只缓存实际使用的流程图
- ✅ 常用流程快速响应，预加载保证首次请求性能
- ✅ 灵活性高，可根据实际需求配置预加载列表

### 3.3 模型供应商管理

**设计**：供应商配置与模型参数分离

**问题背景**：
- 不同流程可能使用不同的模型供应商（OpenAI、豆包、DeepSeek等）
- 每个供应商需要不同的API密钥和Base URL
- 如果每个流程都配置完整的供应商信息，会导致配置冗余和维护困难

**设计策略**：供应商配置集中管理 + 流程配置引用

**策略说明**：

1. **供应商配置集中管理**
   - 在`config/model_providers.yaml`中统一配置所有模型供应商信息
   - 包含：provider名称、api_key、base_url
   - 支持环境变量（如`${DOUBAO_API_KEY}`）

2. **流程配置引用供应商**
   - 流程YAML配置中只需指定provider名称（引用供应商配置）
   - 指定模型名称（如`doubao-seed-1-6-251015`）
   - 指定模型参数（如temperature等）

3. **启动时加载**
   - 系统启动时加载所有供应商配置到ProviderManager
   - 供应商配置缓存在ProviderRegistry中
   - Agent创建时根据provider名称获取对应的供应商配置

**配置示例**：

**供应商配置**（`config/model_providers.yaml`）：
```yaml
providers:
  - provider: "openai"
    api_key: "${OPENAI_API_KEY}"
    base_url: "https://api.openai.com/v1"
  
  - provider: "doubao"
    api_key: "${DOUBAO_API_KEY}"
    base_url: "https://ark.cn-beijing.volces.com/api/v3"
  
  - provider: "deepseek"
    api_key: "${DEEPSEEK_API_KEY}"
    base_url: "https://api.deepseek.com"
```

**流程配置**（在流程YAML中）：
```yaml
nodes:
  - name: "blood_pressure_agent"
    type: "agent"
    config:
      model:
        provider: "doubao"              # 引用供应商配置
        name: "doubao-seed-1-6-251015" # 模型名称
        temperature: 0.7               # 模型参数
```

**优势**：
- ✅ 配置集中管理，便于维护
- ✅ 供应商信息与模型参数分离，职责清晰
- ✅ 支持环境变量，提高安全性
- ✅ 流程配置简洁，只需引用provider名称
- ✅ 易于扩展新的模型供应商

### 3.4 提示词统一管理

**设计**：被动加载策略

1. **被动加载**：不在系统启动时预加载所有提示词
   - 只有在流程加载时，才根据流程配置中指定的提示词进行加载
   - 流程预加载时：加载流程配置中指定的提示词
   - 流程按需加载时：首次使用流程时，加载流程配置中指定的提示词

2. **缓存管理**：
   - 加载后的提示词缓存在PromptManager中
   - 运行时从缓存获取，提高性能
   - 缓存一直保留，直到系统重启或手动清理

3. **占位符替换**：提示词转换模块从流程上下文获取属性值替换占位符

4. **扩展性**：为后续热更新、Langfuse/Nacos加载预留接口

**提示词加载时机**：
```
流程加载（预加载或按需加载）
  ↓
解析流程配置，获取流程中使用的提示词列表
  ↓
检查PromptManager缓存，加载未缓存的提示词
  ↓
提示词缓存在PromptManager中
  ↓
后续使用直接从缓存获取
```

**提示词转换流程**：
```
提示词模板（含占位符） → 从流程上下文获取属性 → 替换占位符 → 最终提示词
```

**上下文数据来源**：
- 流程上下文（FlowContext）：流程执行过程中的共享数据
- 用户上下文（UserContext）：用户信息、历史记录等
- 流程状态（RouterState）：当前状态信息

**优势**：
- ✅ 启动时间更短：不预加载所有提示词
- ✅ 按需加载：只加载实际使用的提示词
- ✅ 内存优化：只缓存实际使用的提示词
- ✅ 流程关联：提示词与流程绑定，逻辑更清晰

### 3.5 上下文管理重新设计

**设计思路**：

**保留的上下文内容**：
- `RouterState`：LangGraph状态（消息列表、当前意图等）
- `FlowContext`：流程级别的共享数据（Agent间传递的数据）
- `UserContext`：用户相关信息（用户信息、偏好等）
- `TokenContext`：Token上下文（用于工具参数注入）

**舍弃的上下文内容**：
- 移除与外部Java服务相关的上下文

**新增的上下文内容**：
- `FlowContext`：流程级别的共享缓存对象，用于Agent间数据传递和提示词占位符替换

**上下文层次结构**：
```
RouterState（LangGraph状态）
  ├── messages（消息列表）
  ├── current_intent（当前意图）
  └── ...
  
FlowContext（流程上下文）
  ├── user_info（用户信息）
  ├── conversation_history（对话历史）
  ├── extracted_data（提取的数据）
  └── ...（流程共享数据）

UserContext（用户上下文）
  ├── user_id（用户ID）
  ├── preferences（用户偏好）
  └── ...（用户相关数据）

TokenContext（Token上下文）
  └── token_id（Token ID，用于工具参数注入）
```

### 3.6 工具系统设计

**设计原则**：保持现有方案，完全遵循LangGraph标准机制

**当前方案评估**：
- ✅ 使用LangChain标准工具机制（`BaseTool`、`@tool`装饰器）
- ✅ 工具注册表管理工具
- ✅ 工具包装器自动注入TokenContext
- ✅ 与LangGraph标准机制一致，无需改造

**结论**：工具系统保持现有设计，无需修改

### 3.7 可观测性简化

**设计决策**：
- **仅保留Langfuse**：作为唯一的可观测性方案
- **移除数据库日志**：不再将LLM调用日志写入数据库（`infrastructure/observability/llm_logger.py`可移除或标记为废弃）

**Langfuse职责**：
- Trace追踪：完整追踪请求链路
- Span记录：记录每个节点的执行情况
- LLM调用日志：记录所有LLM调用（输入、输出、参数等）
- 元数据管理：记录相关的元数据信息

**优势**：
- 简化系统架构
- 统一可观测性方案
- 减少数据库写入压力

### 3.8 数据库层公共化

**设计定位**：数据库层作为公共模块，供前端API和Tool工具使用

**使用场景**：
1. **前端API**：通过Repository进行数据CRUD操作
2. **Tool工具**：业务工具通过Repository访问数据库
3. **统一接口**：Repository提供统一的数据访问接口

**模块结构**：
```
infrastructure/database/
├── models/          # 数据模型（SQLAlchemy ORM）
├── repository/      # Repository接口（公共模块）
└── connection.py    # 数据库连接管理
```

### 3.9 外部服务集成移除

**移除内容**：
- `infrastructure/external/java_service.py`：不再需要Java服务集成
- 相关的配置和依赖

**影响范围**：
- 如果工具中有使用Java服务的，需要移除或替换为其他实现

---

## 四、核心数据流

### 4.1 系统启动流程

```
1. 加载配置（.env文件）
   ↓
2. 初始化数据库连接池
   ↓
3. 加载模型供应商配置（ProviderManager加载config/model_providers.yaml）
   ↓
4. 初始化工具注册表（注册所有业务工具）
   ↓
5. 扫描流程文件（FlowManager扫描YAML流程文件）
   ↓
6. 解析流程定义（FlowParser解析流程定义，不构建图）
   ↓
7. 预加载常用流程（根据配置预加载常用流程的编译图）
   - 流程加载时，根据流程配置中指定的提示词进行加载（被动加载）
   - 加载的提示词缓存在PromptManager中
   ↓
8. 应用启动完成（其他流程和提示词按需加载）
```

**流程加载策略说明**：
- **阶段1（启动时）**：只解析流程定义（FlowDefinition），不构建图（CompiledGraph）
  - 解析YAML文件速度快，内存占用小
  - 即使有100个流程，启动时间也可控
  - **不预加载提示词**：提示词采用被动加载策略
  
- **阶段2（启动时）**：根据配置预加载常用流程
  - 配置文件中指定需要预加载的流程（如主路由流程）
  - 只有预加载的流程会构建和编译图
  - **提示词被动加载**：流程加载时，根据流程配置中指定的提示词进行加载
  - 加载的提示词缓存在PromptManager中，后续直接使用
  
- **阶段3（运行时）**：按需加载流程
  - 首次使用某个流程时，才构建和编译图
  - **提示词按需加载**：流程首次使用时，根据流程配置加载所需的提示词
  - 编译后的图和提示词都会缓存，后续使用直接获取

### 4.2 请求处理流程

```
1. 接收请求（API层）
   ↓
2. 确定使用的流程（从请求或配置获取流程名称）
   ↓
3. 获取流程图（FlowManager.get_flow，支持按需加载）
   - 如果流程已编译：直接从缓存获取
   - 如果流程未编译：立即构建和编译（按需加载）
   - **提示词被动加载**：流程加载时，根据流程配置加载所需的提示词
   ↓
4. 构建初始状态（RouterState）
   ↓
5. 初始化流程上下文（FlowContext）
   ↓
6. 执行流程图（LangGraph执行）
   ↓
7. Agent节点执行：
   - 从PromptManager获取提示词模板（从缓存获取，如果未加载则按需加载）
   - 从FlowContext获取上下文数据
   - PromptRenderer替换占位符
   - 根据节点配置的provider从ProviderManager获取供应商配置
   - 根据供应商配置和模型参数创建LLM客户端
   - 执行Agent（调用LLM和工具）
   - 更新FlowContext（提取的数据等）
   ↓
8. 返回结果
```

**流程获取说明**：
- FlowManager.get_flow()方法支持按需加载
- 如果流程未编译，会在首次使用时自动编译并缓存
- 预加载的流程直接返回，无额外耗时
- **提示词加载**：流程加载时，根据流程配置中指定的提示词进行加载并缓存

### 4.3 提示词处理流程

```
1. Agent节点需要提示词
   ↓
2. PromptManager获取提示词（被动加载）
   - 检查缓存中是否存在提示词
   - 如果不存在：根据流程配置加载提示词并缓存
   - 如果存在：直接从缓存获取
   ↓
3. PromptRenderer从FlowContext/UserContext获取属性值
   ↓
4. 替换占位符（{{user_name}}、{{conversation_history}}等）
   ↓
5. 返回最终提示词给Agent
```

**提示词加载说明**：
- 提示词采用被动加载策略，不在系统启动时预加载
- 流程加载时，根据流程配置中指定的提示词进行加载
- 加载后的提示词缓存在PromptManager中，后续直接使用
- 如果Agent节点需要提示词但未加载，会在首次使用时按需加载

---

## 五、关键改造点总结

### 5.1 新增模块

1. **流程管理模块**（`domain/flows/`）
   - FlowDefinition、FlowParser、NodeFactory、GraphBuilder、FlowManager

2. **模型供应商管理模块**（`infrastructure/llm/providers/`）
   - ProviderManager：模型供应商管理器
   - ProviderRegistry：供应商注册表
   - ProviderConfig：供应商配置对象

3. **上下文管理模块**（`domain/context/`）
   - FlowContext、UserContext、ContextManager

4. **提示词转换模块**（`infrastructure/prompts/renderer.py`）
   - PromptRenderer：从上下文取属性替换占位符

### 5.2 改造模块

1. **Agent系统**（`domain/agents/`）
   - 支持在流程节点配置中指定模型参数
   - Agent创建时根据配置初始化LLM客户端

2. **LLM客户端模块**（`infrastructure/llm/`）
   - 支持从ProviderManager获取供应商配置
   - 根据供应商配置和模型参数创建LLM客户端实例

3. **提示词管理模块**（`infrastructure/prompts/`）
   - PromptManager：改为被动加载策略，流程加载时按需加载提示词
   - 提示词缓存在内存中，后续直接使用
   - 为后续热更新、远程加载预留接口

3. **路由图构建**（`domain/router/graph.py`）
   - 从硬编码改为使用FlowManager加载流程

### 5.3 移除模块

1. **可观测性**（`infrastructure/observability/llm_logger.py`）
   - 移除数据库日志功能（仅保留Langfuse）

2. **外部服务集成**（`infrastructure/external/java_service.py`）
   - 移除Java服务集成

### 5.4 保持不变模块

1. **工具系统**（`domain/tools/`）
   - 保持现有设计，完全遵循LangGraph标准

2. **数据库层**（`infrastructure/database/`）
   - 保持现有Repository设计
   - 定位为公共模块，供前端和Tool使用

3. **Langfuse集成**（`infrastructure/observability/langfuse_handler.py`）
   - 保持不变，作为唯一可观测性方案

---

## 六、设计原则与约束

### 6.1 设计原则

1. **配置驱动**：流程结构、Agent配置、模型参数等均通过配置文件定义
2. **模块解耦**：各功能模块职责清晰，相互独立
3. **标准化**：遵循LangGraph和LangChain标准机制，减少定制化
4. **可扩展性**：支持多流程、多版本、热更新等高级特性
5. **性能优先**：提示词预加载缓存、流程缓存等性能优化

### 6.2 技术约束

1. **LangGraph标准**：遵循LangGraph的图构建和状态管理机制
2. **LangChain标准**：工具系统使用LangChain标准工具机制
3. **异步支持**：所有I/O操作使用异步方式
4. **类型安全**：使用类型提示保证代码质量

### 6.3 兼容性约束

1. **向后兼容**：尽量保持现有API接口不变
2. **平滑迁移**：支持渐进式迁移，新旧方案可共存
3. **配置兼容**：Agent配置文件格式保持兼容

---

## 七、后续扩展方向

### 7.1 提示词管理扩展

1. **热更新能力**：支持提示词模板的热更新（无需重启服务）
2. **远程加载**：支持从Langfuse、Nacos等远程服务加载提示词
3. **版本管理**：支持提示词版本管理和回滚

### 7.2 流程管理扩展

1. **多流程支持**：支持多个流程并行运行
2. **流程版本管理**：支持流程版本管理和A/B测试
3. **流程热更新**：支持流程配置的热更新

### 7.3 上下文管理扩展

1. **上下文持久化**：支持上下文数据的持久化存储
2. **上下文共享**：支持跨流程的上下文共享
3. **上下文清理**：支持上下文数据的自动清理机制

---

## 八、总结

### 8.1 核心改进

1. **流程配置化**：通过YAML定义流程，实现流程的动态构建
2. **模型供应商管理**：供应商配置集中管理，流程配置通过provider名称引用，支持环境变量
3. **提示词统一管理**：启动时预加载，运行时缓存，支持占位符替换
4. **上下文管理优化**：重新设计上下文结构，支持Agent间数据传递
5. **系统简化**：移除数据库日志和Java服务集成，仅保留Langfuse可观测性
6. **模块公共化**：数据库层作为公共模块，供前端和Tool使用

### 8.2 设计亮点

1. **标准化设计**：遵循LangGraph标准，减少定制化代码
2. **模块化架构**：各模块职责清晰，便于维护和扩展
3. **性能优化**：提示词预加载、流程缓存等性能优化
4. **可扩展性**：为后续热更新、远程加载等特性预留接口

### 8.3 实施建议

1. **渐进式改造**：先实现核心模块，再逐步替换旧代码
2. **充分测试**：流程配置化涉及核心逻辑，需要充分测试
3. **文档完善**：更新开发文档，说明新架构和使用方式
4. **向后兼容**：尽量保持现有API接口不变，支持平滑迁移

---

**文档版本**：V1.0  
**创建时间**：2025-01-XX  
**对应代码路径**：`/Users/m684620/work/github_GD25/gd25-biz-agent-python_cursor`

