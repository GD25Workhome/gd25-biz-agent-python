# 血压提示词模版替换异常问题分析

## 问题描述

在给到模型的提示词中，部分占位符丢失，具体表现为：

```
用户ID: {{user_id}}          # ❌ 未替换
会话ID: {{session_id}}        # ❌ 未替换
当前日期: 2025-12-30          # ✅ 已替换
患者基础信息: {{user_info}}   # ❌ 未替换
历史回话信息: {{history_msg}} # ❌ 未替换
```

## 代码位置

- **API 路由**：`app/api/routes.py:24-25`（`/chat` 接口）
- **提示词原始文件**：`config/prompts/local/blood_pressure_agent_prompt.txt`

## 代码流程分析

### 1. 提示词加载流程

#### 1.1 Agent 创建阶段（`domain/agents/factory.py`）

```261:264:domain/agents/factory.py
# 填充占位符（Agent创建时没有state，只填充Agent特定占位符）
if system_prompt:
    placeholders = PlaceholderManager.get_placeholders(agent_key, state=None)
    system_prompt = PlaceholderManager.fill_placeholders(system_prompt, placeholders)
```

**关键问题**：Agent 在创建时（`AgentFactory.create_agent`）就填充占位符，此时 `state=None`，所以只能填充时间相关的占位符。

#### 1.2 占位符管理器逻辑（`infrastructure/prompts/placeholder.py`）

```165:204:infrastructure/prompts/placeholder.py
@classmethod
def get_placeholders(cls, agent_key: str, state: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    获取占位符值
    
    Args:
        agent_key: Agent键名
        state: 路由状态（可选，如果不提供则只返回Agent特定占位符）
    
    Returns:
        占位符字典
    """
    placeholders = {}
    
    # 系统占位符（需要state）
    if state:
        for key, getter in cls.SYSTEM_PLACEHOLDERS.items():
            try:
                value = getter(state)
                placeholders[key] = value
            except Exception as e:
                logger.warning(f"获取系统占位符失败: {key}, 错误: {e}")
                placeholders[key] = ""
        
        # 特殊处理 history_msg（从state中的messages格式化）
        try:
            placeholders["history_msg"] = cls._format_history_msg_from_state(state)
        except Exception as e:
            logger.warning(f"获取历史消息占位符失败, 错误: {e}")
            placeholders["history_msg"] = "暂无历史对话"
    else:
        # 如果没有state，只设置时间相关的占位符
        placeholders["current_date"] = datetime.now().strftime("%Y-%m-%d")
        placeholders["current_time"] = datetime.now().strftime("%H:%M:%S")
        placeholders["current_datetime"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Agent特定占位符
    if agent_key in cls.AGENT_PLACEHOLDERS:
        placeholders.update(cls.AGENT_PLACEHOLDERS[agent_key])
    
    return placeholders
```

**关键发现**：
- 当 `state=None` 时，只返回时间相关的占位符（`current_date`, `current_time`, `current_datetime`）
- 当 `state` 不为 `None` 时，才会从 state 中提取 `user_id`, `session_id`, `user_info`, `history_msg` 等

#### 1.3 Agent 运行时调用（`domain/router/graph.py`）

```60:181:domain/router/graph.py
async def _run(state: RouterState) -> RouterState:
    messages = state.get("messages", [])
    user_id = state.get("user_id")
    
    # ... 省略部分代码 ...
    
    # 直接调用 Agent，由 LLM 决定如何回复和是否调用工具
    result = await agent_node.ainvoke({"messages": messages})
```

**关键问题**：Agent 在运行时被调用时，提示词已经在创建时固定了，不会再进行占位符替换。

### 2. 数据流转路径

```
API 请求 (routes.py)
  ↓
构建 initial_state（包含 user_id, session_id, user_info, history_msg, current_date）
  ↓
路由图执行 (router_graph.astream)
  ↓
路由到 Agent 节点 (with_user_context)
  ↓
调用 Agent (agent_node.ainvoke)
  ↓
❌ 问题：提示词中的占位符未替换（因为提示词在 Agent 创建时已固定）
```

### 3. 问题根源

**核心问题**：占位符填充时机错误

1. **当前实现**：
   - Agent 创建时（`AgentFactory.create_agent`）→ 填充占位符（`state=None`）→ 只能填充时间相关占位符
   - Agent 运行时（`with_user_context`）→ 提示词已固定，占位符未替换

2. **期望行为**：
   - Agent 创建时 → 保留占位符标记（不填充需要从 state 中获取的占位符）
   - Agent 运行时 → 从 state 中获取占位符值 → 动态替换提示词中的占位符

## 修复方案

### 方案一：运行时动态替换占位符（推荐）

在 `with_user_context` 函数中，在调用 Agent 之前，动态替换系统消息中的占位符。

**修改位置**：`domain/router/graph.py` 的 `with_user_context` 函数

**实现步骤**：
1. 在 Agent 创建时，不填充需要从 state 中获取的占位符（保留占位符标记）
2. 在运行时（`with_user_context` 中），从 state 中获取占位符值
3. 在调用 Agent 之前，查找并替换系统消息中的占位符

**优点**：
- 不影响 Agent 缓存机制
- 每个请求都能使用正确的占位符值
- 实现相对简单

**缺点**：
- 需要在运行时处理系统消息
- 需要确保系统消息在消息列表中的位置

### 方案二：延迟提示词填充

修改 `AgentFactory`，不在创建时填充占位符，而是在运行时填充。

**实现步骤**：
1. Agent 创建时，保留原始提示词模板（包含占位符）
2. 在运行时（`with_user_context` 中），从 state 中获取占位符值
3. 动态生成完整的提示词，并作为系统消息插入到消息列表

**优点**：
- 逻辑清晰，占位符替换集中在一处
- 不依赖 Agent 内部的提示词结构

**缺点**：
- 需要修改 Agent 创建逻辑
- 可能影响 Agent 缓存机制

### 方案三：使用 LangGraph 的系统消息机制

利用 LangGraph 的系统消息机制，在运行时动态注入系统消息。

**实现步骤**：
1. Agent 创建时，使用不包含占位符的基础提示词
2. 在运行时，根据 state 动态生成包含完整上下文的系统消息
3. 将系统消息插入到消息列表的开头

**优点**：
- 符合 LangGraph 的设计模式
- 系统消息和用户消息分离，逻辑清晰

**缺点**：
- 需要确保系统消息格式正确
- 可能与现有的系统消息机制冲突

## 推荐方案详细设计

### 方案一：运行时动态替换占位符

#### 1. 修改 Agent 创建逻辑

**文件**：`domain/agents/factory.py`

```python
# 在 _create_agent_internal 方法中
# 修改前：填充所有占位符（但 state=None，只能填充时间相关）
placeholders = PlaceholderManager.get_placeholders(agent_key, state=None)
system_prompt = PlaceholderManager.fill_placeholders(system_prompt, placeholders)

# 修改后：只填充时间相关占位符，保留需要从 state 中获取的占位符标记
# 只填充时间相关占位符（这些不依赖 state）
time_placeholders = {
    "current_date": datetime.now().strftime("%Y-%m-%d"),
    "current_time": datetime.now().strftime("%H:%M:%S"),
    "current_datetime": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
}
system_prompt = PlaceholderManager.fill_placeholders(system_prompt, time_placeholders)

# 保留需要从 state 中获取的占位符标记（user_id, session_id, user_info, history_msg）
# 这些占位符将在运行时替换
```

#### 2. 修改运行时逻辑

**文件**：`domain/router/graph.py`

在 `with_user_context` 函数中，在调用 Agent 之前，动态替换系统消息中的占位符：

```python
async def _run(state: RouterState) -> RouterState:
    messages = state.get("messages", [])
    user_id = state.get("user_id")
    
    # ... 现有代码 ...
    
    # 在调用 Agent 之前，替换系统消息中的占位符
    # 1. 从 state 中获取占位符值
    placeholders = PlaceholderManager.get_placeholders(agent_name, state=state)
    
    # 2. 查找系统消息并替换占位符
    for i, msg in enumerate(messages):
        if isinstance(msg, SystemMessage):
            # 替换系统消息中的占位符
            original_content = msg.content
            filled_content = PlaceholderManager.fill_placeholders(original_content, placeholders)
            if original_content != filled_content:
                messages[i] = SystemMessage(content=filled_content)
                logger.debug(f"已替换系统消息中的占位符: {agent_name}")
            break
    
    # 3. 调用 Agent
    result = await agent_node.ainvoke({"messages": messages})
    
    # ... 现有代码 ...
```

#### 3. 占位符替换逻辑

**文件**：`infrastructure/prompts/placeholder.py`

现有的 `fill_placeholders` 方法已经支持占位符替换，无需修改：

```207:233:infrastructure/prompts/placeholder.py
@classmethod
def fill_placeholders(cls, template: str, placeholders: Dict[str, Any]) -> str:
    """
    填充占位符到模版中
    
    Args:
        template: 模版内容（支持 {{placeholder_name}} 格式）
        placeholders: 占位符字典
    
    Returns:
        填充后的模版内容
    """
    result = template
    
    # 替换所有占位符
    for key, value in placeholders.items():
        placeholder = f"{{{{{key}}}}}"
        if placeholder in result:
            result = result.replace(placeholder, str(value))
            logger.debug(f"填充占位符: {key} = {value}")
    
    # 检查是否有未填充的占位符（警告）
    import re
    remaining_placeholders = re.findall(r'\{\{(\w+)\}\}', result)
    if remaining_placeholders:
        logger.warning(f"模版中存在未填充的占位符: {remaining_placeholders}")
    
    return result
```

## 实施建议

1. **优先级**：高（影响核心功能）
2. **影响范围**：所有使用占位符的 Agent
3. **测试重点**：
   - 验证占位符替换是否正确
   - 验证 Agent 缓存机制是否正常
   - 验证多轮对话中占位符替换是否一致
4. **回滚方案**：如果出现问题，可以回滚到 Agent 创建时填充占位符（但会丢失动态性）

## 相关文件清单

- `domain/agents/factory.py` - Agent 创建逻辑
- `domain/router/graph.py` - Agent 运行时调用逻辑
- `infrastructure/prompts/placeholder.py` - 占位符管理逻辑
- `app/api/routes.py` - API 路由，构建 initial_state
- `config/prompts/local/blood_pressure_agent_prompt.txt` - 提示词模板文件

## 总结

问题的根本原因是**占位符填充时机错误**：Agent 在创建时（没有 state）就填充占位符，导致需要从 state 中获取的占位符（`user_id`, `session_id`, `user_info`, `history_msg`）无法填充。

**推荐解决方案**：在运行时（`with_user_context` 函数中）动态替换系统消息中的占位符，确保每个请求都能使用正确的占位符值。

