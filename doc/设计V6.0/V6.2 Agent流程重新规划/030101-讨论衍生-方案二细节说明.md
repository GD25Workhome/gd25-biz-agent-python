# 方案二：自动注入 tokenId 详细实现说明

## 一、方案概述

### 1.1 核心目标

在工具调用时自动注入 `tokenId`，而不依赖 LLM 显式传递，提高工具调用的可靠性和一致性。

### 1.2 技术挑战

1. **时机问题**：Agent 在路由图创建时一次性创建（`domain/router/graph.py:257`），此时还没有 `tokenId`（`tokenId` 在运行时从 `RouterState` 中获取）
2. **注入点**：需要在工具实际调用时注入 `tokenId`，而不是在 Agent 创建时
3. **兼容性**：需要保持与 LangChain 工具系统的兼容性，不影响现有功能

### 1.3 解决方案选择

经过分析，推荐使用**自定义 Tool 包装类**方案，原因：
- ✅ 实现简单，易于维护
- ✅ 对现有代码影响小
- ✅ 不需要修改 LangGraph 的内部机制
- ✅ 支持运行时动态注入

## 二、技术实现方案

### 2.1 架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                    Agent 创建阶段（启动时）                    │
├─────────────────────────────────────────────────────────────┤
│ 1. AgentFactory.create_agent()                             │
│ 2. 从 TOOL_REGISTRY 获取原始工具                            │
│ 3. 使用 TokenInjectedTool 包装工具                          │
│ 4. 创建 Agent（使用包装后的工具）                            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                  Agent 执行阶段（运行时）                     │
├─────────────────────────────────────────────────────────────┤
│ 1. with_user_context 从 state 获取 tokenId                  │
│ 2. 设置工具上下文（通过 contextvars 或工具绑定）             │
│ 3. Agent 调用工具                                            │
│ 4. TokenInjectedTool.ainvoke() 拦截调用                     │
│ 5. 自动注入 tokenId 到工具参数                              │
│ 6. 调用原始工具函数                                          │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心组件设计

#### 2.2.1 TokenInjectedTool 类

创建一个工具包装类，用于在工具调用时自动注入 `tokenId`。

**文件位置**：`domain/tools/wrapper.py`

**设计要点**：
1. 继承或包装 `BaseTool`，保持与 LangChain 的兼容性
2. 使用 `contextvars` 或闭包机制存储 `tokenId`
3. 重写 `invoke` 和 `ainvoke` 方法，在调用时注入 `tokenId`
4. 保持原始工具的所有属性和行为

#### 2.2.2 工具上下文管理器

创建一个上下文管理器，用于在 Agent 执行时设置 `tokenId`。

**文件位置**：`domain/tools/context.py`

**设计要点**：
1. 使用 `contextvars` 实现线程安全的上下文传递
2. 在 `with_user_context` 中设置上下文
3. 工具包装类从上下文中读取 `tokenId`

#### 2.2.3 工具包装工厂

创建一个工厂函数，用于批量包装工具。

**文件位置**：`domain/tools/wrapper.py`

**设计要点**：
1. 提供 `wrap_tools_with_token_context()` 函数
2. 批量包装工具列表
3. 保持工具名称和描述不变

### 2.3 详细实现代码

#### 2.3.1 工具上下文管理器（contextvars 方案）

```python
"""
工具上下文管理器
使用 contextvars 实现线程安全的 tokenId 传递
"""
import contextvars
from typing import Optional

# 创建上下文变量
_token_id_context: contextvars.ContextVar[Optional[str]] = contextvars.ContextVar(
    'token_id', default=None
)


def set_token_id(token_id: str) -> None:
    """
    设置当前上下文的 tokenId
    
    Args:
        token_id: 令牌ID
    """
    _token_id_context.set(token_id)


def get_token_id() -> Optional[str]:
    """
    获取当前上下文的 tokenId
    
    Returns:
        令牌ID，如果未设置则返回 None
    """
    return _token_id_context.get()


class TokenContext:
    """
    工具上下文管理器（上下文管理器协议）
    
    使用示例：
        with TokenContext(token_id="xxx"):
            # 在此上下文中，工具可以获取 token_id
            tool.invoke(...)
    """
    
    def __init__(self, token_id: str):
        """
        初始化上下文管理器
        
        Args:
            token_id: 令牌ID
        """
        self.token_id = token_id
        self._token = None
    
    def __enter__(self):
        """进入上下文"""
        self._token = _token_id_context.set(self.token_id)
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文，恢复之前的上下文"""
        if self._token is not None:
            _token_id_context.reset(self._token)
        return False
```

#### 2.3.2 TokenInjectedTool 类（完整实现）

```python
"""
工具包装器：自动注入 tokenId
"""
import inspect
from typing import Any, Dict, Optional, Type
from langchain_core.tools import BaseTool, StructuredTool
from langchain_core.callbacks import CallbackManagerForToolRun, AsyncCallbackManagerForToolRun

from domain.tools.context import get_token_id, TokenContext


class TokenInjectedTool(BaseTool):
    """
    工具包装器：在工具调用时自动注入 tokenId
    
    工作原理：
    1. 包装原始工具，保持所有属性和行为
    2. 在 invoke/ainvoke 时，从上下文获取 tokenId
    3. 自动将 tokenId 注入到工具参数中
    4. 调用原始工具函数
    """
    
    def __init__(
        self,
        tool: BaseTool,
        token_id_param_name: str = "token_id",
        require_token: bool = True
    ):
        """
        初始化工具包装器
        
        Args:
            tool: 原始工具实例
            token_id_param_name: tokenId 参数名称（默认为 "token_id"）
            require_token: 是否要求 tokenId 必须存在（默认 True）
        """
        self._original_tool = tool
        self._token_id_param_name = token_id_param_name
        self._require_token = require_token
        
        # 继承原始工具的所有属性
        super().__init__(
            name=tool.name,
            description=tool.description,
            args_schema=tool.args_schema,
        )
    
    @property
    def original_tool(self) -> BaseTool:
        """获取原始工具实例"""
        return self._original_tool
    
    def _inject_token_id(self, tool_input: Dict[str, Any]) -> Dict[str, Any]:
        """
        注入 tokenId 到工具参数中
        
        Args:
            tool_input: 工具输入参数字典
            
        Returns:
            注入 tokenId 后的参数字典
            
        Raises:
            ValueError: 如果 require_token=True 但 tokenId 不存在
        """
        # 从上下文获取 tokenId
        token_id = get_token_id()
        
        # 检查 tokenId 是否存在
        if token_id is None:
            if self._require_token:
                raise ValueError(
                    f"工具 {self.name} 需要 tokenId，但上下文中未设置。"
                    f"请确保在调用工具前使用 TokenContext 设置 tokenId。"
                )
            else:
                # 如果不需要 tokenId，直接返回原参数
                return tool_input
        
        # 检查参数中是否已经存在 token_id（避免重复注入）
        if self._token_id_param_name in tool_input:
            # 如果已存在，使用已有的值（LLM 可能已经传递）
            # 但记录警告，说明应该依赖自动注入
            import logging
            logger = logging.getLogger(__name__)
            logger.warning(
                f"工具 {self.name} 的参数中已存在 {self._token_id_param_name}，"
                f"将使用自动注入的值覆盖。"
            )
        
        # 注入 tokenId
        tool_input[self._token_id_param_name] = token_id
        
        return tool_input
    
    def _invoke(
        self,
        tool_input: Dict[str, Any],
        run_manager: Optional[CallbackManagerForToolRun] = None,
    ) -> Any:
        """
        同步调用工具（自动注入 tokenId）
        
        Args:
            tool_input: 工具输入参数
            run_manager: 回调管理器
            
        Returns:
            工具执行结果
        """
        # 注入 tokenId
        injected_input = self._inject_token_id(tool_input)
        
        # 调用原始工具
        return self._original_tool.invoke(injected_input, run_manager=run_manager)
    
    async def _ainvoke(
        self,
        tool_input: Dict[str, Any],
        run_manager: Optional[AsyncCallbackManagerForToolRun] = None,
    ) -> Any:
        """
        异步调用工具（自动注入 tokenId）
        
        Args:
            tool_input: 工具输入参数
            run_manager: 异步回调管理器
            
        Returns:
            工具执行结果
        """
        # 注入 tokenId
        injected_input = self._inject_token_id(tool_input)
        
        # 调用原始工具
        return await self._original_tool.ainvoke(injected_input, run_manager=run_manager)
    
    def __getattr__(self, name: str) -> Any:
        """
        代理原始工具的其他属性
        
        这样可以让包装后的工具保持原始工具的所有行为
        """
        return getattr(self._original_tool, name)
```

#### 2.3.3 工具包装工厂函数

```python
"""
工具包装工厂
"""
from typing import List
from langchain_core.tools import BaseTool

from domain.tools.wrapper import TokenInjectedTool


def wrap_tools_with_token_context(
    tools: List[BaseTool],
    token_id_param_name: str = "token_id",
    require_token: bool = True
) -> List[BaseTool]:
    """
    批量包装工具，使其支持自动注入 tokenId
    
    Args:
        tools: 原始工具列表
        token_id_param_name: tokenId 参数名称（默认为 "token_id"）
        require_token: 是否要求 tokenId 必须存在（默认 True）
        
    Returns:
        包装后的工具列表
    """
    wrapped_tools = []
    for tool in tools:
        # 检查工具是否已经是包装后的工具
        if isinstance(tool, TokenInjectedTool):
            # 如果已经是包装后的工具，直接使用
            wrapped_tools.append(tool)
        else:
            # 包装工具
            wrapped_tool = TokenInjectedTool(
                tool=tool,
                token_id_param_name=token_id_param_name,
                require_token=require_token
            )
            wrapped_tools.append(wrapped_tool)
    
    return wrapped_tools
```

### 2.4 集成到现有架构

#### 2.4.1 修改 AgentFactory

在 `domain/agents/factory.py` 中，修改 `_create_agent_internal` 方法，使用包装后的工具：

```python
from domain.tools.wrapper import wrap_tools_with_token_context

@classmethod
def _create_agent_internal(
    cls,
    agent_key: str,
    llm: Optional[BaseChatModel] = None,
    tools: Optional[List[BaseTool]] = None
) -> CompiledStateGraph:
    """
    内部方法：实际创建智能体（不涉及缓存）
    """
    # ... 前面的代码保持不变 ...
    
    # 2. 获取工具列表
    if not tools:
        tool_names = agent_config.get("tools", [])
        tools = [
            TOOL_REGISTRY[name]
            for name in tool_names
            if name in TOOL_REGISTRY
        ]
    
    # 2.5. 包装工具，使其支持自动注入 tokenId
    # 注意：这里只是包装工具，tokenId 将在运行时从上下文获取
    tools = wrap_tools_with_token_context(
        tools,
        token_id_param_name="token_id",
        require_token=True
    )
    
    # ... 后面的代码保持不变 ...
```

#### 2.4.2 修改 with_user_context

在 `domain/router/graph.py` 中，修改 `with_user_context` 函数，设置工具上下文：

```python
from domain.tools.context import TokenContext

def with_user_context(agent_node, agent_name: str):
    """
    为智能体包装系统指令，动态注入完整的上下文信息。
    """
    async def _run(state: RouterState) -> RouterState:
        messages = state.get("messages", [])
        user_id = state.get("user_id")
        session_id = state.get("session_id")
        
        # ... 前面的代码保持不变（系统消息注入等）...
        
        # 6. 调用 Agent（在 TokenContext 中调用，以便工具可以获取 tokenId）
        # 当前场景：tokenId = userId
        token_id = user_id  # 未来可以从 state 中获取 token_id 字段
        
        logger.info(
            f"[AGENT_INVOKE] 调用智能体: {agent_name}, "
            f"session_id={session_id}, user_id={user_id}, token_id={token_id}, "
            f"messages_count={len(messages_with_context)}"
        )
        
        # 在 TokenContext 中调用 Agent，工具可以自动获取 tokenId
        with TokenContext(token_id=token_id):
            # ... Langfuse Span 追踪代码 ...
            if (settings.LANGFUSE_ENABLED and 
                settings.LANGFUSE_ENABLE_SPANS and 
                langfuse_client and 
                trace_id):
                # ... Span 追踪代码 ...
                try:
                    span_params["trace_context"] = {"trace_id": normalized_trace_id}
                    with langfuse_client.start_as_current_span(**span_params):
                        result = await agent_node.ainvoke({"messages": messages_with_context})
                except Exception as e:
                    # ... 错误处理 ...
                    result = await agent_node.ainvoke({"messages": messages_with_context})
            else:
                result = await agent_node.ainvoke({"messages": messages_with_context})
        
        # ... 后面的代码保持不变 ...
    
    _run.__name__ = f"{agent_name}_with_user_context"
    return _run
```

### 2.5 工具函数改造

#### 2.5.1 修改工具函数签名

所有工具函数需要将 `user_id` 参数改为 `token_id`：

**改造前：**
```python
@tool
async def record_blood_pressure(
    user_id: str,
    systolic: int,
    diastolic: int,
    ...
) -> str:
```

**改造后：**
```python
@tool
async def record_blood_pressure(
    token_id: str,  # 自动注入的参数
    systolic: int,
    diastolic: int,
    ...
) -> str:
    # 工具内部数据转换
    from domain.tools.utils.token_converter import convert_token_to_user_id
    user_id = convert_token_to_user_id(token_id)
    
    # 后续业务逻辑保持不变
    ...
```

#### 2.5.2 创建数据转换工具模块

**文件位置**：`domain/tools/utils/token_converter.py`

```python
"""
TokenId 数据转换工具
"""
from typing import Optional, Dict, List


def convert_token_to_user_id(token_id: str) -> str:
    """
    将 tokenId 转换为 userId
    
    当前场景：直接返回 token_id（因为 token_id = user_id）
    未来场景：通过 token_id 查询业务系统，获取 user_id
    
    Args:
        token_id: 令牌ID
        
    Returns:
        用户ID
    """
    # 当前实现：直接返回
    return token_id
    
    # 未来实现示例：
    # from infrastructure.business_system.client import BusinessSystemClient
    # client = BusinessSystemClient()
    # user_info = client.get_user_by_token(token_id)
    # return user_info.user_id


def get_user_info_by_token(token_id: str) -> Optional[Dict]:
    """
    通过 tokenId 获取用户信息
    
    当前场景：通过 user_id 查询数据库
    未来场景：通过 token_id 查询业务系统
    
    Args:
        token_id: 令牌ID
        
    Returns:
        用户信息字典，如果不存在则返回 None
    """
    # 当前实现：通过 user_id 查询数据库
    user_id = convert_token_to_user_id(token_id)
    # 查询数据库获取用户信息
    # ...
    
    # 未来实现：直接通过 token_id 查询业务系统
    # from infrastructure.business_system.client import BusinessSystemClient
    # client = BusinessSystemClient()
    # return client.get_user_info(token_id)
    pass


def get_blood_pressure_by_token(token_id: str) -> List[Dict]:
    """
    通过 tokenId 获取血压信息（根据工具场景需要）
    
    当前场景：通过 user_id 查询数据库
    未来场景：通过 token_id 查询业务系统
    
    Args:
        token_id: 令牌ID
        
    Returns:
        血压记录列表
    """
    # 类似实现
    pass
```

## 三、实施步骤

### 3.1 第一阶段：创建核心组件

1. **创建工具上下文管理器**
   - 文件：`domain/tools/context.py`
   - 实现 `TokenContext` 类和上下文变量

2. **创建工具包装器**
   - 文件：`domain/tools/wrapper.py`
   - 实现 `TokenInjectedTool` 类
   - 实现 `wrap_tools_with_token_context` 函数

3. **创建数据转换工具**
   - 文件：`domain/tools/utils/token_converter.py`
   - 实现 `convert_token_to_user_id` 等函数

### 3.2 第二阶段：集成到现有架构

1. **修改 AgentFactory**
   - 在 `_create_agent_internal` 中使用工具包装器
   - 确保所有工具都被包装

2. **修改 with_user_context**
   - 在 Agent 调用时设置 `TokenContext`
   - 从 `state` 中获取 `token_id`（当前使用 `user_id`）

### 3.3 第三阶段：改造工具函数

1. **修改工具函数签名**
   - 将所有工具的 `user_id` 参数改为 `token_id`
   - 在工具函数内部调用数据转换函数

2. **更新工具函数列表**（按优先级）：
   - 血压工具：`record_blood_pressure`, `query_blood_pressure`, `update_blood_pressure`
   - 健康事件工具：`record_health_event`, `query_health_event`, `update_health_event`
   - 用药工具：`record_medication`, `query_medication`, `update_medication`
   - 症状工具：`record_symptom`, `query_symptom`, `update_symptom`

### 3.4 第四阶段：测试验证

1. **单元测试**
   - 测试 `TokenContext` 的上下文传递
   - 测试 `TokenInjectedTool` 的参数注入
   - 测试数据转换函数

2. **集成测试**
   - 测试 Agent 的完整调用流程
   - 测试工具调用的参数注入
   - 测试多轮对话的场景

3. **回归测试**
   - 确保现有功能不受影响
   - 验证工具调用的正确性

### 3.5 第五阶段：文档更新

1. **代码文档**
   - 更新工具使用文档
   - 更新架构设计文档

2. **开发文档**
   - 更新工具开发指南
   - 说明如何添加新工具

## 四、关键设计决策

### 4.1 为什么使用 contextvars？

**优点**：
- ✅ 线程安全：每个线程有独立的上下文
- ✅ 异步安全：支持 async/await
- ✅ 无需显式传递：通过上下文自动传递
- ✅ 性能好：比全局变量更安全，比参数传递更方便

**缺点**：
- ⚠️ 需要显式设置上下文（在 `with_user_context` 中设置）

### 4.2 为什么在 Agent 创建时包装工具？

**原因**：
- Agent 在路由图创建时一次性创建，此时包装工具最合适
- 工具包装是一次性操作，不需要每次调用都包装
- 保持工具列表的一致性

**替代方案**（不推荐）：
- 在运行时动态包装：需要在每次调用时检查并包装，性能开销大
- 在工具注册时包装：但此时还没有 `tokenId`，无法设置上下文

### 4.3 为什么使用包装类而不是修改工具函数？

**优点**：
- ✅ 对现有工具函数影响小
- ✅ 可以逐步迁移，不需要一次性修改所有工具
- ✅ 保持工具函数的独立性
- ✅ 便于测试和维护

**缺点**：
- ⚠️ 增加了一层包装，可能有轻微的性能开销（可忽略）

### 4.4 如何处理更新类工具？

更新类工具（如 `update_blood_pressure`）使用 `record_id` 而不是 `user_id`。

**方案一：不添加 tokenId**（当前推荐）
- 保持现有设计，通过 `record_id` 间接关联用户
- 在工具内部通过 `record_id` 查询记录，获取 `user_id`

**方案二：添加 tokenId 用于权限验证**
- 添加 `token_id` 参数
- 在工具内部验证 `record.user_id == convert_token_to_user_id(token_id)`
- 如果权限验证失败，返回错误

**建议**：根据业务需求选择，如果不需要权限验证，使用方案一；如果需要权限验证，使用方案二。

## 五、潜在问题和解决方案

### 5.1 问题：LLM 仍然传递 token_id 怎么办？

**现象**：LLM 可能从系统提示词中看到 `token_id`，仍然尝试传递它。

**解决方案**：
1. 在系统提示词中明确说明：`token_id` 会自动注入，不需要传递
2. 在工具包装器中，如果检测到 LLM 传递了 `token_id`，使用自动注入的值覆盖（并记录警告）
3. 在工具描述中，明确说明 `token_id` 是自动注入的参数

### 5.2 问题：上下文丢失怎么办？

**现象**：在某些异步场景中，上下文可能丢失。

**解决方案**：
1. 使用 `contextvars` 确保上下文在异步调用中正确传递
2. 在工具包装器中，如果检测到 `token_id` 不存在，抛出明确的错误信息
3. 添加日志记录，便于排查问题

### 5.3 问题：工具缓存问题

**现象**：Agent 使用缓存时，工具可能没有被包装。

**解决方案**：
1. 在 Agent 创建时始终包装工具，不依赖缓存
2. 或者在缓存 Agent 时，确保工具已经被包装
3. 添加检查机制，确保工具是 `TokenInjectedTool` 实例

### 5.4 问题：性能影响

**现象**：工具包装可能带来性能开销。

**解决方案**：
1. 包装操作是一次性的，在 Agent 创建时执行
2. 参数注入操作是轻量级的，只是字典操作
3. 如果性能成为问题，可以考虑优化实现（如使用 `__slots__` 等）

## 六、测试策略

### 6.1 单元测试

**测试文件**：`cursor_test/M2_test/domain/test_tool_wrapper.py`

**测试用例**：
1. `test_token_context_set_and_get`：测试上下文设置和获取
2. `test_token_injected_tool_invoke`：测试同步工具调用
3. `test_token_injected_tool_ainvoke`：测试异步工具调用
4. `test_token_injected_tool_missing_token`：测试缺少 tokenId 的情况
5. `test_wrap_tools_with_token_context`：测试批量包装工具

### 6.2 集成测试

**测试文件**：`cursor_test/M2_test/domain/test_agent_with_token_injection.py`

**测试用例**：
1. `test_agent_tool_call_with_token`：测试 Agent 调用工具时自动注入 tokenId
2. `test_agent_multiple_tool_calls`：测试多次工具调用
3. `test_agent_tool_call_without_token`：测试缺少 tokenId 时的错误处理

### 6.3 端到端测试

**测试场景**：
1. 完整的聊天流程，验证工具调用正常
2. 多轮对话，验证上下文保持
3. 并发请求，验证线程安全

## 七、迁移计划

### 7.1 渐进式迁移策略

1. **阶段一**：创建核心组件，但不启用
   - 创建 `TokenInjectedTool` 等组件
   - 添加单元测试
   - 不修改现有代码

2. **阶段二**：启用工具包装，但工具函数仍使用 `user_id`
   - 在 `AgentFactory` 中启用工具包装
   - 工具函数仍使用 `user_id` 参数
   - 工具包装器注入 `token_id`，但工具函数内部将其作为 `user_id` 使用
   - 验证功能正常

3. **阶段三**：逐步迁移工具函数
   - 选择一个工具（如 `record_blood_pressure`）进行改造
   - 修改工具函数签名，使用 `token_id`
   - 添加数据转换逻辑
   - 测试验证

4. **阶段四**：全面迁移
   - 迁移所有工具函数
   - 更新文档
   - 完成测试

### 7.2 回滚方案

如果出现问题，可以快速回滚：

1. **回滚工具包装**：在 `AgentFactory` 中注释掉工具包装代码
2. **回滚工具函数**：恢复工具函数的 `user_id` 参数
3. **保持数据转换模块**：数据转换模块可以保留，为未来使用做准备

## 八、总结

### 8.1 方案优势

1. ✅ **可靠性高**：不依赖 LLM 传递参数，减少出错可能
2. ✅ **实现简单**：使用标准 Python 特性（contextvars），易于理解和维护
3. ✅ **影响范围小**：主要修改集中在工具包装和 Agent 创建逻辑
4. ✅ **易于测试**：组件独立，便于单元测试和集成测试
5. ✅ **向后兼容**：可以渐进式迁移，不影响现有功能

### 8.2 实施建议

1. **优先实施**：核心组件（工具包装器、上下文管理器）
2. **逐步迁移**：先迁移一个工具，验证方案可行后再全面迁移
3. **充分测试**：每个阶段都要进行充分的测试
4. **文档同步**：及时更新文档，记录设计决策和实现细节

### 8.3 未来扩展

1. **业务系统对接**：在数据转换函数中实现业务系统调用
2. **权限验证**：在工具包装器中添加权限验证逻辑
3. **性能优化**：如果性能成为问题，可以考虑优化实现
4. **监控和日志**：添加工具调用的监控和日志，便于排查问题

