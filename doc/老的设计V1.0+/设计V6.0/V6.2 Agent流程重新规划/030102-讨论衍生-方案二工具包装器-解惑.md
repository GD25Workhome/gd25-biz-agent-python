# 方案二工具包装器原理详解

## 一、核心问题：token_id 是谁在持有？

### 1.1 token_id 的持有者

**答案：调用者（API 层）持有 token_id，存储在 RouterState 中，通过 contextvars 传递给工具包装器。**

### 1.2 token_id 的完整流转路径

```
┌─────────────────────────────────────────────────────────────┐
│ 第一层：API 调用者（app/api/routes.py）                      │
├─────────────────────────────────────────────────────────────┤
│ 1. 接收 HTTP 请求                                            │
│    POST /api/v1/chat                                        │
│    {                                                         │
│      "message": "记录血压120/80",                            │
│      "user_id": "user123",      ← token_id 的来源           │
│      "session_id": "session456"                             │
│    }                                                         │
│                                                              │
│ 2. 构建 RouterState                                          │
│    initial_state = {                                         │
│      "user_id": request.user_id,  ← token_id 存储在这里      │
│      "session_id": request.session_id,                      │
│      "messages": [...],                                     │
│      ...                                                     │
│    }                                                         │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 第二层：路由图执行（domain/router/graph.py）                 │
├─────────────────────────────────────────────────────────────┤
│ 3. 路由图节点执行                                            │
│    router_graph.astream(initial_state, config)              │
│    → route_node(state)                                      │
│    → with_user_context(agent_node, agent_name)               │
│                                                              │
│ 4. with_user_context 从 state 获取 token_id                 │
│    async def _run(state: RouterState):                      │
│        user_id = state.get("user_id")  ← 从 state 获取       │
│        token_id = user_id  # 当前场景：token_id = user_id    │
│                                                              │
│ 5. 设置 TokenContext（使用 contextvars）                     │
│    with TokenContext(token_id=token_id):  ← 设置上下文      │
│        result = await agent_node.ainvoke(...)                │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 第三层：Agent 执行（LangChain ReAct Agent）                  │
├─────────────────────────────────────────────────────────────┤
│ 6. Agent 调用 LLM                                            │
│    LLM 分析用户消息，决定调用工具                            │
│    LLM 只传递业务参数（systolic, diastolic）                │
│    LLM 不知道 token_id 的存在                               │
│                                                              │
│ 7. LangChain 框架调用工具                                    │
│    tool.ainvoke({                                            │
│      "systolic": 120,  ← LLM 传递的参数                    │
│      "diastolic": 80   ← LLM 传递的参数                    │
│      # token_id 不在参数中！                                │
│    })                                                        │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 第四层：工具包装器（domain/tools/wrapper.py）                │
├─────────────────────────────────────────────────────────────┤
│ 8. TokenInjectedTool.ainvoke() 拦截调用                     │
│    async def _ainvoke(self, tool_input, ...):               │
│        # 从 contextvars 获取 token_id                       │
│        token_id = get_token_id()  ← 从上下文获取            │
│                                                              │
│        # 自动注入 token_id                                   │
│        injected_input = {                                   │
│            "token_id": token_id,  ← 自动添加                │
│            "systolic": 120,                                 │
│            "diastolic": 80                                   │
│        }                                                     │
│                                                              │
│        # 调用原始工具                                        │
│        return await self._original_tool.ainvoke(            │
│            injected_input, ...                              │
│        )                                                     │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 第五层：工具函数执行（domain/tools/blood_pressure/record.py）│
├─────────────────────────────────────────────────────────────┤
│ 9. 工具函数接收完整参数                                      │
│    async def record_blood_pressure(                         │
│        token_id: str,      ← 自动注入的参数                  │
│        systolic: int,     ← LLM 传递的参数                  │
│        diastolic: int,    ← LLM 传递的参数                  │
│        ...                                                 │
│    ):                                                       │
│        # 数据转换                                            │
│        user_id = convert_token_to_user_id(token_id)        │
│        # 执行业务逻辑                                        │
│        ...                                                  │
└─────────────────────────────────────────────────────────────┘
```

## 二、关键机制详解

### 2.1 contextvars：上下文变量机制

**什么是 contextvars？**

`contextvars` 是 Python 3.7+ 引入的模块，用于实现**上下文变量**（Context Variables）。它可以在异步调用链中安全地传递上下文信息。

**为什么使用 contextvars？**

1. **线程安全**：每个线程有独立的上下文，不会相互干扰
2. **异步安全**：支持 `async/await`，在异步调用链中正确传递
3. **隐式传递**：不需要显式传递参数，通过上下文自动获取
4. **隔离性**：不同请求的上下文相互隔离

**工作原理：**

```python
import contextvars

# 创建上下文变量
_token_id_context: contextvars.ContextVar[str] = contextvars.ContextVar('token_id')

# 设置上下文（在 with_user_context 中）
def set_token_id(token_id: str):
    _token_id_context.set(token_id)

# 获取上下文（在工具包装器中）
def get_token_id() -> str:
    return _token_id_context.get()
```

**关键特性：**

- **上下文继承**：子任务自动继承父任务的上下文
- **上下文隔离**：不同请求的上下文相互隔离
- **自动清理**：上下文在作用域结束时自动清理

### 2.2 工具包装器的工作原理

#### 2.2.1 包装器的拦截机制

工具包装器通过**继承 BaseTool 并重写调用方法**来实现拦截：

```python
class TokenInjectedTool(BaseTool):
    """工具包装器：自动注入 tokenId"""
    
    def __init__(self, tool: BaseTool):
        self._original_tool = tool  # 保存原始工具
        # 继承原始工具的所有属性
        super().__init__(
            name=tool.name,
            description=tool.description,
            args_schema=tool.args_schema,
        )
    
    async def _ainvoke(self, tool_input, ...):
        """
        拦截工具调用，自动注入 token_id
        
        关键点：
        1. 这个方法在工具被调用时自动执行
        2. tool_input 是 LLM 传递的参数（不包含 token_id）
        3. 我们从 contextvars 获取 token_id
        4. 将 token_id 注入到 tool_input 中
        5. 调用原始工具
        """
        # 步骤1：从上下文获取 token_id
        token_id = get_token_id()  # 从 contextvars 获取
        
        # 步骤2：注入 token_id
        injected_input = tool_input.copy()
        injected_input['token_id'] = token_id
        
        # 步骤3：调用原始工具
        return await self._original_tool.ainvoke(injected_input, ...)
```

#### 2.2.2 包装时机

**关键点：工具在 Agent 创建时被包装，但 token_id 在运行时注入。**

```
┌─────────────────────────────────────────────────────────────┐
│ Agent 创建阶段（应用启动时，domain/agents/factory.py）        │
├─────────────────────────────────────────────────────────────┤
│ 1. 从 TOOL_REGISTRY 获取原始工具                            │
│    tools = [TOOL_REGISTRY[name] for name in tool_names]     │
│                                                              │
│ 2. 包装工具（此时还没有 token_id）                           │
│    wrapped_tools = wrap_tools_with_token_context(tools)      │
│    → 每个工具被包装成 TokenInjectedTool                      │
│    → 工具包装器已经准备好，等待运行时注入 token_id            │
│                                                              │
│ 3. 创建 Agent（使用包装后的工具）                            │
│    agent = create_agent(model=llm, tools=wrapped_tools)     │
│                                                              │
│ 注意：此时 token_id 还不存在，工具包装器只是准备好了        │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ Agent 执行阶段（运行时，domain/router/graph.py）              │
├─────────────────────────────────────────────────────────────┤
│ 4. with_user_context 从 state 获取 token_id                 │
│    token_id = state.get("user_id")                           │
│                                                              │
│ 5. 设置 TokenContext                                         │
│    with TokenContext(token_id=token_id):  ← 设置上下文       │
│        result = await agent_node.ainvoke(...)                │
│                                                              │
│ 6. Agent 执行，LLM 调用工具                                  │
│    → 工具包装器拦截调用                                      │
│    → 从 contextvars 获取 token_id                           │
│    → 自动注入 token_id                                       │
│    → 调用原始工具                                            │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 与方案一的对比

#### 方案一：LLM 管理 token_id

```
API 层
  ↓ user_id 存入 state
RouterState { user_id: "user123" }
  ↓ 通过占位符注入
系统提示词: "用户ID: user123"
  ↓ LLM 看到并理解
LLM: "我需要调用 record_blood_pressure，参数包括 token_id=user123"
  ↓ LLM 传递参数
工具调用: record_blood_pressure(token_id="user123", systolic=120, ...)
  ↓
工具函数执行
```

**问题**：
- 依赖 LLM 正确提取和传递 token_id
- 如果 LLM 遗漏或传错，工具调用失败
- 提示词需要明确说明 token_id 的使用方式

#### 方案二：系统管理 token_id

```
API 层
  ↓ user_id 存入 state
RouterState { user_id: "user123" }
  ↓ 通过 contextvars 设置
TokenContext(token_id="user123")  ← 系统设置上下文
  ↓ LLM 不知道 token_id
系统提示词: "请使用 record_blood_pressure 记录血压"
  ↓ LLM 只传递业务参数
LLM: "我需要调用 record_blood_pressure，参数 systolic=120, diastolic=80"
  ↓ LangChain 调用工具
工具调用: record_blood_pressure(systolic=120, diastolic=80)
  ↓ 工具包装器拦截
TokenInjectedTool: 从 contextvars 获取 token_id，自动注入
  ↓ 注入后调用原始工具
工具调用: record_blood_pressure(token_id="user123", systolic=120, diastolic=80)
  ↓
工具函数执行
```

**优势**：
- 不依赖 LLM，系统自动管理
- 保证每次调用都有 token_id
- 提示词更简洁，只关注业务逻辑

## 三、详细代码流程

### 3.1 完整调用链代码示例

#### 步骤 1：API 层接收请求

```python
# app/api/routes.py
@router.post("/chat")
async def chat(request: ChatRequest):
    # 调用者提供 user_id（未来可能是 token_id）
    initial_state: RouterState = {
        "user_id": request.user_id,  # ← token_id 的来源
        "session_id": request.session_id,
        "messages": [...],
        ...
    }
    
    # 执行路由图
    async for event in router_graph.astream(initial_state, config):
        ...
```

#### 步骤 2：with_user_context 设置上下文

```python
# domain/router/graph.py
def with_user_context(agent_node, agent_name: str):
    async def _run(state: RouterState) -> RouterState:
        # 从 state 获取 user_id
        user_id = state.get("user_id")
        
        # 当前场景：token_id = user_id
        # 未来场景：token_id = state.get("token_id")
        token_id = user_id
        
        # 设置 TokenContext（使用 contextvars）
        with TokenContext(token_id=token_id):  # ← 关键：设置上下文
            # 调用 Agent
            result = await agent_node.ainvoke({"messages": messages_with_context})
        
        return result
```

#### 步骤 3：TokenContext 实现

```python
# domain/tools/context.py
import contextvars

# 创建上下文变量
_token_id_context: contextvars.ContextVar[str] = contextvars.ContextVar('token_id')

class TokenContext:
    """工具上下文管理器"""
    
    def __init__(self, token_id: str):
        self.token_id = token_id
        self._token = None
    
    def __enter__(self):
        """进入上下文：设置 token_id"""
        self._token = _token_id_context.set(self.token_id)
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文：恢复之前的上下文"""
        if self._token is not None:
            _token_id_context.reset(self._token)
        return False

def get_token_id() -> Optional[str]:
    """获取当前上下文的 token_id"""
    return _token_id_context.get()
```

#### 步骤 4：工具包装器拦截调用

```python
# domain/tools/wrapper.py
class TokenInjectedTool(BaseTool):
    """工具包装器：自动注入 tokenId"""
    
    def __init__(self, tool: BaseTool):
        self._original_tool = tool
        super().__init__(
            name=tool.name,
            description=tool.description,
            args_schema=tool.args_schema,
        )
    
    async def _ainvoke(self, tool_input, run_manager, ...):
        """
        拦截工具调用，自动注入 token_id
        
        tool_input 是 LLM 传递的参数，例如：
        {
            "systolic": 120,
            "diastolic": 80
        }
        """
        # 从 contextvars 获取 token_id
        token_id = get_token_id()  # ← 从上下文获取
        
        if token_id is None:
            raise ValueError(f"工具 {self.name} 需要 tokenId，但上下文中未设置")
        
        # 注入 token_id
        injected_input = tool_input.copy()
        injected_input['token_id'] = token_id
        
        # 调用原始工具
        return await self._original_tool.ainvoke(injected_input, run_manager, ...)
```

#### 步骤 5：工具函数执行

```python
# domain/tools/blood_pressure/record.py
@tool
async def record_blood_pressure(
    token_id: str,      # ← 自动注入的参数
    systolic: int,      # ← LLM 传递的参数
    diastolic: int,     # ← LLM 传递的参数
    ...
) -> str:
    # 数据转换
    from domain.tools.utils.token_converter import convert_token_to_user_id
    user_id = convert_token_to_user_id(token_id)
    
    # 执行业务逻辑
    ...
```

### 3.2 关键时序图

```
时间线：
│
├─ [T1] API 接收请求
│   └─ initial_state = { user_id: "user123", ... }
│
├─ [T2] 路由图执行
│   └─ with_user_context 被调用
│
├─ [T3] 设置 TokenContext
│   └─ with TokenContext(token_id="user123"):
│       └─ contextvars 设置 token_id = "user123"
│
├─ [T4] Agent 调用 LLM
│   └─ LLM 分析消息，决定调用工具
│
├─ [T5] LLM 生成工具调用
│   └─ record_blood_pressure(systolic=120, diastolic=80)
│       └─ 注意：没有 token_id
│
├─ [T6] LangChain 调用工具
│   └─ tool.ainvoke({ "systolic": 120, "diastolic": 80 })
│
├─ [T7] 工具包装器拦截
│   └─ TokenInjectedTool._ainvoke() 被调用
│       ├─ token_id = get_token_id()  # 从 contextvars 获取
│       ├─ injected_input = { "token_id": "user123", "systolic": 120, ... }
│       └─ 调用原始工具
│
├─ [T8] 原始工具执行
│   └─ record_blood_pressure(token_id="user123", systolic=120, ...)
│
└─ [T9] 退出 TokenContext
    └─ contextvars 恢复之前的上下文
```

## 四、常见问题解答

### Q1: 模型知道 tokenId 是什么吗？

**答案：不知道。**

在方案二中：
- LLM 看不到 token_id
- LLM 不需要传递 token_id
- token_id 由系统自动管理

**对比方案一：**
- 方案一：LLM 从提示词中看到 token_id，需要传递
- 方案二：LLM 不知道 token_id 的存在，系统自动注入

### Q2: 如果模型不知道，是不是必须依赖调用者？

**答案：是的，但这是设计目标。**

方案二的核心思想就是：
- **调用者（API 层）负责提供 token_id**
- **系统（工具包装器）负责自动注入 token_id**
- **LLM 只关注业务逻辑，不需要知道 token_id**

这是**关注点分离**的设计：
- 技术参数（token_id）由系统管理
- 业务参数（systolic, diastolic）由 LLM 管理

### Q3: 调用者如何管理 token_id？

**答案：调用者通过 RouterState 管理 token_id。**

**管理流程：**

1. **API 层接收请求**
   ```python
   # 调用者提供 user_id（未来可能是 token_id）
   request.user_id  # 来自 HTTP 请求
   ```

2. **存入 RouterState**
   ```python
   initial_state = {
       "user_id": request.user_id,  # 存储在 state 中
       ...
   }
   ```

3. **with_user_context 从 state 获取**
   ```python
   user_id = state.get("user_id")
   token_id = user_id  # 当前场景
   ```

4. **设置 TokenContext**
   ```python
   with TokenContext(token_id=token_id):
       # 在此上下文中，工具可以获取 token_id
   ```

**关键点：**
- token_id 的**来源**是调用者（API 请求）
- token_id 的**存储**是 RouterState
- token_id 的**传递**是 contextvars
- token_id 的**注入**是工具包装器

### Q4: contextvars 是如何工作的？

**答案：contextvars 是 Python 的上下文变量机制。**

**工作原理：**

1. **创建上下文变量**
   ```python
   _token_id_context = contextvars.ContextVar('token_id')
   ```

2. **设置上下文（在 with_user_context 中）**
   ```python
   with TokenContext(token_id="user123"):
       # 在此作用域内，_token_id_context.get() 返回 "user123"
   ```

3. **获取上下文（在工具包装器中）**
   ```python
   token_id = _token_id_context.get()  # 返回 "user123"
   ```

4. **上下文隔离**
   - 不同请求的上下文相互隔离
   - 异步任务自动继承父任务的上下文
   - 上下文在作用域结束时自动清理

**关键特性：**
- **线程安全**：每个线程有独立的上下文
- **异步安全**：支持 async/await
- **自动继承**：子任务自动继承父任务的上下文
- **自动清理**：作用域结束时自动清理

### Q5: 如果多个工具同时调用，token_id 会混乱吗？

**答案：不会，contextvars 保证上下文隔离。**

**原因：**

1. **每个请求有独立的上下文**
   - 请求 A：token_id = "user123"
   - 请求 B：token_id = "user456"
   - 两个请求的上下文相互隔离

2. **异步任务继承父任务上下文**
   ```python
   # 主任务设置上下文
   with TokenContext(token_id="user123"):
       # 子任务自动继承上下文
       async def sub_task():
           token_id = get_token_id()  # 返回 "user123"
   ```

3. **工具调用在同一上下文中**
   - 所有工具调用都在 `with TokenContext(...)` 作用域内
   - 所有工具都能获取到正确的 token_id

## 五、总结

### 5.1 token_id 的持有者

- **来源**：调用者（API 请求）
- **存储**：RouterState
- **传递**：contextvars
- **注入**：工具包装器

### 5.2 工具包装器的工作原理

1. **包装时机**：Agent 创建时包装工具
2. **拦截机制**：重写 `_ainvoke` 方法拦截调用
3. **注入机制**：从 contextvars 获取 token_id，自动注入
4. **调用机制**：调用原始工具，传递注入后的参数

### 5.3 方案二的优势

1. **可靠性**：不依赖 LLM，系统自动管理
2. **简洁性**：提示词更简洁，只关注业务逻辑
3. **分离性**：技术参数和业务参数分离
4. **可维护性**：token_id 的管理逻辑集中在一处

### 5.4 关键理解点

1. **LLM 不知道 token_id**：这是设计目标，不是缺陷
2. **调用者管理 token_id**：这是设计目标，通过 RouterState 和 contextvars 实现
3. **工具包装器自动注入**：这是技术实现，通过拦截调用实现
4. **contextvars 传递上下文**：这是关键技术，保证上下文正确传递

