# 工具参数逻辑情况讨论

## 一、当前工具的入参情况

### 1.1 工具入参结构

当前所有业务工具都采用**直接参数传递**的方式，工具函数签名中直接包含所有业务参数，其中 `user_id` 作为第一个参数（查询和记录类工具）或通过 `record_id` 间接关联（更新类工具）。

#### 1.1.1 记录类工具（Record Tools）

所有记录类工具的第一个参数都是 `user_id: str`，后续是业务数据结构参数。

**示例：血压记录工具**
```python
@tool
async def record_blood_pressure(
    user_id: str,              # 第一个参数：用户ID
    systolic: int,             # 业务数据：收缩压
    diastolic: int,            # 业务数据：舒张压
    heart_rate: Optional[int] = None,
    record_time: Optional[str] = None,
    notes: Optional[str] = None
) -> str:
```

**其他记录类工具结构类似：**
- `record_health_event(user_id: str, event_type: str, event_name: str, ...)`
- `record_medication(user_id: str, medication_name: str, dosage: str, ...)`
- `record_symptom(user_id: str, symptom_name: str, severity: Optional[str] = None, ...)`

#### 1.1.2 查询类工具（Query Tools）

查询类工具同样以 `user_id` 作为第一个参数，后续是查询条件参数。

**示例：血压查询工具**
```python
@tool
async def query_blood_pressure(
    user_id: str,              # 第一个参数：用户ID
    limit: int = 10,           # 查询条件：返回记录数量限制
    offset: int = 0            # 查询条件：偏移量
) -> str:
```

**其他查询类工具结构类似：**
- `query_health_event(user_id: str, limit: int = 10, offset: int = 0)`
- `query_medication(user_id: str, limit: int = 10, offset: int = 0)`
- `query_symptom(user_id: str, limit: int = 10, offset: int = 0)`

#### 1.1.3 更新类工具（Update Tools）

更新类工具使用 `record_id` 来标识要更新的记录，不直接使用 `user_id`。

**示例：血压更新工具**
```python
@tool
async def update_blood_pressure(
    record_id: int,            # 记录ID（间接关联用户）
    systolic: Optional[int] = None,
    diastolic: Optional[int] = None,
    heart_rate: Optional[int] = None,
    notes: Optional[str] = None
) -> str:
```

**其他更新类工具结构类似：**
- `update_health_event(record_id: int, ...)`
- `update_medication(record_id: int, ...)`
- `update_symptom(record_id: int, ...)`

### 1.2 工具注册与发现机制

所有工具通过 `domain/tools/registry.py` 统一注册到 `TOOL_REGISTRY` 字典中：

```python
# 工具注册表
TOOL_REGISTRY: Dict[str, BaseTool] = {}

def init_tools():
    """初始化工具注册表"""
    # 血压工具
    register_tool("record_blood_pressure", record_blood_pressure)
    register_tool("query_blood_pressure", query_blood_pressure)
    register_tool("update_blood_pressure", update_blood_pressure)
    
    # 健康事件工具
    register_tool("record_health_event", record_health_event)
    register_tool("query_health_event", query_health_event)
    register_tool("update_health_event", update_health_event)
    
    # 用药记录工具
    register_tool("record_medication", record_medication)
    register_tool("query_medication", query_medication)
    register_tool("update_medication", update_medication)
    
    # 症状记录工具
    register_tool("record_symptom", record_symptom)
    register_tool("query_symptom", query_symptom)
    register_tool("update_symptom", update_symptom)
```

### 1.3 工具定义方式

所有工具使用 LangChain 的 `@tool` 装饰器定义，工具会自动转换为 `BaseTool` 实例，支持：
- 自动生成工具描述（从函数文档字符串）
- 自动参数验证（基于函数签名）
- 与 LangChain Agent 无缝集成

## 二、Agent 与工具的对接情况

### 2.1 Agent 获取工具的方式

Agent 在创建时（`domain/agents/factory.py`）从 `TOOL_REGISTRY` 获取工具列表：

```python
# 从配置中读取工具名称列表
tool_names = agent_config.get("tools", [])
tools = [
    TOOL_REGISTRY[name]
    for name in tool_names
    if name in TOOL_REGISTRY
]
```

工具配置在 `config/agents.yaml` 中定义：

```yaml
blood_pressure_agent:
  tools:
    - record_blood_pressure
    # - query_blood_pressure  # 已停用
    # - update_blood_pressure  # 已停用
```

### 2.2 Agent 调用工具的机制

Agent 通过 **LangChain ReAct 模式**调用工具：

1. **LLM 决策**：Agent 的 LLM 根据用户消息和系统提示词，决定是否需要调用工具
2. **参数提取**：LLM 从对话上下文中提取工具所需的参数（包括 `user_id`）
3. **工具调用**：LangChain 框架自动调用工具函数，传入 LLM 提取的参数
4. **结果返回**：工具执行结果返回给 LLM，用于生成最终回复

### 2.3 user_id 的传递路径

当前 `user_id` 的传递路径如下：

```
API 请求 (ChatRequest)
  ↓ user_id
RouterState (state["user_id"])
  ↓ 通过占位符注入
系统提示词 ({{user_id}})
  ↓ LLM 理解并提取
工具调用参数 (user_id: str)
  ↓ 直接使用
工具函数执行
```

**关键点：**
- `user_id` 存储在 `RouterState` 中（`domain/router/state.py`）
- 通过 `PlaceholderManager` 将 `user_id` 注入到系统提示词中（`domain/router/graph.py`）
- LLM 需要从系统提示词中理解 `user_id` 的值，并在调用工具时传递给工具
- **没有自动注入机制**：LLM 必须显式地将 `user_id` 作为参数传递给工具

### 2.4 系统提示词中的 user_id 注入

在 `domain/router/graph.py` 的 `with_user_context` 函数中，`user_id` 通过占位符注入到系统提示词：

```python
# 从 state 中获取占位符值
placeholders = PlaceholderManager.get_placeholders(agent_name, state=state)
# placeholders 包含 {"user_id": "xxx", "session_id": "yyy", ...}

# 填充占位符
filled_prompt = PlaceholderManager.fill_placeholders(template, placeholders)
# 系统提示词中的 {{user_id}} 被替换为实际值
```

**示例系统提示词片段：**
```
用户ID: {{user_id}}
会话ID: {{session_id}}
当前日期: {{current_date}}
患者基础信息: {{user_info}}
```

### 2.5 当前机制的问题

1. **依赖 LLM 理解**：LLM 必须从系统提示词中理解 `user_id` 的值，并在调用工具时正确传递
2. **容易出错**：如果 LLM 没有正确提取或传递 `user_id`，工具调用会失败
3. **缺乏自动注入**：无法在工具调用时自动注入 `user_id`，必须依赖 LLM 的显式传递
4. **与业务系统对接困难**：未来需要与业务系统对接时，需要修改所有工具的参数结构

## 三、改造方案分析

### 3.1 改造目标

根据 `0100-原始思考.md` 的要求，工具入参需要改为两种结构：
1. **tokenId**：用于身份标识和未来业务系统对接
   - 当前场景：`tokenId` 直接使用 `userId` 填充
   - 未来场景：`tokenId` 可以是业务系统提供的令牌，用于获取用户信息、血压信息等
2. **工具的数据结构**：工具的业务参数（如血压值、症状名称等）

### 3.2 tokenId 的设计思路

**tokenId 的作用：**
- 作为身份标识，用于在工具内部进行数据转换
- 工具内部通过 `tokenId` 获取用户信息、血压信息等（根据各个工具的实际场景）
- 为未来与业务系统对接做准备，业务系统可以提供 `tokenId`，工具内部通过 `tokenId` 查询业务数据

**当前实现方案：**
- `tokenId` 直接使用 `userId` 填充
- 工具内部需要做数据转换：
  - 入参是 `tokenId`
  - 工具内部将 `tokenId` 转换为 `userId`（当前场景：直接使用）
  - 根据工具场景，可能还需要通过 `tokenId` 获取用户信息、血压信息等

### 3.3 改造后的工具结构

#### 3.3.1 记录类工具改造示例

**改造前：**
```python
@tool
async def record_blood_pressure(
    user_id: str,
    systolic: int,
    diastolic: int,
    heart_rate: Optional[int] = None,
    record_time: Optional[str] = None,
    notes: Optional[str] = None
) -> str:
```

**改造后：**
```python
@tool
async def record_blood_pressure(
    token_id: str,             # 第一部分：tokenId（身份标识）
    systolic: int,             # 第二部分：工具的数据结构
    diastolic: int,
    heart_rate: Optional[int] = None,
    record_time: Optional[str] = None,
    notes: Optional[str] = None
) -> str:
    # 工具内部数据转换
    user_id = _convert_token_to_user_id(token_id)  # 当前：直接使用 token_id
    # 可能还需要：user_info = _get_user_info_by_token(token_id)
    # 可能还需要：blood_pressure_history = _get_blood_pressure_by_token(token_id)
    
    # 后续业务逻辑保持不变
    ...
```

#### 3.3.2 查询类工具改造示例

**改造前：**
```python
@tool
async def query_blood_pressure(
    user_id: str,
    limit: int = 10,
    offset: int = 0
) -> str:
```

**改造后：**
```python
@tool
async def query_blood_pressure(
    token_id: str,             # 第一部分：tokenId
    limit: int = 10,           # 第二部分：工具的数据结构
    offset: int = 0
) -> str:
    # 工具内部数据转换
    user_id = _convert_token_to_user_id(token_id)
    # 可能还需要：user_info = _get_user_info_by_token(token_id)
    
    # 后续业务逻辑保持不变
    ...
```

#### 3.3.3 更新类工具改造示例

更新类工具需要考虑是否也需要 `tokenId`，或者保持使用 `record_id` 的方式。

**方案一：保持 record_id，不添加 tokenId**
```python
@tool
async def update_blood_pressure(
    record_id: int,            # 通过 record_id 间接关联用户
    systolic: Optional[int] = None,
    ...
) -> str:
    # 通过 record_id 查询记录，获取 user_id
    record = await repo.get_by_id(record_id)
    user_id = record.user_id
    ...
```

**方案二：添加 tokenId 用于权限验证**
```python
@tool
async def update_blood_pressure(
    token_id: str,             # 第一部分：tokenId（用于权限验证）
    record_id: int,            # 第二部分：工具的数据结构
    systolic: Optional[int] = None,
    ...
) -> str:
    # 数据转换和权限验证
    user_id = _convert_token_to_user_id(token_id)
    record = await repo.get_by_id(record_id)
    
    # 权限验证：确保 record 属于该 user_id
    if record.user_id != user_id:
        return "无权更新该记录"
    ...
```

### 3.4 Agent 调用工具的改造

#### 3.4.1 方案一：依赖 LLM 传递 tokenId（当前方式）

**优点：**
- 改造量小，只需修改工具函数签名和内部逻辑
- 保持 LangChain 的 ReAct 模式不变

**缺点：**
- 仍然依赖 LLM 正确传递 `tokenId`
- 需要在系统提示词中明确说明 `tokenId` 的值

**实现方式：**
1. 修改系统提示词，将 `{{user_id}}` 改为 `{{token_id}}`，并说明 `token_id` 的值就是 `user_id`
2. 修改所有工具函数签名，将 `user_id` 改为 `token_id`
3. 在工具内部添加数据转换逻辑

#### 3.4.2 方案二：自动注入 tokenId（推荐）

**优点：**
- 不依赖 LLM 传递 `tokenId`，减少出错可能
- 工具调用时自动注入，更加可靠

**缺点：**
- 需要修改 LangChain 的工具调用机制
- 可能需要自定义工具包装器

**实现方式：**
1. 创建工具包装器，在工具调用时自动注入 `tokenId`
2. 修改 Agent 创建逻辑，使用包装后的工具
3. 工具函数签名保持不变，但通过包装器注入 `tokenId`

**示例实现：**
```python
def wrap_tool_with_token(tool: BaseTool, token_id: str) -> BaseTool:
    """包装工具，自动注入 tokenId"""
    original_func = tool.func
    
    async def wrapped_func(**kwargs):
        # 自动注入 token_id
        kwargs['token_id'] = token_id
        return await original_func(**kwargs)
    
    # 创建新的工具实例
    wrapped_tool = type(tool)(
        name=tool.name,
        description=tool.description,
        func=wrapped_func,
        args_schema=tool.args_schema
    )
    return wrapped_tool
```

**在 Agent 创建时使用：**
```python
# 获取原始工具
tools = [TOOL_REGISTRY[name] for name in tool_names]

# 包装工具（需要从 state 中获取 token_id）
# 注意：这需要在运行时动态包装，可能需要修改 Agent 创建逻辑
```

#### 3.4.3 方案三：使用工具绑定（Tool Binding）

LangChain 支持工具绑定（Tool Binding），可以在工具调用时自动注入上下文信息。

**实现方式：**
1. 使用 LangChain 的 `bind_tools` 或自定义工具绑定机制
2. 在 Agent 调用时，将 `tokenId` 绑定到工具上
3. 工具函数通过绑定参数获取 `tokenId`

### 3.5 数据转换逻辑设计

工具内部需要实现数据转换逻辑，将 `tokenId` 转换为实际需要的数据：

```python
def _convert_token_to_user_id(token_id: str) -> str:
    """
    将 tokenId 转换为 userId
    
    当前场景：直接返回 token_id（因为 token_id = user_id）
    未来场景：通过 token_id 查询业务系统，获取 user_id
    """
    # 当前实现：直接返回
    return token_id
    
    # 未来实现示例：
    # user_info = business_system.get_user_by_token(token_id)
    # return user_info.user_id


def _get_user_info_by_token(token_id: str) -> Optional[Dict]:
    """
    通过 tokenId 获取用户信息
    
    当前场景：通过 user_id 查询数据库
    未来场景：通过 token_id 查询业务系统
    """
    # 当前实现：通过 user_id 查询数据库
    user_id = _convert_token_to_user_id(token_id)
    # 查询数据库获取用户信息
    ...
    
    # 未来实现：直接通过 token_id 查询业务系统
    # return business_system.get_user_info(token_id)


def _get_blood_pressure_by_token(token_id: str) -> List[Dict]:
    """
    通过 tokenId 获取血压信息（根据工具场景需要）
    
    当前场景：通过 user_id 查询数据库
    未来场景：通过 token_id 查询业务系统
    """
    # 类似实现
    ...
```

### 3.6 改造影响范围

#### 3.6.1 需要修改的文件

1. **工具函数文件**（12个工具）：
   - `domain/tools/blood_pressure/record.py`
   - `domain/tools/blood_pressure/query.py`
   - `domain/tools/blood_pressure/update.py`
   - `domain/tools/health_event/record.py`
   - `domain/tools/health_event/query.py`
   - `domain/tools/health_event/update.py`
   - `domain/tools/medication/record.py`
   - `domain/tools/medication/query.py`
   - `domain/tools/medication/update.py`
   - `domain/tools/symptom/record.py`
   - `domain/tools/symptom/query.py`
   - `domain/tools/symptom/update.py`

2. **工具辅助模块**（新增）：
   - `domain/tools/utils/token_converter.py`（数据转换工具函数）

3. **系统提示词文件**（如果采用方案一）：
   - `config/prompts/local/blood_pressure_agent_prompt.txt`
   - 其他 Agent 的提示词文件

4. **Agent 创建逻辑**（如果采用方案二或方案三）：
   - `domain/agents/factory.py`
   - `domain/router/graph.py`

5. **测试文件**：
   - `cursor_test/M1_test/domain/test_blood_pressure_tools.py`
   - 其他工具测试文件

#### 3.6.2 向后兼容性考虑

如果采用渐进式改造，可以考虑：
1. 保持旧工具函数可用（标记为 deprecated）
2. 创建新工具函数（带 `token_id` 参数）
3. 逐步迁移 Agent 配置

### 3.7 改造实施建议

#### 3.7.1 推荐方案

**推荐采用方案二（自动注入 tokenId）**，原因：
1. 减少对 LLM 的依赖，提高可靠性
2. 工具函数签名清晰，业务逻辑与身份标识分离
3. 便于未来扩展（业务系统对接）

#### 3.7.2 实施步骤

1. **第一步：创建数据转换工具模块**
   - 创建 `domain/tools/utils/token_converter.py`
   - 实现 `_convert_token_to_user_id` 等转换函数
   - 当前实现：直接返回 `token_id`

2. **第二步：修改工具函数签名**
   - 将所有工具的 `user_id` 参数改为 `token_id`
   - 在工具函数内部调用转换函数获取 `user_id`
   - 保持其他业务逻辑不变

3. **第三步：实现工具包装器（方案二）**
   - 创建工具包装器，自动注入 `token_id`
   - 修改 Agent 创建逻辑，使用包装后的工具
   - 从 `RouterState` 中获取 `token_id`（当前：`token_id = state["user_id"]`）

4. **第四步：更新系统提示词（如果采用方案一）**
   - 将提示词中的 `{{user_id}}` 改为 `{{token_id}}`
   - 说明 `token_id` 的值就是 `user_id`

5. **第五步：测试验证**
   - 测试所有工具的正常调用
   - 测试 Agent 的完整流程
   - 验证数据转换逻辑

6. **第六步：文档更新**
   - 更新工具使用文档
   - 更新架构设计文档

## 四、总结

### 4.1 当前状态

- 所有工具直接接收 `user_id` 作为参数
- `user_id` 通过系统提示词注入，依赖 LLM 正确传递
- 工具与 Agent 通过 LangChain ReAct 模式对接
- 缺乏自动注入机制，容易出错

### 4.2 改造方向

- 工具入参改为两部分：`tokenId` + 工具的数据结构
- `tokenId` 当前使用 `userId` 填充，未来可对接业务系统
- 工具内部实现数据转换逻辑
- 推荐使用自动注入机制，减少对 LLM 的依赖

### 4.3 关键决策点

1. **tokenId 注入方式**：方案一（LLM 传递）vs 方案二（自动注入）vs 方案三（工具绑定）
2. **更新类工具**：是否需要添加 `tokenId` 用于权限验证
3. **向后兼容性**：是否需要保持旧工具函数可用

### 4.4 下一步行动

1. 确定 tokenId 注入方案（推荐方案二）
2. 创建数据转换工具模块
3. 修改工具函数签名和内部逻辑
4. 实现工具包装器（如果采用方案二）
5. 测试验证
6. 文档更新

