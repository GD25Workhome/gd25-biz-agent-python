# RAG向量存储与查询测试方案

## 一、测试目标

本测试方案用于验证RAG功能的基础能力：
1. **第一步**：测试将文本数据向量化并存储到PostgreSQL向量库
2. **第二步**：测试基于向量相似度的查询功能

## 二、技术栈

- **数据库**：PostgreSQL 17.6 + pgvector 0.8.1
- **向量维度**：768维（moka-ai/m3e-base模型）
- **Python库**：
  - `psycopg`：PostgreSQL驱动
  - `sentence-transformers`：文本向量化
  - `pgvector`：向量类型支持

## 三、第一步：向量存储测试

### 3.1 测试数据准备

使用简单的测试数据，模拟知识库条目：

```python
test_data = [
    {
        "scene_name": "血压达标场景",
        "scene_conditions": "90<=收缩压<=目标值 且 舒张压<=目标值",
        "patient_example": "我今天量了血压，120/80",
        "reply_template": "赞！血压已达标，继续加油保持！"
    },
    {
        "scene_name": "血压轻度偏高场景",
        "scene_conditions": "收缩压、舒张压任一值超过了对应设定目标值，但两者超过了均不到10mmHg",
        "patient_example": "我今天的血压是135/85，有点高",
        "reply_template": "我看到您本次测量的血压稍高，建议遵医嘱，规律用药。"
    },
    {
        "scene_name": "血压重度偏高场景",
        "scene_conditions": "收缩压>=180 or 舒张压>=110",
        "patient_example": "我量了血压，高压185，低压115",
        "reply_template": "您本次测量的血压过高，建议您尽快到医院就诊。"
    }
]
```

### 3.2 实现步骤

#### 步骤1：创建测试表结构

```sql
-- 创建测试表（简化版）
CREATE TABLE IF NOT EXISTS test_knowledge_base (
    id SERIAL PRIMARY KEY,
    scene_name VARCHAR(200) NOT NULL,
    scene_conditions TEXT,
    patient_example TEXT,
    reply_template TEXT,
    embedding vector(768),  -- 768维向量
    created_at TIMESTAMP DEFAULT NOW()
);

-- 创建向量索引（HNSW，用于快速相似度搜索）
CREATE INDEX IF NOT EXISTS test_knowledge_base_embedding_idx 
ON test_knowledge_base 
USING hnsw (embedding vector_cosine_ops);
```

#### 步骤2：文本向量化

```python
from sentence_transformers import SentenceTransformer

# 加载模型（首次运行会自动下载）
model = SentenceTransformer('moka-ai/m3e-base')

# 对文本进行向量化
def text_to_embedding(text: str) -> list:
    """
    将文本转换为768维向量
    
    Args:
        text: 输入文本
        
    Returns:
        list: 768维向量列表
    """
    embedding = model.encode(text, normalize_embeddings=True)
    return embedding.tolist()
```

#### 步骤3：数据入库

```python
import psycopg
from psycopg.types import TypeInfo, register_type
from pgvector.psycopg import register_vector

# 连接数据库
conn = psycopg.connect(
    "host=localhost port=5433 user=postgres "
    "password=sxl_pwd_123 dbname=gd25_biz_agent01_python"
)

# 注册vector类型
register_vector(conn)

# 插入数据
def insert_knowledge_entry(conn, entry: dict, embedding: list):
    """
    插入知识库条目
    
    Args:
        conn: 数据库连接
        entry: 知识条目字典
        embedding: 向量列表（768维）
    """
    with conn.cursor() as cur:
        # 构建向量化文本（用于检索）
        # 可以组合多个字段：场景名称 + 场景条件 + 患者示例
        text_for_embedding = f"{entry['scene_name']} {entry['scene_conditions']} {entry['patient_example']}"
        
        # 生成向量
        embedding_vector = text_to_embedding(text_for_embedding)
        
        # 插入数据（使用pgvector的vector类型）
        cur.execute("""
            INSERT INTO test_knowledge_base 
            (scene_name, scene_conditions, patient_example, reply_template, embedding)
            VALUES (%s, %s, %s, %s, %s)
        """, (
            entry['scene_name'],
            entry['scene_conditions'],
            entry['patient_example'],
            entry['reply_template'],
            embedding_vector  # psycopg会自动转换为vector类型
        ))
    
    conn.commit()
```

### 3.4 测试代码结构

```
cursor_test/rag/01_insertAndQuery/
├── 实现方案.md          # 本文档
├── step1_insert.py      # 第一步：向量存储测试
└── step2_query.py       # 第二步：向量查询测试
```

### 3.5 step1_insert.py 代码框架

```python
"""
第一步：向量存储测试
测试将文本数据向量化并存储到PostgreSQL向量库
"""

import sys
import os
from pathlib import Path

# 添加项目根目录到路径
project_root = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(project_root))

import psycopg
from sentence_transformers import SentenceTransformer
from pgvector.psycopg import register_vector

# 测试数据
TEST_DATA = [
    {
        "scene_name": "血压达标场景",
        "scene_conditions": "90<=收缩压<=目标值 且 舒张压<=目标值",
        "patient_example": "我今天量了血压，120/80",
        "reply_template": "赞！血压已达标，继续加油保持！"
    },
    # ... 更多测试数据
]

def main():
    """主函数"""
    # 1. 连接数据库
    # 2. 注册vector类型
    # 3. 创建表（如果不存在）
    # 4. 加载embedding模型
    # 5. 遍历测试数据，向量化并插入
    # 6. 验证插入结果
    pass

if __name__ == "__main__":
    main()
```

---

## 四、第二步：向量查询测试

### 4.1 查询场景

模拟用户问题，通过向量相似度检索最相关的知识条目：

```python
test_queries = [
    "我量了血压120/80，正常吗？",  # 应该匹配"血压达标场景"
    "今天血压有点高，135/85",      # 应该匹配"血压轻度偏高场景"
    "血压185/115，怎么办？",        # 应该匹配"血压重度偏高场景"
]
```

### 4.2 实现步骤

#### 步骤1：查询向量化

```python
# 将用户问题转换为向量
query_embedding = text_to_embedding(user_query)
```

#### 步骤2：向量相似度查询

```python
def search_similar_entries(conn, query_embedding: list, top_k: int = 3):
    """
    基于向量相似度检索相关知识条目
    
    Args:
        conn: 数据库连接
        query_embedding: 查询向量（768维）
        top_k: 返回Top-K个最相似的结果
        
    Returns:
        list: 检索结果列表，每个元素包含：
            - scene_name: 场景名称
            - scene_conditions: 场景条件
            - patient_example: 患者示例
            - reply_template: 回复模板
            - similarity: 相似度分数（余弦相似度，范围0-1）
    """
    with conn.cursor() as cur:
        # 使用余弦相似度查询（1 - 余弦距离 = 余弦相似度）
        # pgvector的 <-> 操作符计算余弦距离，1 - 距离 = 相似度
        cur.execute("""
            SELECT 
                scene_name,
                scene_conditions,
                patient_example,
                reply_template,
                1 - (embedding <-> %s::vector) as similarity
            FROM test_knowledge_base
            ORDER BY embedding <-> %s::vector
            LIMIT %s
        """, (query_embedding, query_embedding, top_k))
        
        results = []
        for row in cur.fetchall():
            results.append({
                "scene_name": row[0],
                "scene_conditions": row[1],
                "patient_example": row[2],
                "reply_template": row[3],
                "similarity": float(row[4])
            })
        
        return results
```

#### 步骤3：相似度阈值过滤

```python
def search_with_threshold(
    conn, 
    query_embedding: list, 
    top_k: int = 3,
    similarity_threshold: float = 0.7
):
    """
    带相似度阈值的检索
    
    Args:
        similarity_threshold: 相似度阈值，低于此值的结果将被过滤
        
    Returns:
        list: 过滤后的检索结果
    """
    results = search_similar_entries(conn, query_embedding, top_k)
    
    # 过滤低相似度结果
    filtered_results = [
        r for r in results 
        if r['similarity'] >= similarity_threshold
    ]
    
    return filtered_results
```

### 4.3 step2_query.py 代码框架

```python
"""
第二步：向量查询测试
测试基于向量相似度的查询功能
"""

import sys
import os
from pathlib import Path

# 添加项目根目录到路径
project_root = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(project_root))

import psycopg
from sentence_transformers import SentenceTransformer
from pgvector.psycopg import register_vector

# 测试查询
TEST_QUERIES = [
    "我量了血压120/80，正常吗？",
    "今天血压有点高，135/85",
    "血压185/115，怎么办？",
]

def main():
    """主函数"""
    # 1. 连接数据库
    # 2. 注册vector类型
    # 3. 加载embedding模型
    # 4. 遍历测试查询
    # 5. 对每个查询进行向量化
    # 6. 执行向量相似度查询
    # 7. 打印检索结果（包含相似度分数）
    pass

if __name__ == "__main__":
    main()
```

---

## 五、数据库连接配置

### 5.1 连接信息

从 `.env` 文件读取或直接使用：

```python
# 方式1：从环境变量读取（推荐）
import os
from dotenv import load_dotenv

load_dotenv()
DATABASE_URL = os.getenv("DATABASE_URL")

# 方式2：直接配置（测试用）
DATABASE_CONFIG = {
    "host": "localhost",
    "port": 5433,
    "user": "postgres",
    "password": "sxl_pwd_123",
    "dbname": "gd25_biz_agent01_python"
}

# 构建连接字符串
conn_string = (
    f"host={DATABASE_CONFIG['host']} "
    f"port={DATABASE_CONFIG['port']} "
    f"user={DATABASE_CONFIG['user']} "
    f"password={DATABASE_CONFIG['password']} "
    f"dbname={DATABASE_CONFIG['dbname']}"
)
```

### 5.2 表创建脚本

可以在测试代码中自动创建表，或单独执行SQL：

```python
def create_test_table(conn):
    """创建测试表"""
    with conn.cursor() as cur:
        # 创建表
        cur.execute("""
            CREATE TABLE IF NOT EXISTS test_knowledge_base (
                id SERIAL PRIMARY KEY,
                scene_name VARCHAR(200) NOT NULL,
                scene_conditions TEXT,
                patient_example TEXT,
                reply_template TEXT,
                embedding vector(768),
                created_at TIMESTAMP DEFAULT NOW()
            )
        """)
        
        # 创建索引
        cur.execute("""
            CREATE INDEX IF NOT EXISTS test_knowledge_base_embedding_idx 
            ON test_knowledge_base 
            USING hnsw (embedding vector_cosine_ops)
        """)
        
        conn.commit()
        print("✓ 测试表创建成功")
```

---

## 六、预期输出

### 6.1 第一步输出示例

```
开始向量存储测试...
✓ 数据库连接成功
✓ 测试表创建成功
✓ Embedding模型加载成功（moka-ai/m3e-base）

正在插入测试数据...
  [1/3] 插入：血压达标场景
  [2/3] 插入：血压轻度偏高场景
  [3/3] 插入：血压重度偏高场景

✓ 成功插入 3 条记录
✓ 向量存储测试完成
```

### 6.2 第二步输出示例

```
开始向量查询测试...
✓ 数据库连接成功
✓ Embedding模型加载成功（moka-ai/m3e-base）

查询1: "我量了血压120/80，正常吗？"
  检索结果（Top-3）：
    1. 血压达标场景 (相似度: 0.89)
       场景条件: 90<=收缩压<=目标值 且 舒张压<=目标值
       回复模板: 赞！血压已达标，继续加油保持！
    
    2. 血压轻度偏高场景 (相似度: 0.65)
       场景条件: 收缩压、舒张压任一值超过了对应设定目标值...
       回复模板: 我看到您本次测量的血压稍高...
    
    3. 血压重度偏高场景 (相似度: 0.42)
       场景条件: 收缩压>=180 or 舒张压>=110
       回复模板: 您本次测量的血压过高...

查询2: "今天血压有点高，135/85"
  检索结果（Top-3）：
    ...

✓ 向量查询测试完成
```

---

## 七、简化设计说明

### 7.1 简化的地方

1. **表结构简化**：
   - 只包含核心字段（场景名称、条件、示例、回复模板、向量）
   - 不包含元数据、版本、标签等复杂字段

2. **向量化策略简化**：
   - 直接使用场景名称+条件+示例的组合文本进行向量化
   - 不考虑多字段分别向量化或混合策略

3. **查询策略简化**：
   - 只使用余弦相似度
   - 不考虑关键词检索、混合检索等复杂策略

4. **错误处理简化**：
   - 基本的异常捕获，不包含详细的错误分类和处理

### 7.2 后续可以扩展的功能

- 多字段分别向量化（场景条件、患者示例、回复模板分别向量化）
- 混合检索（关键词+向量）
- 检索结果重排序
- 批量插入优化
- 向量缓存机制
- 更完善的错误处理和日志

---

## 八、运行方式

### 8.1 环境准备

```bash
# 1. 激活conda环境
conda activate py_311_rag

# 2. 确保已安装依赖
pip install sentence-transformers pgvector psycopg

# 3. 确保数据库已安装vector扩展
# （已在环境检查报告中确认）
```

### 8.2 执行测试

```bash
# 第一步：向量存储测试
cd cursor_test/rag/01_insertAndQuery
python step1_insert.py

# 第二步：向量查询测试
python step2_query.py
```

---

## 九、注意事项

1. **首次运行**：`moka-ai/m3e-base` 模型会自动下载，需要一定时间
2. **数据库连接**：确保数据库服务正在运行，且连接信息正确
3. **vector扩展**：确保数据库已安装pgvector扩展（已在环境检查中确认）
4. **测试数据隔离**：使用 `test_knowledge_base` 表，不影响主业务数据
5. **向量维度**：确保使用768维向量（moka-ai/m3e-base的输出维度）

---

**文档版本**: v1.0  
**创建时间**: 2025-01-XX  
**测试目标**: 验证RAG基础功能（向量存储+查询）
