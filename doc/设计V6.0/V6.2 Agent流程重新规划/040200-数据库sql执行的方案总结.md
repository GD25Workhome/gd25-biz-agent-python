# 数据库SQL执行方案总结

## 一、数据库代码架构概述

当前数据库代码采用**分层架构**设计，主要包含以下层次：

```
┌─────────────────────────────────────────┐
│         Tools层（业务工具）              │
│  domain/tools/*/record.py               │
└──────────────┬──────────────────────────┘
               │ 调用
┌──────────────▼──────────────────────────┐
│      Repository层（数据访问层）          │
│  infrastructure/database/repository/    │
│  - base.py（基础仓储类）                 │
│  - *_repository.py（具体仓储实现）       │
└──────────────┬──────────────────────────┘
               │ 使用
┌──────────────▼──────────────────────────┐
│      Connection层（连接管理）            │
│  infrastructure/database/connection.py  │
│  - get_async_session_factory()          │
│  - get_async_engine()                   │
└──────────────┬──────────────────────────┘
               │ 使用
┌──────────────▼──────────────────────────┐
│      Models层（数据模型）                │
│  infrastructure/database/models/        │
│  - Base（SQLAlchemy基类）                │
│  - *_model.py（具体模型定义）            │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│          PostgreSQL数据库                │
└─────────────────────────────────────────┘
```

### 1.1 核心组件说明

#### Models层（数据模型）
- **位置**：`infrastructure/database/models/`
- **职责**：定义数据库表结构和ORM模型
- **基类**：`infrastructure/database/base.py` 中的 `Base`
- **特点**：
  - 使用SQLAlchemy ORM
  - 支持ULID作为主键（通过 `generate_ulid()` 函数）
  - 时区感知的时间字段（`DateTime(timezone=True)`）

#### Repository层（数据访问层）
- **位置**：`infrastructure/database/repository/`
- **职责**：封装数据库CRUD操作，提供业务无关的数据访问接口
- **基类**：`BaseRepository[ModelType]`（泛型类）
- **特点**：
  - 提供通用的CRUD方法（`get_by_id`, `create`, `update`, `delete`, `get_all`）
  - 支持子类扩展特定查询方法
  - 使用SQLAlchemy的异步API

#### Connection层（连接管理）
- **位置**：`infrastructure/database/connection.py`
- **职责**：管理数据库连接池和会话工厂
- **核心函数**：
  - `get_async_engine()`：获取异步数据库引擎（单例）
  - `get_async_session_factory()`：获取异步会话工厂（单例）
  - `get_async_session()`：获取异步数据库会话（生成器）

#### Tools层（业务工具）
- **位置**：`domain/tools/*/record.py`
- **职责**：实现具体的业务逻辑，调用Repository进行数据操作
- **特点**：
  - 使用 `@tool` 装饰器注册为LangChain工具
  - 每个工具函数内部创建和管理数据库会话
  - 负责事务提交（`session.commit()`）

---

## 二、工具代码执行数据库的链路

### 2.1 完整执行链路

以 `record_blood_pressure` 工具为例，完整的数据库执行链路如下：

```
1. Agent调用工具
   └─> domain/tools/blood_pressure/record.py::record_blood_pressure()

2. 工具函数内部处理
   ├─> 参数转换（token_id -> user_id）
   ├─> 时间解析（ISO字符串 -> datetime对象）
   └─> 获取数据库会话工厂
       └─> infrastructure/database/connection.py::get_async_session_factory()

3. 创建数据库会话
   └─> session_factory() -> AsyncSession

4. 创建Repository实例
   └─> BloodPressureRepository(session)

5. Repository执行数据库操作
   └─> infrastructure/database/repository/base.py::BaseRepository.create()
       ├─> 创建模型实例：self.model(**kwargs)
       ├─> 添加到会话：self.session.add(instance)
       └─> 刷新会话：await self.session.flush()

6. 提交事务
   └─> await session.commit()

7. 返回结果
   └─> 返回成功消息字符串
```

### 2.2 代码示例

```python
# domain/tools/blood_pressure/record.py
@tool
async def record_blood_pressure(...):
    # 1. 参数处理
    user_info = convert_token_to_user_info(token_id)
    user_id = user_info.user_id
    
    # 2. 获取数据库会话工厂（单例）
    session_factory = get_async_session_factory()
    
    # 3. 创建数据库会话（上下文管理器）
    async with session_factory() as session:
        # 4. 创建Repository实例
        repo = BloodPressureRepository(session)
        
        # 5. 执行创建操作
        record = await repo.create(**create_data)
        
        # 6. 提交事务
        await session.commit()
    
    # 7. 返回结果
    return f"成功记录血压：..."
```

### 2.3 支撑代码结构

#### 2.3.1 会话工厂获取

```python
# infrastructure/database/connection.py
def get_async_session_factory() -> async_sessionmaker[AsyncSession]:
    """获取异步会话工厂（单例模式）"""
    global _async_session_factory
    if _async_session_factory is None:
        engine = get_async_engine()  # 获取引擎（单例）
        _async_session_factory = async_sessionmaker(
            engine,
            class_=AsyncSession,
            expire_on_commit=False
        )
    return _async_session_factory
```

#### 2.3.2 Repository基类

```python
# infrastructure/database/repository/base.py
class BaseRepository(Generic[ModelType]):
    """基础仓储类"""
    
    def __init__(self, session: AsyncSession, model: Type[ModelType]):
        self.session = session
        self.model = model
    
    async def create(self, **kwargs) -> ModelType:
        """创建记录"""
        instance = self.model(**kwargs)
        self.session.add(instance)
        await self.session.flush()  # 刷新到数据库，但不提交
        return instance
```

#### 2.3.3 具体Repository实现

```python
# infrastructure/database/repository/blood_pressure_repository.py
class BloodPressureRepository(BaseRepository[BloodPressureRecord]):
    """血压记录仓储类"""
    
    def __init__(self, session: AsyncSession):
        super().__init__(session, BloodPressureRecord)
    
    # 可以扩展特定查询方法
    async def get_by_user_id(self, user_id: str, ...):
        result = await self.session.execute(
            select(BloodPressureRecord)
            .where(BloodPressureRecord.user_id == user_id)
            ...
        )
        return list(result.scalars().all())
```

---

## 三、CRUD各个代码的执行链路

### 3.1 Create（创建）操作链路

```
工具函数
  └─> Repository.create(**kwargs)
      ├─> 创建模型实例：instance = self.model(**kwargs)
      ├─> 添加到会话：self.session.add(instance)
      ├─> 刷新会话：await self.session.flush()
      │   └─> SQLAlchemy生成INSERT SQL
      │       └─> 执行SQL（未提交）
      └─> 返回实例（包含生成的ID）
  └─> 工具函数中：await session.commit()
      └─> 提交事务，数据持久化
```

**代码位置**：
- 基类方法：`infrastructure/database/repository/base.py::BaseRepository.create()`
- 调用示例：`domain/tools/blood_pressure/record.py::record_blood_pressure()`

**关键点**：
- `flush()` 将SQL发送到数据库但**不提交事务**
- `commit()` 由工具函数在外部调用，确保事务完整性
- 模型实例在 `flush()` 后即可获得自动生成的ID（如ULID）

### 3.2 Read（查询）操作链路

#### 3.2.1 根据ID查询

```
工具函数
  └─> Repository.get_by_id(id)
      └─> await self.session.execute(
          select(self.model).where(self.model.id == id)
      )
      └─> SQLAlchemy生成SELECT SQL
          └─> 执行SQL查询
      └─> result.scalar_one_or_none()
          └─> 返回模型实例或None
```

**代码位置**：
- 基类方法：`infrastructure/database/repository/base.py::BaseRepository.get_by_id()`

#### 3.2.2 查询所有记录

```
工具函数
  └─> Repository.get_all(limit, offset)
      └─> await self.session.execute(
          select(self.model).limit(limit).offset(offset)
      )
      └─> SQLAlchemy生成SELECT SQL（带LIMIT和OFFSET）
          └─> 执行SQL查询
      └─> result.scalars().all()
          └─> 返回模型实例列表
```

**代码位置**：
- 基类方法：`infrastructure/database/repository/base.py::BaseRepository.get_all()`

#### 3.2.3 扩展查询方法（如按用户ID查询）

```
工具函数
  └─> Repository.get_by_user_id(user_id, limit, offset)
      └─> await self.session.execute(
          select(BloodPressureRecord)
          .where(BloodPressureRecord.user_id == user_id)
          .order_by(desc(BloodPressureRecord.record_time))
          .limit(limit)
          .offset(offset)
      )
      └─> SQLAlchemy生成SELECT SQL（带WHERE、ORDER BY、LIMIT、OFFSET）
          └─> 执行SQL查询
      └─> result.scalars().all()
          └─> 返回模型实例列表
```

**代码位置**：
- 具体实现：`infrastructure/database/repository/blood_pressure_repository.py::BloodPressureRepository.get_by_user_id()`

**关键点**：
- 查询操作通常**不需要显式commit**（只读操作）
- 可以使用SQLAlchemy的查询构建器进行复杂查询
- 支持链式调用（`.where()`, `.order_by()`, `.limit()`, `.offset()`）

### 3.3 Update（更新）操作链路

```
工具函数
  └─> Repository.update(id, **kwargs)
      ├─> 先查询记录：instance = await self.get_by_id(id)
      ├─> 如果记录不存在，返回None
      ├─> 更新字段：setattr(instance, key, value) for key, value in kwargs.items()
      ├─> 刷新会话：await self.session.flush()
      │   └─> SQLAlchemy检测到对象变更
      │       └─> 生成UPDATE SQL
      │           └─> 执行SQL（未提交）
      └─> 返回更新后的实例
  └─> 工具函数中：await session.commit()
      └─> 提交事务，数据持久化
```

**代码位置**：
- 基类方法：`infrastructure/database/repository/base.py::BaseRepository.update()`

**关键点**：
- 使用 `setattr()` 动态更新字段
- SQLAlchemy会自动跟踪对象变更，生成对应的UPDATE语句
- 只更新传入的字段，未传入的字段保持不变

### 3.4 Delete（删除）操作链路

```
工具函数
  └─> Repository.delete(id)
      ├─> 先查询记录：instance = await self.get_by_id(id)
      ├─> 如果记录不存在，返回False
      ├─> 删除记录：await self.session.delete(instance)
      ├─> 刷新会话：await self.session.flush()
      │   └─> SQLAlchemy生成DELETE SQL
      │       └─> 执行SQL（未提交）
      └─> 返回True
  └─> 工具函数中：await session.commit()
      └─> 提交事务，数据持久化
```

**代码位置**：
- 基类方法：`infrastructure/database/repository/base.py::BaseRepository.delete()`

**关键点**：
- 删除前需要先查询记录是否存在
- 使用 `session.delete()` 标记对象为删除状态
- `flush()` 后生成DELETE SQL，`commit()` 后真正删除

---

## 四、数据库执行日志支持方案

### 4.1 当前架构的日志支持能力

当前代码架构在多个层面支持添加数据库执行日志：

#### 4.1.1 SQLAlchemy引擎层面（已支持）

**位置**：`infrastructure/database/connection.py::get_async_engine()`

```python
_async_engine = create_async_engine(
    settings.ASYNC_DB_URI,
    echo=settings.DEBUG,  # 当DEBUG=True时，会打印所有SQL语句
    ...
)
```

**特点**：
- ✅ 已实现，通过 `echo` 参数控制
- ✅ 可以打印所有SQL语句和参数
- ⚠️ 日志级别较低，输出到标准输出
- ⚠️ 格式固定，不易自定义

#### 4.1.2 Repository层面（可扩展）

**位置**：`infrastructure/database/repository/base.py`

**方案1：装饰器模式**

```python
from functools import wraps
import logging

logger = logging.getLogger(__name__)

def log_db_operation(operation: str):
    """数据库操作日志装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(self, *args, **kwargs):
            start_time = time.time()
            try:
                result = await func(self, *args, **kwargs)
                duration = time.time() - start_time
                logger.info(
                    f"DB {operation} success",
                    extra={
                        "operation": operation,
                        "model": self.model.__name__,
                        "duration_ms": duration * 1000,
                        "args": args,
                        "kwargs": kwargs
                    }
                )
                return result
            except Exception as e:
                duration = time.time() - start_time
                logger.error(
                    f"DB {operation} failed",
                    extra={
                        "operation": operation,
                        "model": self.model.__name__,
                        "duration_ms": duration * 1000,
                        "error": str(e)
                    },
                    exc_info=True
                )
                raise
        return wrapper
    return decorator

# 使用示例
class BaseRepository(Generic[ModelType]):
    @log_db_operation("CREATE")
    async def create(self, **kwargs) -> ModelType:
        ...
    
    @log_db_operation("READ")
    async def get_by_id(self, id: str) -> Optional[ModelType]:
        ...
```

**方案2：中间件模式**

```python
class BaseRepository(Generic[ModelType]):
    async def _execute_with_logging(self, operation: str, func, *args, **kwargs):
        """执行数据库操作并记录日志"""
        start_time = time.time()
        try:
            result = await func(*args, **kwargs)
            duration = time.time() - start_time
            logger.info(
                f"DB {operation}",
                extra={
                    "operation": operation,
                    "model": self.model.__name__,
                    "duration_ms": duration * 1000
                }
            )
            return result
        except Exception as e:
            duration = time.time() - start_time
            logger.error(
                f"DB {operation} failed",
                extra={
                    "operation": operation,
                    "model": self.model.__name__,
                    "duration_ms": duration * 1000,
                    "error": str(e)
                },
                exc_info=True
            )
            raise
    
    async def create(self, **kwargs) -> ModelType:
        return await self._execute_with_logging(
            "CREATE",
            self._create_impl,
            **kwargs
        )
    
    async def _create_impl(self, **kwargs) -> ModelType:
        instance = self.model(**kwargs)
        self.session.add(instance)
        await self.session.flush()
        return instance
```

#### 4.1.3 SQLAlchemy事件监听器层面（推荐）

**位置**：`infrastructure/database/connection.py`

**方案：使用SQLAlchemy的事件系统**

```python
from sqlalchemy import event
from sqlalchemy.engine import Engine
import logging

logger = logging.getLogger(__name__)

def setup_db_logging():
    """设置数据库日志监听器"""
    
    @event.listens_for(Engine, "before_cursor_execute")
    def receive_before_cursor_execute(conn, cursor, statement, parameters, context, executemany):
        """SQL执行前记录日志"""
        conn.info.setdefault('query_start_time', []).append(time.time())
        logger.debug(
            "Executing SQL",
            extra={
                "sql": statement,
                "parameters": parameters,
                "executemany": executemany
            }
        )
    
    @event.listens_for(Engine, "after_cursor_execute")
    def receive_after_cursor_execute(conn, cursor, statement, parameters, context, executemany):
        """SQL执行后记录日志"""
        total = time.time() - conn.info['query_start_time'].pop(-1)
        logger.info(
            "SQL executed",
            extra={
                "sql": statement,
                "parameters": parameters,
                "duration_ms": total * 1000,
                "executemany": executemany
            }
        )
    
    @event.listens_for(Engine, "handle_error")
    def receive_handle_error(exception_context):
        """SQL执行错误记录日志"""
        logger.error(
            "SQL execution error",
            extra={
                "sql": exception_context.statement,
                "parameters": exception_context.parameters,
                "error": str(exception_context.original_exception)
            },
            exc_info=exception_context.original_exception
        )

# 在get_async_engine()中调用
def get_async_engine():
    global _async_engine
    if _async_engine is None:
        _async_engine = create_async_engine(...)
        setup_db_logging()  # 设置日志监听器
    return _async_engine
```

**优点**：
- ✅ 统一拦截所有SQL执行
- ✅ 可以记录执行时间、参数、错误信息
- ✅ 不影响业务代码，透明添加
- ✅ 可以记录所有ORM操作生成的SQL

#### 4.1.4 Tool层面（业务日志）

**位置**：`domain/tools/*/record.py`

```python
import logging

logger = logging.getLogger(__name__)

@tool
async def record_blood_pressure(...):
    logger.info(
        "Recording blood pressure",
        extra={
            "user_id": user_id,
            "systolic": systolic,
            "diastolic": diastolic
        }
    )
    
    session_factory = get_async_session_factory()
    async with session_factory() as session:
        repo = BloodPressureRepository(session)
        record = await repo.create(**create_data)
        await session.commit()
    
    logger.info(
        "Blood pressure recorded",
        extra={
            "record_id": record.id,
            "user_id": user_id
        }
    )
    
    return f"成功记录血压：..."
```

### 4.2 推荐的日志实现方案

#### 方案A：SQLAlchemy事件监听器（推荐用于SQL日志）

**适用场景**：需要记录所有SQL执行情况，包括ORM自动生成的SQL

**实现步骤**：
1. 在 `infrastructure/database/connection.py` 中添加事件监听器
2. 配置日志格式，包含SQL语句、参数、执行时间
3. 可以按日志级别控制输出（DEBUG级别输出详细SQL，INFO级别输出摘要）

**优点**：
- 统一拦截，无需修改每个Repository方法
- 可以记录ORM自动生成的SQL
- 性能影响小（异步事件）

#### 方案B：Repository装饰器（推荐用于操作日志）

**适用场景**：需要记录业务层面的数据库操作（CREATE/READ/UPDATE/DELETE）

**实现步骤**：
1. 在 `infrastructure/database/repository/base.py` 中添加日志装饰器
2. 为每个CRUD方法添加装饰器
3. 记录操作类型、模型名称、执行时间、参数

**优点**：
- 业务语义清晰（CREATE/READ/UPDATE/DELETE）
- 可以记录业务相关的上下文信息
- 易于过滤和统计

#### 方案C：混合方案（推荐）

**同时使用方案A和方案B**：
- **SQLAlchemy事件监听器**：记录底层SQL执行日志（用于调试和性能分析）
- **Repository装饰器**：记录业务操作日志（用于业务监控和审计）

### 4.3 日志格式建议

#### SQL执行日志格式

```json
{
  "timestamp": "2024-01-01T12:00:00.000Z",
  "level": "INFO",
  "logger": "infrastructure.database.connection",
  "message": "SQL executed",
  "sql": "INSERT INTO biz_agent_blood_pressure_records (id, user_id, systolic, diastolic) VALUES ($1, $2, $3, $4)",
  "parameters": ["01ARZ3NDEKTSV4RRFFQ69G5FAV", "user123", 120, 80],
  "duration_ms": 15.5,
  "executemany": false
}
```

#### 业务操作日志格式

```json
{
  "timestamp": "2024-01-01T12:00:00.000Z",
  "level": "INFO",
  "logger": "infrastructure.database.repository",
  "message": "DB CREATE success",
  "operation": "CREATE",
  "model": "BloodPressureRecord",
  "duration_ms": 15.5,
  "record_id": "01ARZ3NDEKTSV4RRFFQ69G5FAV",
  "user_id": "user123"
}
```

### 4.4 实现注意事项

1. **性能考虑**：
   - 日志记录应该是异步的，避免阻塞数据库操作
   - 生产环境可以只记录ERROR和WARN级别
   - 可以使用采样率控制日志量

2. **敏感信息**：
   - 避免记录敏感数据（如密码、token等）
   - 可以对参数进行脱敏处理

3. **日志聚合**：
   - 建议使用结构化日志（JSON格式）
   - 便于日志聚合系统（如ELK、Loki）进行查询和分析

4. **配置化**：
   - 日志级别和格式应该可以通过配置文件控制
   - 不同环境（开发/测试/生产）使用不同的日志策略

---

## 五、总结

### 5.1 架构特点

1. **分层清晰**：Models → Repository → Connection → Tools，职责明确
2. **异步支持**：全面使用SQLAlchemy异步API，支持高并发
3. **事务管理**：工具函数负责事务边界，Repository只负责数据操作
4. **可扩展性**：基类提供通用方法，子类可以扩展特定查询

### 5.2 执行流程

1. **工具函数**创建数据库会话
2. **Repository**封装数据访问逻辑
3. **SQLAlchemy ORM**生成和执行SQL
4. **工具函数**提交事务

### 5.3 日志支持

当前架构支持在多个层面添加日志：
- ✅ SQLAlchemy引擎层面（已实现，通过echo参数）
- ✅ Repository层面（可扩展，推荐使用装饰器）
- ✅ SQLAlchemy事件层面（推荐，统一拦截SQL）
- ✅ Tool层面（业务日志，已支持）

**推荐方案**：使用SQLAlchemy事件监听器 + Repository装饰器的混合方案，既记录底层SQL，又记录业务操作。

