# LangChain 1.2.0 导入问题分析

## 问题描述

在 `test_Ex2_multiAgentLangGraph.py` 第 114-115 行出现导入错误：

```python
from langchain.agents import AgentExecutor, create_openai_tools_agent
ImportError: cannot import name 'AgentExecutor' from 'langchain.agents'
```

## 根本原因

### 1. 版本不匹配

- **伪代码示例来源**：Langfuse 官方文档的示例代码
- **示例使用的版本**：可能是 LangChain 0.x 版本
- **当前环境版本**：LangChain 1.2.0

### 2. API 变更

在 LangChain 1.x 版本中，以下 API 已被移除或重构：

#### ❌ 已移除的 API（LangChain 0.x）
- `AgentExecutor` - 智能体执行器类
- `create_openai_tools_agent` - 创建 OpenAI 工具智能体的函数

#### ✅ 新的 API（LangChain 1.x）
- `langchain.agents.create_agent` - 创建智能体图（返回 `CompiledStateGraph`）
- `langgraph.prebuilt.create_react_agent` - 创建 ReAct 智能体（返回 `CompiledStateGraph`）

### 3. 当前环境可用内容

通过检查当前环境（LangChain 1.2.0），`langchain.agents` 模块包含：

```python
['AgentState', 'create_agent', 'factory', 'middleware', 'structured_output']
```

**注意**：没有 `AgentExecutor` 和 `create_openai_tools_agent`

## 解决方案

### 方案一：创建兼容层（推荐）

创建兼容的包装类和函数，使代码可以在 LangChain 1.2.0 中运行，同时保持与伪代码示例相似的接口。

#### 1. 创建兼容的 `AgentExecutor` 类

```python
class AgentExecutor:
    """兼容 LangChain 0.x 的 AgentExecutor 包装类"""
    
    def __init__(self, graph, tools):
        """
        Args:
            graph: LangGraph 编译后的图（CompiledStateGraph）
            tools: 工具列表
        """
        self.graph = graph
        self.tools = tools
    
    def invoke(self, state):
        """
        调用智能体
        
        Args:
            state: 状态字典，通常包含 "messages" 字段
            
        Returns:
            dict: 包含 "output" 字段的字典
        """
        # 调用 LangGraph 图
        result = self.graph.invoke(state)
        
        # 提取最后一条 AI 消息作为输出
        output = ""
        if result.get("messages"):
            for msg in reversed(result["messages"]):
                if hasattr(msg, "type") and msg.type == "ai":
                    output = msg.content if isinstance(msg.content, str) else str(msg.content)
                    break
        
        return {"output": output, "messages": result.get("messages", [])}
```

#### 2. 创建兼容的 `create_openai_tools_agent` 函数

```python
from langchain.agents import create_agent as langchain_create_agent

def create_openai_tools_agent(llm, tools, prompt):
    """
    兼容函数：使用 LangChain 1.x 的 create_agent 创建智能体
    
    Args:
        llm: LLM 客户端
        tools: 工具列表
        prompt: 提示词模板
        
    Returns:
        CompiledStateGraph: LangGraph 编译后的图
    """
    # 从 prompt 中提取 system_prompt
    system_prompt = None
    if hasattr(prompt, 'messages'):
        for msg in prompt.messages:
            if hasattr(msg, 'prompt') and hasattr(msg.prompt, 'template'):
                if 'system' in str(msg).lower():
                    system_prompt = msg.prompt.template
                    break
    
    # 使用 LangChain 1.x 的 create_agent
    graph = langchain_create_agent(
        model=llm,
        tools=tools,
        system_prompt=system_prompt
    )
    
    return graph
```

### 方案二：直接使用 LangChain 1.x API

完全重写 `create_agent` 函数，直接使用 `langchain.agents.create_agent`：

```python
from langchain.agents import create_agent as langchain_create_agent

def create_agent(llm: ChatOpenAI, system_prompt: str, tools: list):
    """
    使用 LangChain 1.x API 创建智能体
    
    Returns:
        CompiledStateGraph: LangGraph 编译后的图
    """
    graph = langchain_create_agent(
        model=llm,
        tools=tools,
        system_prompt=system_prompt
    )
    return graph
```

然后修改 `agent_node` 函数以适配 `CompiledStateGraph`：

```python
def agent_node(state, agent_graph, name):
    """
    智能体节点函数（适配 CompiledStateGraph）
    """
    result = agent_graph.invoke(state)
    
    # 提取最后一条 AI 消息
    output = ""
    if result.get("messages"):
        for msg in reversed(result["messages"]):
            if hasattr(msg, "type") and msg.type == "ai":
                output = msg.content if isinstance(msg.content, str) else str(msg.content)
                break
    
    return {"messages": [HumanMessage(content=output, name=name)]}
```

## 推荐方案

**推荐使用方案一（兼容层）**，因为：
1. 最小化代码改动
2. 保持与伪代码示例的接口一致性
3. 便于理解原始设计意图
4. 如果将来需要升级到更新版本，只需修改兼容层

## 注意事项

1. **不升级包版本**：按照要求，不修改环境中的包版本
2. **保持接口一致**：确保兼容层的行为与原始 API 尽可能一致
3. **测试验证**：修改后需要测试确保功能正常

## 相关文件

- 问题文件：`cursor_test/langfuse/04multiAgent/test_Ex2_multiAgentLangGraph.py`
- 参考文件：`cursor_test/langfuse/03LangChain/test_multi_agent_langgraph.py`
- 项目中的兼容实现：`backend/domain/agents/factory.py`（包含 `AgentExecutor` 包装类）

