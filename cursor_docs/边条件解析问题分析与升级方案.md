# 边条件解析问题分析与升级方案

## 一、问题概述

当前 `backend/domain/flows/builder.py` 中的 `_evaluate_condition` 方法无法正确识别和解析 `config/flows/medical_agent/flow.yaml` 中定义的复杂边条件表达式。

### 1.1 配置中的边定义

```yaml
edges:
  - from: intent_recognition
    to: blood_pressure_agent
    condition: intent == "blood_pressure" && confidence >= 0.8
  
  - from: intent_recognition
    to: qa_agent
    condition: intent == "qa" && confidence >= 0.8
  
  - from: intent_recognition
    to: unclear_agent
    condition: intent == "greeting" || need_clarification == true
```

### 1.2 问题表现

- 边条件包含逻辑运算符（`&&`、`||`）无法解析
- 边条件包含数值比较（`>=`）无法解析
- 边条件引用的状态字段（`confidence`、`need_clarification`）在 FlowState 中不存在
- 所有复杂条件都会被错误地评估为 `False`，导致路由失败

---

## 二、当前代码逻辑分析

### 2.1 边条件评估流程

**文件位置**: `backend/domain/flows/builder.py`

**关键方法**: `_evaluate_condition` (第199-221行)

```python
@staticmethod
def _evaluate_condition(condition: str, state: FlowState) -> bool:
    """
    评估条件表达式（简化版，仅支持简单的条件判断）
    """
    # 简化处理：仅支持 intent == "xxx" 的条件
    if "==" in condition:
        parts = condition.split("==")
        if len(parts) == 2:
            key = parts[0].strip()
            value = parts[1].strip().strip('"\'')
            
            if key == "intent":
                return state.get("intent") == value
    
    # 默认返回False
    return False
```

### 2.2 代码逻辑说明

1. **条件解析方式**：
   - 仅检查条件字符串中是否包含 `==`
   - 使用简单的字符串分割 `split("==")` 来解析
   - 只支持 `key == "value"` 这种最简单的格式

2. **支持的条件类型**：
   - ✅ `intent == "blood_pressure"` （仅限 intent 字段）
   - ❌ `intent == "blood_pressure" && confidence >= 0.8` （不支持逻辑运算符）
   - ❌ `confidence >= 0.8` （不支持数值比较）
   - ❌ `intent == "greeting" || need_clarification == true` （不支持逻辑或）

3. **状态字段访问**：
   - 仅支持访问 `state.get("intent")`
   - 不支持访问 `confidence`、`need_clarification` 等字段

### 2.3 路由函数构建逻辑

**文件位置**: `backend/domain/flows/builder.py`

**关键方法**: `build_graph` (第58-74行)

```python
if conditional_edges:
    # 条件边：创建路由函数
    edges_list = conditional_edges.copy()
    
    def route_func(state: FlowState) -> str:
        """路由函数"""
        for edge in edges_list:
            if GraphBuilder._evaluate_condition(edge.condition, state):
                return edge.to_node
        return END
    
    # 构建路由映射
    route_map = {edge.to_node: edge.to_node for edge in conditional_edges}
    route_map[END] = END
    
    graph.add_conditional_edges(from_node, route_func, route_map)
```

**路由逻辑说明**：
- 按顺序遍历所有条件边
- 对每个边的条件调用 `_evaluate_condition` 进行评估
- 如果条件为真，返回目标节点
- 如果所有条件都为假，返回 `END`（流程结束）

---

## 三、失败原因分析

### 3.1 根本原因

**原因1：条件解析器过于简化**
- 当前实现只支持最简单的 `key == "value"` 格式
- 无法处理包含逻辑运算符的复合条件
- 无法处理数值比较运算符（`>=`、`<=`、`>`、`<`）

**原因2：状态字段缺失**
- `FlowState` 中只定义了 `intent` 字段
- 配置中使用的 `confidence` 和 `need_clarification` 字段在状态中不存在
- 即使解析器支持，也无法从状态中获取这些值

**原因3：条件评估逻辑不完整**
- 没有实现逻辑运算符的优先级处理
- 没有实现短路求值（`&&` 和 `||` 的特性）
- 没有类型转换（字符串、数字、布尔值的处理）

### 3.2 具体失败场景

#### 场景1：包含逻辑与的条件
```yaml
condition: intent == "blood_pressure" && confidence >= 0.8
```
**失败原因**：
- `_evaluate_condition` 方法使用 `split("==")` 分割，会得到 `['intent ', ' "blood_pressure" && confidence >= 0.8']`
- 第二部分包含 `&&`，无法正确解析
- 最终返回 `False`

#### 场景2：包含数值比较的条件
```yaml
condition: confidence >= 0.8
```
**失败原因**：
- 条件中不包含 `==`，`_evaluate_condition` 方法直接返回 `False`
- 即使包含 `==`，也不支持 `>=` 运算符

#### 场景3：包含逻辑或的条件
```yaml
condition: intent == "greeting" || need_clarification == true
```
**失败原因**：
- 不支持 `||` 运算符
- `need_clarification` 字段在 `FlowState` 中不存在
- 即使解析成功，也无法从状态中获取值

### 3.3 实际运行效果

当流程执行到 `intent_recognition` 节点后：
1. 所有边的条件评估都会返回 `False`
2. 路由函数返回 `END`
3. 流程直接结束，无法路由到任何目标节点（`blood_pressure_agent`、`qa_agent`、`unclear_agent`）
4. 用户请求无法得到正确的处理

---

## 四、升级方案

### 4.1 方案概述

采用**表达式解析器**方案，支持完整的条件表达式解析和评估。

### 4.2 方案一：使用 AST 解析（推荐）

#### 4.2.1 实现思路

使用 Python 的 `ast` 模块将条件表达式解析为抽象语法树，然后安全地评估。

**优点**：
- 安全性高（可以限制可用的操作符和函数）
- 支持完整的 Python 表达式语法
- 易于扩展和维护

**缺点**：
- 实现复杂度较高
- 需要处理 AST 节点的遍历和评估

#### 4.2.2 实现步骤

1. **扩展 FlowState**：
   ```python
   class FlowState(TypedDict, total=False):
       # ... 现有字段 ...
       intent: Optional[str]
       confidence: Optional[float]  # 新增：置信度
       need_clarification: Optional[bool]  # 新增：是否需要澄清
   ```

2. **实现 AST 表达式解析器**：
   ```python
   import ast
   import operator
   
   class ConditionEvaluator:
       """条件表达式评估器"""
       
       # 允许的操作符映射
       ALLOWED_OPERATORS = {
           ast.Eq: operator.eq,      # ==
           ast.NotEq: operator.ne,   # !=
           ast.Lt: operator.lt,       # <
           ast.LtE: operator.le,     # <=
           ast.Gt: operator.gt,       # >
           ast.GtE: operator.ge,      # >=
           ast.And: lambda a, b: a and b,  # &&
           ast.Or: lambda a, b: a or b,   # ||
           ast.Not: operator.not_,    # !
       }
       
       @staticmethod
       def evaluate(condition: str, state: FlowState) -> bool:
           """评估条件表达式"""
           try:
               # 解析表达式为 AST
               tree = ast.parse(condition, mode='eval')
               # 评估 AST
               return ConditionEvaluator._eval_node(tree.body, state)
           except Exception as e:
               logger.error(f"条件表达式解析失败: {condition}, 错误: {e}")
               return False
       
       @staticmethod
       def _eval_node(node, state: FlowState):
           """递归评估 AST 节点"""
           if isinstance(node, ast.Compare):
               # 比较表达式：a >= b
               left = ConditionEvaluator._eval_node(node.left, state)
               for op, right_node in zip(node.ops, node.comparators):
                   right = ConditionEvaluator._eval_node(right_node, state)
                   op_func = ConditionEvaluator.ALLOWED_OPERATORS[type(op)]
                   if not op_func(left, right):
                       return False
               return True
           
           elif isinstance(node, ast.BoolOp):
               # 逻辑运算：a && b, a || b
               op_func = ConditionEvaluator.ALLOWED_OPERATORS[type(node.op)]
               values = [ConditionEvaluator._eval_node(v, state) for v in node.values]
               return op_func(*values)
           
           elif isinstance(node, ast.Name):
               # 变量名：从 state 中获取值
               return state.get(node.id)
           
           elif isinstance(node, ast.Constant):
               # 常量值
               return node.value
           
           # ... 其他节点类型处理 ...
   ```

3. **更新 builder.py**：
   ```python
   @staticmethod
   def _evaluate_condition(condition: str, state: FlowState) -> bool:
       """评估条件表达式"""
       from backend.domain.flows.condition_evaluator import ConditionEvaluator
       return ConditionEvaluator.evaluate(condition, state)
   ```

#### 4.2.3 支持的条件格式

- ✅ `intent == "blood_pressure"`
- ✅ `intent == "blood_pressure" && confidence >= 0.8`
- ✅ `confidence >= 0.8`
- ✅ `intent == "greeting" || need_clarification == true`
- ✅ `intent != "unclear" && confidence > 0.5`
- ✅ `(intent == "qa" || intent == "blood_pressure") && confidence >= 0.8`

### 4.3 方案二：使用正则表达式解析（简单但有限）

#### 4.3.1 实现思路

使用正则表达式匹配和解析条件表达式，支持常见的条件格式。

**优点**：
- 实现简单
- 性能较好

**缺点**：
- 功能有限，难以支持复杂的嵌套表达式
- 正则表达式难以处理括号优先级
- 扩展性差

#### 4.3.2 实现示例

```python
import re

class SimpleConditionEvaluator:
    """简单条件表达式评估器"""
    
    @staticmethod
    def evaluate(condition: str, state: FlowState) -> bool:
        """评估条件表达式"""
        # 处理逻辑或：||
        if "||" in condition:
            parts = condition.split("||")
            return any(SimpleConditionEvaluator.evaluate(p.strip(), state) for p in parts)
        
        # 处理逻辑与：&&
        if "&&" in condition:
            parts = condition.split("&&")
            return all(SimpleConditionEvaluator.evaluate(p.strip(), state) for p in parts)
        
        # 处理比较运算符
        for op, func in [(">=", lambda a, b: a >= b), 
                         ("<=", lambda a, b: a <= b),
                         ("==", lambda a, b: a == b),
                         ("!=", lambda a, b: a != b)]:
            if op in condition:
                parts = condition.split(op)
                if len(parts) == 2:
                    left = SimpleConditionEvaluator._get_value(parts[0].strip(), state)
                    right = SimpleConditionEvaluator._get_value(parts[1].strip(), state)
                    return func(left, right)
        
        return False
    
    @staticmethod
    def _get_value(expr: str, state: FlowState):
        """从表达式或状态中获取值"""
        # 字符串字面量
        if expr.startswith('"') and expr.endswith('"'):
            return expr.strip('"')
        if expr.startswith("'") and expr.endswith("'"):
            return expr.strip("'")
        
        # 布尔值
        if expr == "true":
            return True
        if expr == "false":
            return False
        
        # 数字
        try:
            return float(expr)
        except ValueError:
            pass
        
        # 从状态中获取
        return state.get(expr)
```

### 4.4 方案三：使用第三方表达式库（推荐用于生产环境）

#### 4.4.1 推荐库

- **simpleeval**: 轻量级、安全的表达式评估库
- **asteval**: 基于 AST 的表达式评估库

#### 4.4.2 使用 simpleeval 示例

```python
from simpleeval import simple_eval, NameNotDefined

class SimpleEvalConditionEvaluator:
    """基于 simpleeval 的条件评估器"""
    
    @staticmethod
    def evaluate(condition: str, state: FlowState) -> bool:
        """评估条件表达式"""
        try:
            # 构建变量字典
            names = {
                'intent': state.get('intent'),
                'confidence': state.get('confidence'),
                'need_clarification': state.get('need_clarification'),
            }
            
            # 评估表达式
            result = simple_eval(condition, names=names)
            return bool(result)
        except NameNotDefined as e:
            logger.warning(f"条件表达式中使用了未定义的变量: {e.name}")
            return False
        except Exception as e:
            logger.error(f"条件表达式评估失败: {condition}, 错误: {e}")
            return False
```

**优点**：
- 实现简单，代码量少
- 安全性好（限制可用的函数和操作符）
- 性能较好
- 社区维护，稳定可靠

**缺点**：
- 需要引入第三方依赖

---

## 五、推荐实施方案

### 5.1 推荐方案

**推荐使用方案三（simpleeval）**，原因：
1. 实现简单，代码量少
2. 安全性好，适合生产环境
3. 性能满足需求
4. 维护成本低

### 5.2 实施步骤

1. **更新 requirements.txt**：
   ```
   simpleeval>=0.9.13
   ```

2. **扩展 FlowState**（`backend/domain/state.py`）：
   ```python
   class FlowState(TypedDict, total=False):
       # ... 现有字段 ...
       intent: Optional[str]
       confidence: Optional[float]  # 新增
       need_clarification: Optional[bool]  # 新增
   ```

3. **创建条件评估器**（`backend/domain/flows/condition_evaluator.py`）：
   - 使用 simpleeval 实现条件表达式评估

4. **更新意图识别节点**（`backend/domain/flows/builder.py`）：
   - 在解析意图识别结果时，同时提取 `confidence` 和 `need_clarification` 字段
   - 更新到 FlowState 中

5. **更新 builder.py**：
   - 替换 `_evaluate_condition` 方法，使用新的条件评估器

6. **测试验证**：
   - 编写测试用例，验证各种条件表达式的正确性
   - 测试边界情况和错误处理

### 5.3 注意事项

1. **状态字段初始化**：
   - 确保在意图识别节点执行后，正确设置 `confidence` 和 `need_clarification` 字段
   - 如果字段不存在，条件评估时应该返回合理的默认值

2. **向后兼容**：
   - 保持对简单条件（如 `intent == "xxx"`）的支持
   - 确保现有流程不受影响

3. **错误处理**：
   - 条件表达式解析失败时，应该记录日志并返回 `False`
   - 避免因条件解析错误导致整个流程崩溃

4. **性能考虑**：
   - 条件表达式会在每次路由时评估，确保评估性能满足需求
   - 对于复杂表达式，考虑缓存解析结果

---

## 六、总结

### 6.1 问题总结

当前代码的 `_evaluate_condition` 方法实现过于简化，无法支持：
- 逻辑运算符（`&&`、`||`）
- 数值比较运算符（`>=`、`<=`、`>`、`<`）
- 多个条件的组合
- 状态中缺失的字段（`confidence`、`need_clarification`）

### 6.2 影响范围

- **直接影响**：`intent_recognition` 节点后的路由完全失效
- **业务影响**：用户请求无法正确路由到对应的 Agent，导致功能不可用

### 6.3 升级优先级

**高优先级**：此问题导致核心路由功能失效，需要尽快修复。

### 6.4 后续优化建议

1. **条件表达式验证**：
   - 在流程加载时验证所有条件表达式的语法正确性
   - 检查条件中引用的状态字段是否存在

2. **条件表达式文档**：
   - 提供条件表达式的语法文档和示例
   - 说明支持的操作符和函数

3. **可视化支持**：
   - 在流程配置界面中可视化条件表达式
   - 提供条件表达式的编辑和验证工具

