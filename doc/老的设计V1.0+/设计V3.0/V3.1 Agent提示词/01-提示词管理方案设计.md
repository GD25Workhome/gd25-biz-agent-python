# Agent提示词管理方案设计

## 一、设计目标

### 1.1 核心目标
1. **统一管理**：所有提示词集中存储和管理，提供统一的加载接口
2. **模块化设计**：支持提示词模板化和模块化，每个Agent有自己的模板和子模块
3. **灵活加载**：支持从配置文件或数据库加载（当前版本实现配置文件，预留数据库扩展）
4. **热更新支持**：提示词修改后无需重启服务，支持版本管理和回滚
5. **解耦业务逻辑**：将动态提示词构建逻辑从业务代码中抽离

### 1.2 功能特性
- ✅ 模块化提示词模板系统
- ✅ 变量替换和模板继承
- ✅ 多数据源支持（配置文件/数据库）
- ✅ 热更新机制
- ✅ 版本管理和回滚
- ✅ 提示词验证和测试
- ✅ 插件化的提示词构建器

## 二、架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│              提示词管理模块 (PromptManager)              │
├─────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │ 模板加载器   │  │ 数据加载器   │  │ 模板渲染器   │ │
│  │TemplateLoader│  │DataLoader    │  │TemplateRender│ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │ 版本管理器   │  │ 缓存管理器   │  │ 验证器       │ │
│  │VersionManager│  │CacheManager │  │Validator     │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────┘
         │                    │                    │
         ▼                    ▼                    ▼
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│ 配置文件     │    │ 数据库       │    │ 业务代码     │
│ (YAML/JSON)  │    │ (预留扩展)   │    │ (Agent/Router)│
└──────────────┘    └──────────────┘    └──────────────┘
```

### 2.2 模块职责

| 模块 | 职责 |
|------|------|
| **PromptManager** | 提示词管理核心类，提供统一接口 |
| **TemplateLoader** | 加载提示词模板（从文件或数据库） |
| **DataLoader** | 加载模块数据（用户信息、参考文章、样本等） |
| **TemplateRender** | 渲染模板，支持变量替换和条件逻辑 |
| **VersionManager** | 管理提示词版本，支持回滚 |
| **CacheManager** | 缓存提示词，提高性能 |
| **Validator** | 验证提示词格式和内容 |

## 三、模块化设计

### 3.1 提示词模块结构

每个Agent的提示词由以下**必需模块**和**可选模块**组成：

#### 必需模块
1. **Agent职责 (Role)** - 定义Agent的角色和职责
2. **返回消息格式 (ResponseFormat)** - 定义返回消息的格式要求

#### 可选模块
3. **用户信息 (UserInfo)** - 用户相关信息（如user_id、用户偏好等）
4. **参考文章 (ReferenceArticles)** - RAG增强的参考文章（预留）
5. **回答样本 (FewShotExamples)** - Few-shot学习样本

#### 其他业务模块（根据Agent需求）
6. **功能说明 (FunctionDescription)** - Agent功能说明
7. **数据完整性检查 (DataValidation)** - 数据验证规则
8. **澄清机制 (Clarification)** - 澄清对话机制
9. **注意事项 (Notes)** - 业务注意事项

### 3.2 模板结构示例

```yaml
# config/prompts/templates/blood_pressure_agent.yaml
agent_key: blood_pressure_agent
version: 1.0.0
modules:
  # 必需模块：Agent职责
  role:
    type: required
    loader: config  # 或 database（预留）
    source: config/prompts/modules/blood_pressure/role.txt
    # 或 source: database://prompts/blood_pressure/role
    content: |
      你是一个专业的血压记录助手。你的职责是帮助用户记录、查询和管理血压数据。
  
  # 必需模块：返回消息格式
  response_format:
    type: required
    loader: config
    source: config/prompts/modules/blood_pressure/response_format.txt
    content: |
      返回消息格式要求：
      - 回答要简洁、专业、友好
      - 使用结构化的格式展示数据
      - 错误信息要清晰明确
  
  # 可选模块：用户信息
  user_info:
    type: optional
    loader: dynamic  # 运行时动态加载
    source: runtime  # 从运行时状态获取
    template: |
      系统提供的用户ID：{user_id}
      调用工具时直接使用该 user_id，无需向用户索取。
  
  # 可选模块：参考文章（预留，当前版本不实现）
  reference_articles:
    type: optional
    loader: database  # 预留：从数据库加载
    source: database://rag/articles/blood_pressure
    enabled: false  # 当前版本禁用
  
  # 可选模块：回答样本
  few_shot_examples:
    type: optional
    loader: config
    source: config/prompts/modules/blood_pressure/few_shot_examples.txt
    content: |
      示例对话1：
      用户：我想记录血压，收缩压120，舒张压80
      助手：好的，我已经为您记录了血压数据：收缩压120mmHg，舒张压80mmHg。
      
      示例对话2：
      用户：查询我的血压记录
      助手：以下是您最近的血压记录：
      [展示血压记录列表]
  
  # 业务模块：功能说明
  function_description:
    type: business
    loader: config
    source: config/prompts/modules/blood_pressure/function_description.txt
  
  # 业务模块：数据完整性检查
  data_validation:
    type: business
    loader: config
    source: config/prompts/modules/blood_pressure/data_validation.txt
  
  # 业务模块：澄清机制
  clarification:
    type: business
    loader: config
    source: config/prompts/modules/blood_pressure/clarification.txt
  
  # 业务模块：注意事项
  notes:
    type: business
    loader: config
    source: config/prompts/modules/blood_pressure/notes.txt

# 模板组合规则
composition:
  order:
    - role
    - function_description
    - data_validation
    - clarification
    - response_format
    - user_info  # 动态注入
    - few_shot_examples
    - notes
  separator: "\n\n"  # 模块之间的分隔符
```

### 3.3 模块文件结构

```
config/prompts/
├── templates/                          # 模板配置文件
│   ├── blood_pressure_agent.yaml
│   ├── appointment_agent.yaml
│   └── router_tools.yaml
├── modules/                            # 模块内容文件
│   ├── blood_pressure/
│   │   ├── role.txt
│   │   ├── response_format.txt
│   │   ├── function_description.txt
│   │   ├── data_validation.txt
│   │   ├── clarification.txt
│   │   ├── few_shot_examples.txt
│   │   └── notes.txt
│   ├── appointment/
│   │   ├── role.txt
│   │   ├── response_format.txt
│   │   └── ...
│   └── router/
│       ├── intent_identification.txt
│       └── clarify_intent.txt
└── shared/                             # 共享模块
    ├── common_response_format.txt
    └── common_notes.txt
```

## 四、数据加载方式

### 4.1 加载器类型

| 加载器类型 | 说明 | 当前版本 | 扩展性 |
|-----------|------|---------|--------|
| **config** | 从配置文件加载 | ✅ 实现 | ✅ |
| **file** | 从文件路径加载 | ✅ 实现 | ✅ |
| **dynamic** | 运行时动态构建 | ✅ 实现 | ✅ |
| **database** | 从数据库加载 | ❌ 预留接口 | ✅ 可扩展 |

### 4.2 加载器接口设计

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional

class DataLoader(ABC):
    """数据加载器基类"""
    
    @abstractmethod
    def load(self, source: str, context: Optional[Dict[str, Any]] = None) -> str:
        """
        加载数据
        
        Args:
            source: 数据源（文件路径、数据库URI等）
            context: 上下文信息（用于动态加载）
        
        Returns:
            加载的内容字符串
        """
        pass
    
    @abstractmethod
    def supports(self, source: str) -> bool:
        """检查是否支持该数据源"""
        pass


class ConfigLoader(DataLoader):
    """配置文件加载器"""
    
    def load(self, source: str, context: Optional[Dict[str, Any]] = None) -> str:
        # 从配置文件加载
        with open(source, "r", encoding="utf-8") as f:
            return f.read()
    
    def supports(self, source: str) -> bool:
        return source.startswith("config/") or source.endswith((".txt", ".yaml", ".json"))


class DatabaseLoader(DataLoader):
    """数据库加载器（预留扩展）"""
    
    def load(self, source: str, context: Optional[Dict[str, Any]] = None) -> str:
        # 从数据库加载（当前版本返回空，预留接口）
        # TODO: 实现数据库加载逻辑
        raise NotImplementedError("数据库加载器当前版本未实现")
    
    def supports(self, source: str) -> bool:
        return source.startswith("database://")


class DynamicLoader(DataLoader):
    """动态加载器（运行时构建）"""
    
    def load(self, source: str, context: Optional[Dict[str, Any]] = None) -> str:
        # 根据上下文动态构建内容
        if source == "runtime" and context:
            # 例如：构建用户信息模块
            user_id = context.get("user_id")
            if user_id:
                return f"系统提供的用户ID：{user_id}。"
        return ""
    
    def supports(self, source: str) -> bool:
        return source == "runtime"
```

### 4.3 加载器注册机制

```python
class LoaderRegistry:
    """加载器注册表"""
    
    _loaders: Dict[str, DataLoader] = {}
    
    @classmethod
    def register(cls, name: str, loader: DataLoader):
        """注册加载器"""
        cls._loaders[name] = loader
    
    @classmethod
    def get_loader(cls, source: str) -> Optional[DataLoader]:
        """根据数据源获取合适的加载器"""
        for loader in cls._loaders.values():
            if loader.supports(source):
                return loader
        return None
```

## 五、模板渲染系统

### 5.1 变量替换

支持以下变量替换方式：

```python
# 模板示例
template = """
{role}

{function_description}

用户信息：
{user_info}

{response_format}
"""

# 变量替换
variables = {
    "role": "你是一个专业的血压记录助手...",
    "function_description": "功能说明：...",
    "user_info": "系统提供的用户ID：user123",
    "response_format": "返回消息格式：..."
}

# 渲染结果
rendered = render_template(template, variables)
```

### 5.2 条件逻辑

支持根据条件选择不同的模块：

```yaml
# 模板配置
modules:
  user_info:
    type: optional
    loader: dynamic
    condition: "{user_id is not None}"  # 条件表达式
    template: "系统提供的用户ID：{user_id}"
```

### 5.3 模板继承

支持模板继承，减少重复：

```yaml
# 基础模板
base_template:
  modules:
    response_format:
      source: config/prompts/shared/common_response_format.txt

# 派生模板
blood_pressure_agent:
  extends: base_template
  modules:
    role:
      source: config/prompts/modules/blood_pressure/role.txt
```

## 六、核心类设计

### 6.1 PromptManager（提示词管理器）

```python
from typing import Dict, Any, Optional, List
from dataclasses import dataclass

@dataclass
class PromptModule:
    """提示词模块"""
    name: str
    type: str  # required, optional, business
    loader: str  # config, file, dynamic, database
    source: str
    content: Optional[str] = None
    enabled: bool = True
    condition: Optional[str] = None


@dataclass
class PromptTemplate:
    """提示词模板"""
    agent_key: str
    version: str
    modules: Dict[str, PromptModule]
    composition: Dict[str, Any]  # 组合规则


class PromptManager:
    """提示词管理器"""
    
    def __init__(self):
        self._templates: Dict[str, PromptTemplate] = {}
        self._cache: Dict[str, str] = {}
        self._version_manager = VersionManager()
        self._loader_registry = LoaderRegistry()
        self._validator = PromptValidator()
    
    def load_template(self, agent_key: str) -> PromptTemplate:
        """加载模板"""
        if agent_key in self._templates:
            return self._templates[agent_key]
        
        # 从配置文件加载
        template = self._load_template_from_config(agent_key)
        self._templates[agent_key] = template
        return template
    
    def render(
        self,
        agent_key: str,
        context: Optional[Dict[str, Any]] = None,
        include_modules: Optional[List[str]] = None,
        exclude_modules: Optional[List[str]] = None
    ) -> str:
        """
        渲染提示词
        
        Args:
            agent_key: Agent键名
            context: 上下文信息（用于动态模块）
            include_modules: 包含的模块列表（None表示全部）
            exclude_modules: 排除的模块列表
        
        Returns:
            渲染后的提示词
        """
        # 检查缓存
        cache_key = self._build_cache_key(agent_key, context, include_modules, exclude_modules)
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        # 加载模板
        template = self.load_template(agent_key)
        
        # 加载模块内容
        modules_content = {}
        for module_name, module in template.modules.items():
            # 检查是否包含/排除
            if include_modules and module_name not in include_modules:
                continue
            if exclude_modules and module_name in exclude_modules:
                continue
            
            # 检查条件
            if module.condition and not self._evaluate_condition(module.condition, context):
                continue
            
            # 加载模块内容
            content = self._load_module_content(module, context)
            if content:
                modules_content[module_name] = content
        
        # 组合模块
        prompt = self._compose_modules(template, modules_content)
        
        # 验证提示词
        self._validator.validate(prompt, agent_key)
        
        # 缓存结果
        self._cache[cache_key] = prompt
        
        return prompt
    
    def _load_module_content(
        self,
        module: PromptModule,
        context: Optional[Dict[str, Any]] = None
    ) -> str:
        """加载模块内容"""
        loader = self._loader_registry.get_loader(module.source)
        if not loader:
            raise ValueError(f"未找到支持 {module.source} 的加载器")
        
        return loader.load(module.source, context)
    
    def _compose_modules(
        self,
        template: PromptTemplate,
        modules_content: Dict[str, str]
    ) -> str:
        """组合模块"""
        order = template.composition.get("order", list(modules_content.keys()))
        separator = template.composition.get("separator", "\n\n")
        
        parts = []
        for module_name in order:
            if module_name in modules_content:
                parts.append(modules_content[module_name])
        
        return separator.join(parts)
    
    def reload_template(self, agent_key: str):
        """重新加载模板（热更新）"""
        if agent_key in self._templates:
            del self._templates[agent_key]
        # 清除相关缓存
        self._clear_cache(agent_key)
        # 重新加载
        self.load_template(agent_key)
    
    def get_version(self, agent_key: str) -> str:
        """获取模板版本"""
        template = self.load_template(agent_key)
        return template.version
```

### 6.2 TemplateLoader（模板加载器）

```python
import yaml
from pathlib import Path

class TemplateLoader:
    """模板加载器"""
    
    def __init__(self, templates_dir: str = "config/prompts/templates"):
        self.templates_dir = Path(templates_dir)
    
    def load(self, agent_key: str) -> PromptTemplate:
        """加载模板配置"""
        template_file = self.templates_dir / f"{agent_key}.yaml"
        
        if not template_file.exists():
            raise FileNotFoundError(f"模板文件不存在: {template_file}")
        
        with open(template_file, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)
        
        # 解析模块
        modules = {}
        for name, module_data in data.get("modules", {}).items():
            modules[name] = PromptModule(
                name=name,
                type=module_data.get("type", "business"),
                loader=module_data.get("loader", "config"),
                source=module_data.get("source", ""),
                enabled=module_data.get("enabled", True),
                condition=module_data.get("condition")
            )
        
        return PromptTemplate(
            agent_key=data["agent_key"],
            version=data.get("version", "1.0.0"),
            modules=modules,
            composition=data.get("composition", {})
        )
```

### 6.3 VersionManager（版本管理器）

```python
from typing import Dict, List
from datetime import datetime

class VersionManager:
    """版本管理器"""
    
    def __init__(self):
        self._versions: Dict[str, List[Dict[str, Any]]] = {}
    
    def save_version(self, agent_key: str, prompt: str, metadata: Dict[str, Any] = None):
        """保存版本"""
        if agent_key not in self._versions:
            self._versions[agent_key] = []
        
        version_info = {
            "version": len(self._versions[agent_key]) + 1,
            "prompt": prompt,
            "timestamp": datetime.now().isoformat(),
            "metadata": metadata or {}
        }
        
        self._versions[agent_key].append(version_info)
    
    def get_version(self, agent_key: str, version: int) -> Optional[str]:
        """获取指定版本"""
        if agent_key not in self._versions:
            return None
        
        versions = self._versions[agent_key]
        if 0 < version <= len(versions):
            return versions[version - 1]["prompt"]
        
        return None
    
    def rollback(self, agent_key: str, version: int) -> bool:
        """回滚到指定版本"""
        prompt = self.get_version(agent_key, version)
        if prompt:
            # 触发重新加载
            # TODO: 实现回滚逻辑
            return True
        return False
```

## 七、使用示例

### 7.1 Agent工厂集成

```python
# domain/agents/factory.py
from infrastructure.prompts.manager import PromptManager

class AgentFactory:
    _prompt_manager = PromptManager()
    
    @classmethod
    def create_agent(cls, agent_key: str, ...):
        # ... 其他代码 ...
        
        # 使用PromptManager获取提示词
        context = {
            "user_id": state.get("user_id") if state else None,
            "bp_form": state.get("bp_form") if state else None
        }
        
        system_prompt = cls._prompt_manager.render(
            agent_key=agent_key,
            context=context
        )
        
        return create_react_agent(
            model=llm,
            tools=tools,
            prompt=system_prompt
        )
```

### 7.2 路由工具集成

```python
# domain/router/tools/router_tools.py
from infrastructure.prompts.manager import PromptManager

_prompt_manager = PromptManager()

@tool
def identify_intent(messages: list[BaseMessage]) -> Dict[str, Any]:
    # 使用PromptManager获取意图识别提示词
    prompt_template = _prompt_manager.render(
        agent_key="router_intent_identification",
        context={
            "query": current_query,
            "history": history_text
        }
    )
    
    prompt = ChatPromptTemplate.from_messages([
        ("system", prompt_template),
        ("human", "用户消息: {query}\n\n对话历史: {history}")
    ])
    
    # ... 其他代码 ...
```

### 7.3 动态提示词注入

```python
# domain/router/graph.py
from infrastructure.prompts.manager import PromptManager

_prompt_manager = PromptManager()

def with_user_context(agent_node, agent_name: str):
    async def _run(state: RouterState) -> RouterState:
        messages = state.get("messages", [])
        user_id = state.get("user_id")
        
        # 使用PromptManager动态构建用户上下文提示
        context = {
            "user_id": user_id,
            "bp_form": state.get("bp_form") if agent_name == "blood_pressure_agent" else None
        }
        
        # 只渲染user_info模块
        user_info_prompt = _prompt_manager.render(
            agent_key=agent_name,
            context=context,
            include_modules=["user_info"]
        )
        
        if user_info_prompt:
            system_hint = SystemMessage(content=user_info_prompt)
            messages = [system_hint, *messages]
        
        # ... 其他代码 ...
```

## 八、迁移计划

### 8.1 第一阶段：基础框架搭建
1. ✅ 创建 `infrastructure/prompts/` 目录结构
2. ✅ 实现 `PromptManager` 核心类
3. ✅ 实现 `TemplateLoader` 和基础加载器
4. ✅ 实现模板渲染系统
5. ✅ 编写单元测试

### 8.2 第二阶段：模块化改造
1. ✅ 将现有提示词拆分为模块
2. ✅ 创建模板配置文件
3. ✅ 迁移 `blood_pressure_agent` 提示词
4. ✅ 迁移 `appointment_agent` 提示词
5. ✅ 迁移路由工具提示词

### 8.3 第三阶段：功能增强
1. ✅ 实现版本管理
2. ✅ 实现热更新机制
3. ✅ 实现缓存优化
4. ✅ 实现提示词验证

### 8.4 第四阶段：扩展支持（预留）
1. ⏳ 实现数据库加载器接口（当前版本不实现，但保留扩展性）
2. ⏳ 实现RAG参考文章模块（预留）
3. ⏳ 实现A/B测试支持
4. ⏳ 实现提示词效果分析

## 九、文件结构

```
infrastructure/
└── prompts/
    ├── __init__.py
    ├── manager.py              # PromptManager核心类
    ├── loader.py               # 模板加载器
    ├── data_loaders.py         # 数据加载器（ConfigLoader, DatabaseLoader等）
    ├── renderer.py             # 模板渲染器
    ├── version.py              # 版本管理器
    ├── cache.py                # 缓存管理器
    ├── validator.py            # 提示词验证器
    └── registry.py             # 加载器注册表

config/prompts/
├── templates/                  # 模板配置文件
│   ├── blood_pressure_agent.yaml
│   ├── appointment_agent.yaml
│   └── router_tools.yaml
├── modules/                    # 模块内容文件
│   ├── blood_pressure/
│   │   ├── role.txt
│   │   ├── response_format.txt
│   │   ├── function_description.txt
│   │   ├── data_validation.txt
│   │   ├── clarification.txt
│   │   ├── few_shot_examples.txt
│   │   └── notes.txt
│   ├── appointment/
│   │   └── ...
│   └── router/
│       ├── intent_identification.txt
│       └── clarify_intent.txt
└── shared/                     # 共享模块
    └── common_response_format.txt
```

## 十、优势总结

### 10.1 统一管理
- ✅ 所有提示词集中管理，易于查找和维护
- ✅ 统一的加载接口，使用简单

### 10.2 模块化设计
- ✅ 提示词模块化，易于复用和组合
- ✅ 必需模块和可选模块清晰分离
- ✅ 支持模块的条件加载

### 10.3 灵活扩展
- ✅ 支持多种数据加载方式（配置/数据库）
- ✅ 预留数据库扩展接口
- ✅ 支持插件化的加载器

### 10.4 热更新支持
- ✅ 提示词修改无需重启服务
- ✅ 支持版本管理和回滚
- ✅ 缓存机制提高性能

### 10.5 解耦业务逻辑
- ✅ 动态提示词构建逻辑从业务代码抽离
- ✅ 配置化的提示词构建规则
- ✅ 易于测试和维护

## 十一、后续扩展方向

### 11.1 数据库支持
- 实现 `DatabaseLoader`，支持从数据库加载提示词
- 支持提示词的在线编辑和管理
- 支持多环境配置（开发/测试/生产）

### 11.2 RAG增强
- 实现 `ReferenceArticles` 模块，从RAG系统加载参考文章
- 支持动态检索相关文章并注入到提示词

### 11.3 A/B测试
- 支持多版本提示词同时运行
- 支持效果对比和分析
- 支持自动选择最优版本

### 11.4 效果分析
- 记录提示词使用情况
- 分析提示词效果
- 提供优化建议
