# 工具参数设计方案

## 一、改造目标

### 1.1 核心目标

1. **移除 user_id 痕迹**：在整个系统中，将 `user_id` 字段全部替换为 `token_id`
2. **采纳方案二技术方案**：使用工具包装器 + contextvars 实现自动注入 tokenId
3. **提示词无 tokenId**：所有 Agent 的提示词中不包含 tokenId 相关信息，LLM 不需要传递 tokenId
4. **统一数据转换**：创建通用转换器，将 tokenId 转换为用户信息（当前阶段只返回 user_id）

### 1.2 设计原则

- **关注点分离**：技术参数（tokenId）由系统管理，业务参数由 LLM 管理
- **向后兼容**：当前阶段 tokenId = userId，未来可扩展为业务系统令牌
- **渐进式改造**：分阶段实施，确保每个阶段都可以独立测试和验证

## 二、改造范围

### 2.1 需要修改的文件清单

#### 前端相关
- `web/chat.html`：前端调用时，将 `user_id` 改为 `token_id`，但传入的值仍然是 `user_id`

#### API 层
- `app/schemas/chat.py`：`ChatRequest` 中的 `user_id` 字段改为 `token_id`
- `app/api/routes.py`：所有使用 `user_id` 的地方改为 `token_id`

#### 路由层
- `domain/router/state.py`：`RouterState` 中的 `user_id` 字段改为 `token_id`
- `domain/router/graph.py`：`with_user_context` 中所有 `user_id` 改为 `token_id`
- `infrastructure/prompts/placeholder.py`：占位符管理中的 `user_id` 改为 `token_id`

#### 工具层（核心改造）
- `domain/tools/context.py`：**新建**，实现 TokenContext 和 contextvars
- `domain/tools/wrapper.py`：**新建**，实现 TokenInjectedTool 工具包装器
- `domain/tools/utils/token_converter.py`：**新建**，实现 tokenId 到用户信息的转换
- `domain/tools/blood_pressure/record.py`：工具函数签名改为 `token_id`
- `domain/tools/blood_pressure/query.py`：工具函数签名改为 `token_id`
- `domain/tools/blood_pressure/update.py`：根据需求决定是否添加 `token_id`
- `domain/tools/health_event/record.py`：工具函数签名改为 `token_id`
- `domain/tools/health_event/query.py`：工具函数签名改为 `token_id`
- `domain/tools/health_event/update.py`：根据需求决定是否添加 `token_id`
- `domain/tools/medication/record.py`：工具函数签名改为 `token_id`
- `domain/tools/medication/query.py`：工具函数签名改为 `token_id`
- `domain/tools/medication/update.py`：根据需求决定是否添加 `token_id`
- `domain/tools/symptom/record.py`：工具函数签名改为 `token_id`
- `domain/tools/symptom/query.py`：工具函数签名改为 `token_id`
- `domain/tools/symptom/update.py`：根据需求决定是否添加 `token_id`

#### Agent 层
- `domain/agents/factory.py`：在工具创建时使用工具包装器

#### 提示词层
- `config/prompts/local/blood_pressure_agent_prompt.txt`：移除所有 `user_id` 相关占位符
- 其他 Agent 的提示词文件：移除所有 `user_id` 相关占位符

#### 日志和追踪
- `infrastructure/observability/langfuse_handler.py`：如果使用 `user_id`，需要改为 `token_id`
- 所有日志记录中的 `user_id` 改为 `token_id`

## 三、详细设计方案

### 3.1 前端调用改造

#### 3.1.1 改造内容

**文件**：`web/chat.html`

**改造前**：
```javascript
const request = {
    message: userMessage,
    session_id: sessionId,
    user_id: selectedUserId,  // 前端选择用户后传入
    conversation_history: history,
    user_info: userInfo,
    current_date: currentDate
};
```

**改造后**：
```javascript
const request = {
    message: userMessage,
    session_id: sessionId,
    token_id: selectedUserId,  // 字段名改为 token_id，但值仍然是 user_id
    conversation_history: history,
    user_info: userInfo,
    current_date: currentDate
};
```

**说明**：
- 前端字段名从 `user_id` 改为 `token_id`
- 传入的值仍然是用户选择的 `user_id`（当前阶段 tokenId = userId）
- 前端逻辑不需要改变，只是字段名改变

### 3.2 API 层改造

#### 3.2.1 ChatRequest 改造

**文件**：`app/schemas/chat.py`

**改造前**：
```python
class ChatRequest(BaseModel):
    message: str
    session_id: str
    user_id: str = Field(..., description="用户ID")
    conversation_history: Optional[List[ChatMessage]] = None
    user_info: Optional[str] = None
    current_date: Optional[str] = None
```

**改造后**：
```python
class ChatRequest(BaseModel):
    message: str
    session_id: str
    token_id: str = Field(..., description="令牌ID（当前阶段等于用户ID，未来可扩展为业务系统令牌）")
    conversation_history: Optional[List[ChatMessage]] = None
    user_info: Optional[str] = None
    current_date: Optional[str] = None
```

#### 3.2.2 API 路由改造

**文件**：`app/api/routes.py`

**改造点**：
1. 所有 `request.user_id` 改为 `request.token_id`
2. 构建 `initial_state` 时，使用 `token_id` 而不是 `user_id`
3. Langfuse 追踪中的 `user_id` 参数改为 `token_id`（如果 Langfuse 支持）

**改造示例**：
```python
# 改造前
initial_state: RouterState = {
    "user_id": request.user_id,
    ...
}

# 改造后
initial_state: RouterState = {
    "token_id": request.token_id,
    ...
}
```

### 3.3 路由层改造

#### 3.3.1 RouterState 改造

**文件**：`domain/router/state.py`

**改造前**：
```python
class RouterState(TypedDict, total=False):
    messages: List[BaseMessage]
    current_intent: Optional[str]
    current_agent: Optional[str]
    need_reroute: bool
    session_id: str
    user_id: str  # 需要移除
    trace_id: Optional[str]
    user_info: Optional[str]
    history_msg: Optional[str]
    current_date: Optional[str]
```

**改造后**：
```python
class RouterState(TypedDict, total=False):
    messages: List[BaseMessage]
    current_intent: Optional[str]
    current_agent: Optional[str]
    need_reroute: bool
    session_id: str
    token_id: str  # 替换 user_id
    trace_id: Optional[str]
    user_info: Optional[str]
    history_msg: Optional[str]
    current_date: Optional[str]
```

#### 3.3.2 with_user_context 改造

**文件**：`domain/router/graph.py`

**改造前**：
```python
async def _run(state: RouterState) -> RouterState:
    user_id = state.get("user_id")
    session_id = state.get("session_id")
    token_id = user_id  # 当前场景：token_id = user_id
    ...
```

**改造后**：
```python
async def _run(state: RouterState) -> RouterState:
    token_id = state.get("token_id")  # 直接从 state 获取 token_id
    session_id = state.get("session_id")
    
    # 设置 TokenContext
    with TokenContext(token_id=token_id):
        result = await agent_node.ainvoke({"messages": messages_with_context})
    ...
```

**关键改造点**：
1. 移除所有 `user_id` 相关的代码
2. 直接从 `state` 获取 `token_id`
3. 使用 `TokenContext` 设置上下文
4. 日志中的 `user_id` 改为 `token_id`

#### 3.3.3 占位符管理改造

**文件**：`infrastructure/prompts/placeholder.py`

**改造前**：
```python
class SimpleRouterState(TypedDict, total=False):
    user_id: str
    session_id: str
    ...

SYSTEM_PLACEHOLDERS = {
    "user_id": lambda state: state.get("user_id", ""),
    "session_id": lambda state: state.get("session_id", ""),
    ...
}
```

**改造后**：
```python
class SimpleRouterState(TypedDict, total=False):
    token_id: str  # 替换 user_id
    session_id: str
    ...

SYSTEM_PLACEHOLDERS = {
    # 移除 user_id 占位符（方案二不需要在提示词中注入 token_id）
    "session_id": lambda state: state.get("session_id", ""),
    ...
}
```

**说明**：
- 移除 `user_id` 占位符（方案二不需要在提示词中注入 token_id）
- 如果提示词中还有 `{{user_id}}`，需要移除或替换

### 3.4 工具层核心改造

#### 3.4.1 创建工具上下文管理器

**文件**：`domain/tools/context.py`（新建）

**实现代码**：
```python
"""
工具上下文管理器
使用 contextvars 实现线程安全的 tokenId 传递
"""
import contextvars
from typing import Optional

# 创建上下文变量
_token_id_context: contextvars.ContextVar[Optional[str]] = contextvars.ContextVar(
    'token_id', default=None
)


def set_token_id(token_id: str) -> None:
    """
    设置当前上下文的 tokenId
    
    Args:
        token_id: 令牌ID
    """
    _token_id_context.set(token_id)


def get_token_id() -> Optional[str]:
    """
    获取当前上下文的 tokenId
    
    Returns:
        令牌ID，如果未设置则返回 None
    """
    return _token_id_context.get()


class TokenContext:
    """
    工具上下文管理器（上下文管理器协议）
    
    使用示例：
        with TokenContext(token_id="xxx"):
            # 在此上下文中，工具可以获取 token_id
            tool.invoke(...)
    """
    
    def __init__(self, token_id: str):
        """
        初始化上下文管理器
        
        Args:
            token_id: 令牌ID
        """
        self.token_id = token_id
        self._token = None
    
    def __enter__(self):
        """进入上下文"""
        self._token = _token_id_context.set(self.token_id)
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文，恢复之前的上下文"""
        if self._token is not None:
            _token_id_context.reset(self._token)
        return False
```

#### 3.4.2 创建工具包装器

**文件**：`domain/tools/wrapper.py`（新建）

**实现代码**：
```python
"""
工具包装器：自动注入 tokenId
"""
from typing import Any, Dict, Optional
from langchain_core.tools import BaseTool
from langchain_core.callbacks import CallbackManagerForToolRun, AsyncCallbackManagerForToolRun

from domain.tools.context import get_token_id
import logging

logger = logging.getLogger(__name__)


class TokenInjectedTool(BaseTool):
    """
    工具包装器：在工具调用时自动注入 tokenId
    
    工作原理：
    1. 包装原始工具，保持所有属性和行为
    2. 在 invoke/ainvoke 时，从上下文获取 tokenId
    3. 自动将 tokenId 注入到工具参数中
    4. 调用原始工具函数
    """
    
    def __init__(
        self,
        tool: BaseTool,
        token_id_param_name: str = "token_id",
        require_token: bool = True
    ):
        """
        初始化工具包装器
        
        Args:
            tool: 原始工具实例
            token_id_param_name: tokenId 参数名称（默认为 "token_id"）
            require_token: 是否要求 tokenId 必须存在（默认 True）
        """
        self._original_tool = tool
        self._token_id_param_name = token_id_param_name
        self._require_token = require_token
        
        # 继承原始工具的所有属性
        super().__init__(
            name=tool.name,
            description=tool.description,
            args_schema=tool.args_schema,
        )
    
    @property
    def original_tool(self) -> BaseTool:
        """获取原始工具实例"""
        return self._original_tool
    
    def _inject_token_id(self, tool_input: Dict[str, Any]) -> Dict[str, Any]:
        """
        注入 tokenId 到工具参数中
        
        Args:
            tool_input: 工具输入参数字典
            
        Returns:
            注入 tokenId 后的参数字典
            
        Raises:
            ValueError: 如果 require_token=True 但 tokenId 不存在
        """
        # 从上下文获取 tokenId
        token_id = get_token_id()
        
        # 检查 tokenId 是否存在
        if token_id is None:
            if self._require_token:
                raise ValueError(
                    f"工具 {self.name} 需要 tokenId，但上下文中未设置。"
                    f"请确保在调用工具前使用 TokenContext 设置 tokenId。"
                )
            else:
                # 如果不需要 tokenId，直接返回原参数
                return tool_input
        
        # 检查参数中是否已经存在 token_id（避免重复注入）
        if self._token_id_param_name in tool_input:
            # 如果已存在，使用已有的值（LLM 可能已经传递）
            # 但记录警告，说明应该依赖自动注入
            logger.warning(
                f"工具 {self.name} 的参数中已存在 {self._token_id_param_name}，"
                f"将使用自动注入的值覆盖。"
            )
        
        # 注入 tokenId
        tool_input[self._token_id_param_name] = token_id
        
        return tool_input
    
    def _invoke(
        self,
        tool_input: Dict[str, Any],
        run_manager: Optional[CallbackManagerForToolRun] = None,
    ) -> Any:
        """
        同步调用工具（自动注入 tokenId）
        """
        # 注入 tokenId
        injected_input = self._inject_token_id(tool_input)
        
        # 调用原始工具
        return self._original_tool.invoke(injected_input, run_manager=run_manager)
    
    async def _ainvoke(
        self,
        tool_input: Dict[str, Any],
        run_manager: Optional[AsyncCallbackManagerForToolRun] = None,
    ) -> Any:
        """
        异步调用工具（自动注入 tokenId）
        """
        # 注入 tokenId
        injected_input = self._inject_token_id(tool_input)
        
        # 调用原始工具
        return await self._original_tool.ainvoke(injected_input, run_manager=run_manager)
    
    def __getattr__(self, name: str) -> Any:
        """
        代理原始工具的其他属性
        """
        return getattr(self._original_tool, name)


def wrap_tools_with_token_context(
    tools: list[BaseTool],
    token_id_param_name: str = "token_id",
    require_token: bool = True
) -> list[BaseTool]:
    """
    批量包装工具，使其支持自动注入 tokenId
    
    Args:
        tools: 原始工具列表
        token_id_param_name: tokenId 参数名称（默认为 "token_id"）
        require_token: 是否要求 tokenId 必须存在（默认 True）
        
    Returns:
        包装后的工具列表
    """
    wrapped_tools = []
    for tool in tools:
        # 检查工具是否已经是包装后的工具
        if isinstance(tool, TokenInjectedTool):
            # 如果已经是包装后的工具，直接使用
            wrapped_tools.append(tool)
        else:
            # 包装工具
            wrapped_tool = TokenInjectedTool(
                tool=tool,
                token_id_param_name=token_id_param_name,
                require_token=require_token
            )
            wrapped_tools.append(wrapped_tool)
    
    return wrapped_tools
```

#### 3.4.3 创建数据转换器

**文件**：`domain/tools/utils/token_converter.py`（新建）

**实现代码**：
```python
"""
TokenId 数据转换工具
将 tokenId 转换为用户信息
"""
from typing import Dict, Optional
from dataclasses import dataclass


@dataclass
class UserInfo:
    """
    用户信息数据类
    
    当前阶段：只包含 user_id
    未来阶段：可以扩展更多属性（如用户姓名、年龄、病史等）
    """
    user_id: str


def convert_token_to_user_info(token_id: str) -> UserInfo:
    """
    将 tokenId 转换为用户信息
    
    当前场景：直接返回 UserInfo(user_id=token_id)
    未来场景：通过 token_id 查询业务系统，获取完整的用户信息
    
    Args:
        token_id: 令牌ID
        
    Returns:
        UserInfo 对象，包含用户信息
        
    示例：
        # 当前阶段
        user_info = convert_token_to_user_info("user123")
        # user_info.user_id == "user123"
        
        # 未来阶段（示例）
        # user_info = convert_token_to_user_info("token_abc123")
        # user_info.user_id == "user123"  # 从业务系统获取
        # user_info.name == "张三"  # 从业务系统获取
        # user_info.age == 45  # 从业务系统获取
    """
    # 当前实现：直接返回 UserInfo(user_id=token_id)
    return UserInfo(user_id=token_id)
    
    # 未来实现示例：
    # from infrastructure.business_system.client import BusinessSystemClient
    # client = BusinessSystemClient()
    # user_data = client.get_user_by_token(token_id)
    # return UserInfo(
    #     user_id=user_data.user_id,
    #     name=user_data.name,
    #     age=user_data.age,
    #     # ... 更多属性
    # )


def convert_token_to_user_id(token_id: str) -> str:
    """
    将 tokenId 转换为 userId（便捷方法）
    
    Args:
        token_id: 令牌ID
        
    Returns:
        用户ID
    """
    user_info = convert_token_to_user_info(token_id)
    return user_info.user_id
```

#### 3.4.4 改造工具函数

**示例：血压记录工具**

**文件**：`domain/tools/blood_pressure/record.py`

**改造前**：
```python
@tool
async def record_blood_pressure(
    user_id: str,
    systolic: int,
    diastolic: int,
    heart_rate: Optional[int] = None,
    record_time: Optional[str] = None,
    notes: Optional[str] = None
) -> str:
    # 获取数据库会话
    session_factory = get_async_session_factory()
    async with session_factory() as session:
        repo = BloodPressureRepository(session)
        create_data = {
            "user_id": user_id,
            "systolic": systolic,
            ...
        }
        ...
```

**改造后**：
```python
@tool
async def record_blood_pressure(
    token_id: str,  # 自动注入的参数
    systolic: int,
    diastolic: int,
    heart_rate: Optional[int] = None,
    record_time: Optional[str] = None,
    notes: Optional[str] = None
) -> str:
    # 数据转换：将 tokenId 转换为用户信息
    from domain.tools.utils.token_converter import convert_token_to_user_info
    
    user_info = convert_token_to_user_info(token_id)
    user_id = user_info.user_id
    
    # 获取数据库会话
    session_factory = get_async_session_factory()
    async with session_factory() as session:
        repo = BloodPressureRepository(session)
        create_data = {
            "user_id": user_id,  # 使用转换后的 user_id
            "systolic": systolic,
            ...
        }
        ...
```

**所有工具函数都需要类似改造**：
- 将 `user_id: str` 参数改为 `token_id: str`
- 在函数开头添加数据转换逻辑
- 使用转换后的 `user_id` 进行后续操作

### 3.5 Agent 层改造

#### 3.5.1 AgentFactory 改造

**文件**：`domain/agents/factory.py`

**改造点**：在 `_create_agent_internal` 方法中，使用工具包装器包装工具

**改造前**：
```python
# 2. 获取工具列表
if not tools:
    tool_names = agent_config.get("tools", [])
    tools = [
        TOOL_REGISTRY[name]
        for name in tool_names
        if name in TOOL_REGISTRY
    ]
```

**改造后**：
```python
# 2. 获取工具列表
if not tools:
    tool_names = agent_config.get("tools", [])
    tools = [
        TOOL_REGISTRY[name]
        for name in tool_names
        if name in TOOL_REGISTRY
    ]

# 2.5. 包装工具，使其支持自动注入 tokenId
# 注意：这里只是包装工具，tokenId 将在运行时从上下文获取
from domain.tools.wrapper import wrap_tools_with_token_context
tools = wrap_tools_with_token_context(
    tools,
    token_id_param_name="token_id",
    require_token=True
)
```

### 3.6 提示词改造

#### 3.6.1 移除 user_id 占位符

**文件**：所有 Agent 的提示词文件

**改造前**：
```
用户ID: {{user_id}}
会话ID: {{session_id}}
当前日期: {{current_date}}
患者基础信息: {{user_info}}
历史回话信息: {{history_msg}}
```

**改造后**：
```
会话ID: {{session_id}}
当前日期: {{current_date}}
患者基础信息: {{user_info}}
历史回话信息: {{history_msg}}
```

**说明**：
- 移除 `用户ID: {{user_id}}` 这一行
- 提示词中不再提及 tokenId 或 user_id
- LLM 不需要知道 tokenId 的存在

## 四、开发计划

### 阶段一：核心基础设施（1-2 天）

**目标**：创建工具包装器和上下文管理器

**任务清单**：
1. ✅ 创建 `domain/tools/context.py` - **已完成**
   - ✅ 实现 `TokenContext` 类
   - ✅ 实现 `get_token_id()` 和 `set_token_id()` 函数
   - ✅ 编写单元测试（6个测试用例全部通过）

2. ✅ 创建 `domain/tools/wrapper.py` - **已完成**
   - ✅ 实现 `TokenInjectedTool` 类
   - ✅ 实现 `wrap_tools_with_token_context()` 函数
   - ✅ 编写单元测试（11个测试用例全部通过）

3. ✅ 创建 `domain/tools/utils/token_converter.py` - **已完成**
   - ✅ 实现 `UserInfo` 数据类
   - ✅ 实现 `convert_token_to_user_info()` 函数
   - ✅ 实现 `convert_token_to_user_id()` 便捷方法
   - ✅ 编写单元测试（7个测试用例全部通过）

**验收标准**：
- ✅ 所有新文件创建完成
- ✅ 单元测试通过（24个测试用例全部通过）
- ✅ 代码符合项目规范

### 阶段二：路由层改造（1 天）

**目标**：将 RouterState 和路由图执行中的 user_id 改为 token_id

**任务清单**：
1. ✅ 修改 `domain/router/state.py` - **已完成**
   - ✅ 将 `user_id: str` 改为 `token_id: str`
   - ✅ 更新类型定义

2. ✅ 修改 `domain/router/graph.py` - **已完成**
   - ✅ 移除所有 `user_id` 相关代码
   - ✅ 改为从 `state` 获取 `token_id`
   - ✅ 添加 `TokenContext` 的使用
   - ✅ 更新日志中的字段名

3. ✅ 修改 `infrastructure/prompts/placeholder.py` - **已完成**
   - ✅ 移除 `user_id` 占位符
   - ✅ 更新 `SimpleRouterState` 类型定义

**验收标准**：
- ✅ 所有 `user_id` 字段改为 `token_id`
- ✅ `with_user_context` 正确使用 `TokenContext`
- ✅ 代码编译通过

### 阶段三：API 层改造（0.5 天）

**目标**：将 API 层的 user_id 改为 token_id

**任务清单**：
1. ✅ 修改 `app/schemas/chat.py` - **已完成**
   - ✅ 将 `ChatRequest.user_id` 改为 `ChatRequest.token_id`
   - ✅ 更新字段描述

2. ✅ 修改 `app/api/routes.py` - **已完成**
   - ✅ 所有 `request.user_id` 改为 `request.token_id`
   - ✅ 构建 `initial_state` 时使用 `token_id`
   - ✅ 更新日志中的字段名
   - ✅ 检查 Langfuse 追踪是否需要修改（已更新为使用 token_id）

**验收标准**：
- ✅ API 接口参数改为 `token_id`
- ✅ 所有相关代码更新完成
- ⚠️ API 测试通过（需要实际测试验证）

### 阶段四：工具函数改造（2-3 天）

**目标**：将所有工具函数的 `user_id` 参数改为 `token_id`，并添加数据转换逻辑

**任务清单**：
1. ✅ 改造血压工具 - **已完成**
   - ✅ `domain/tools/blood_pressure/record.py` - 已改为 token_id，添加数据转换
   - ✅ `domain/tools/blood_pressure/query.py` - 已改为 token_id，添加数据转换
   - ✅ `domain/tools/blood_pressure/update.py` - 无需修改（使用 record_id，不涉及 user_id）

2. ✅ 改造健康事件工具 - **已完成**
   - ✅ `domain/tools/health_event/record.py` - 已改为 token_id，添加数据转换
   - ✅ `domain/tools/health_event/query.py` - 已改为 token_id，添加数据转换
   - ✅ `domain/tools/health_event/update.py` - 无需修改（使用 record_id，不涉及 user_id）

3. ✅ 改造用药工具 - **已完成**
   - ✅ `domain/tools/medication/record.py` - 已改为 token_id，添加数据转换
   - ✅ `domain/tools/medication/query.py` - 已改为 token_id，添加数据转换
   - ✅ `domain/tools/medication/update.py` - 无需修改（使用 record_id，不涉及 user_id）

4. ✅ 改造症状工具 - **已完成**
   - ✅ `domain/tools/symptom/record.py` - 已改为 token_id，添加数据转换
   - ✅ `domain/tools/symptom/query.py` - 已改为 token_id，添加数据转换
   - ✅ `domain/tools/symptom/update.py` - 无需修改（使用 record_id，不涉及 user_id）

5. ✅ 修改 `domain/agents/factory.py` - **已完成**
   - ✅ 在工具创建时使用工具包装器包装工具

**每个工具的改造步骤**：
1. 将函数签名中的 `user_id: str` 改为 `token_id: str`
2. 在函数开头添加数据转换逻辑
3. 使用转换后的 `user_id` 进行后续操作
4. 更新函数文档字符串

**验收标准**：
- 所有工具函数改造完成
- 工具函数测试通过
- 代码符合项目规范

### 阶段五：Agent 层改造（0.5 天）

**目标**：在 Agent 创建时使用工具包装器

**任务清单**：
1. ✅ 修改 `domain/agents/factory.py` - **已完成**
   - ✅ 在 `_create_agent_internal` 中添加工具包装逻辑
   - ✅ 导入 `wrap_tools_with_token_context` 函数

**验收标准**：
- ✅ Agent 创建时工具被正确包装
- ⚠️ Agent 功能测试通过（需要实际测试验证）

### 阶段六：提示词改造（0.5 天）

**目标**：移除所有提示词中的 user_id 占位符

**任务清单**：
1. ✅ 修改 `config/prompts/local/blood_pressure_agent_prompt.txt` - **已完成**
   - ✅ 移除 `用户ID: {{user_id}}` 行
   - ✅ 检查是否还有其他 user_id 相关描述

2. ✅ 修改其他 Agent 的提示词文件 - **已完成**
   - ✅ 检查所有提示词文件
   - ✅ 移除 user_id 相关占位符和描述
   - ✅ 已修改的文件：
     - `blood_pressure_agent_prompt.txt`
     - `medication_agent_prompt.txt`
     - `symptom_agent_prompt.txt`
     - `health_event_agent_prompt.txt`
     - `router_intent_identification_prompt.txt`
     - `router_clarify_intent_prompt.txt`
     - `safety_boundary_agent_prompt.txt`
   - ✅ 修改模板文件 `templates/blood_pressure_agent.yaml`（禁用 user_info 模块）

**验收标准**：
- ✅ 所有提示词中不包含 user_id 或 token_id
- ✅ 提示词格式正确

### 阶段七：前端改造（0.5 天）

**目标**：前端调用时使用 token_id 字段

**任务清单**：
1. ✅ 修改 `web/chat.html` - **已完成**
   - ✅ 将请求中的 `user_id` 字段改为 `token_id`
   - ✅ 传入的值仍然是 `user_id`（当前阶段 token_id = user_id）

**验收标准**：
- ✅ 前端可以正常调用 API（代码已更新）
- ⚠️ 前端功能测试通过（需要实际测试验证）

### 阶段八：集成测试和验证（1-2 天）

**目标**：完整的功能测试和回归测试

**任务清单**：
1. ✅ 单元测试 - **已完成**
   - ✅ 测试工具包装器（11个测试用例全部通过）
   - ✅ 测试数据转换器（7个测试用例全部通过）
   - ✅ 测试工具上下文管理器（6个测试用例全部通过）
   - ✅ 测试 TokenId 自动注入集成（5个测试用例全部通过）
   - ✅ 总计：29个测试用例全部通过

2. ✅ 集成测试 - **已完成**
   - ✅ 编写 TokenId 自动注入集成测试（5个测试用例全部通过）
   - ✅ 更新多轮会话集成测试（将 user_id 改为 token_id）
   - ⚠️ 完整的聊天流程测试（需要实际运行验证）

3. ⚠️ 回归测试 - **待验证**
   - ⚠️ 确保现有功能不受影响（需要实际测试验证）
   - ⚠️ 验证所有 Agent 正常工作（需要实际测试验证）

4. ✅ 文档更新 - **已完成**
   - ✅ 更新开发计划文档（标记任务完成情况）
   - ⚠️ 更新架构设计文档（需要根据实际情况更新）
   - ⚠️ 更新工具使用文档（需要根据实际情况更新）

**验收标准**：
- ✅ 所有单元测试通过（29个测试用例全部通过）
- ✅ 集成测试通过（5个测试用例全部通过）
- ⚠️ 功能正常（需要实际测试验证）
- ✅ 文档更新完成（开发计划文档已更新）

## 五、关键注意事项

### 5.1 数据兼容性

- **当前阶段**：`token_id = user_id`，直接使用用户ID作为令牌ID
- **未来扩展**：可以在数据转换器中实现业务系统调用，将 token_id 转换为 user_id

### 5.2 更新类工具的处理

更新类工具（如 `update_blood_pressure`）使用 `record_id` 而不是 `user_id`。

**处理方案**：
- **方案一**：不添加 `token_id`，保持现有设计
- **方案二**：添加 `token_id` 用于权限验证

**建议**：根据业务需求选择，如果不需要权限验证，使用方案一；如果需要权限验证，使用方案二。

### 5.3 日志和追踪

- 所有日志中的 `user_id` 改为 `token_id`
- Langfuse 追踪中的 `user_id` 参数可能需要改为 `token_id`（需要检查 Langfuse SDK 是否支持）

### 5.4 测试策略

- **单元测试**：每个新组件都要有单元测试
- **集成测试**：测试完整的调用链
- **回归测试**：确保现有功能不受影响

### 5.5 渐进式改造

- 每个阶段独立完成和测试
- 如果某个阶段有问题，可以回滚到上一个阶段
- 保持代码的可维护性

## 六、风险控制

### 6.1 潜在风险

1. **上下文丢失**：如果 contextvars 使用不当，可能导致 token_id 丢失
   - **缓解措施**：充分测试，确保上下文正确传递

2. **工具包装器性能**：工具包装可能带来性能开销
   - **缓解措施**：性能测试，如果成为问题可以优化

3. **向后兼容性**：改造可能影响现有功能
   - **缓解措施**：充分的回归测试

### 6.2 回滚方案

如果改造过程中出现问题，可以按阶段回滚：

1. **阶段一失败**：回滚新文件，保持原有逻辑
2. **阶段二-三失败**：回滚路由层和 API 层改动
3. **阶段四失败**：逐个回滚工具函数改动
4. **阶段五-七失败**：回滚对应层的改动

## 七、总结

### 7.1 改造核心

1. **移除 user_id 痕迹**：整个系统统一使用 `token_id`
2. **工具包装器**：自动注入 tokenId，LLM 不需要传递
3. **数据转换器**：将 tokenId 转换为用户信息（当前阶段只返回 user_id）
4. **提示词简化**：移除 tokenId 相关信息，LLM 只关注业务逻辑

### 7.2 实施原则

- **渐进式改造**：分阶段实施，每个阶段独立测试
- **向后兼容**：当前阶段 tokenId = userId，未来可扩展
- **关注点分离**：技术参数由系统管理，业务参数由 LLM 管理

### 7.3 预期效果

- **可靠性提升**：不依赖 LLM 传递 tokenId，减少出错可能
- **提示词简化**：提示词更简洁，只关注业务逻辑
- **可维护性提升**：tokenId 管理逻辑集中，便于维护和扩展

