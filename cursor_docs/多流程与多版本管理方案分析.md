# 多流程与多版本管理方案分析

## 文档说明

本文档分析当前架构中多流程、多版本管理的需求，评估LangGraph和其他框架的支持情况，并提供实现方案。

**文档版本**：V1.0  
**创建时间**：2025-01-XX

---

## 目录

1. [需求分析](#一需求分析)
2. [LangGraph支持情况](#二langgraph支持情况)
3. [其他框架对比](#三其他框架对比)
4. [实现方案](#四实现方案)
5. [推荐方案](#五推荐方案)

---

## 一、需求分析

### 1.1 当前架构现状

**当前实现**（`domain/router/graph.py`）：

```python:15:81:domain/router/graph.py
def create_router_graph(
    checkpointer: Optional[BaseCheckpointSaver] = None,
    pool: Optional[AsyncConnectionPool] = None,
    store: Optional[BaseStore] = None
):
    """
    创建路由图
    """
    # 创建状态图
    workflow = StateGraph(RouterState)
    
    # 添加路由节点
    workflow.add_node("route", route_node)
    
    # 添加智能体节点（动态添加）
    # 血压记录智能体
    blood_pressure_agent = AgentFactory.create_agent("blood_pressure_agent")
    workflow.add_node("blood_pressure_agent", blood_pressure_agent)
    
    # 复诊管理智能体
    appointment_agent = AgentFactory.create_agent("appointment_agent")
    workflow.add_node("appointment_agent", appointment_agent)
    
    # 设置入口点
    workflow.set_entry_point("route")
    
    # 添加条件边：从路由节点根据意图路由到智能体或结束
    def route_to_agent(state: RouterState) -> str:
        """根据当前意图路由到对应的智能体"""
        current_agent = state.get("current_agent")
        if current_agent == "blood_pressure_agent":
            return "blood_pressure_agent"
        elif current_agent == "appointment_agent":
            return "appointment_agent"
        else:
            return END
    
    workflow.add_conditional_edges(
        "route",
        route_to_agent,
        {
            "blood_pressure_agent": "blood_pressure_agent",
            "appointment_agent": "appointment_agent",
            END: END
        }
    )
    
    # 智能体执行后返回路由节点（支持多轮对话）
    workflow.add_edge("blood_pressure_agent", "route")
    workflow.add_edge("appointment_agent", "route")
    
    # 编译图
    graph_config = {}
    if checkpointer:
        graph_config["checkpointer"] = checkpointer
    if store:
        graph_config["store"] = store
    
    return workflow.compile(**graph_config)
```

**问题**：
- ❌ 只有一个固定的路由图（`router_graph`）
- ❌ 不支持多个独立的流程
- ❌ 不支持流程版本管理
- ❌ 无法同时运行不同版本的流程

### 1.2 实际业务需求

**场景1：多流程需求**
- 不同业务线需要不同的流程（如：医疗咨询流程、预约流程、诊断流程）
- 不同用户类型需要不同的流程（如：患者流程、医生流程、管理员流程）
- 不同渠道需要不同的流程（如：Web流程、移动端流程、API流程）

**场景2：多版本需求**
- 流程需要迭代升级（如：v1.0 → v2.0）
- 需要A/B测试不同版本的流程
- 需要灰度发布新版本
- 需要回滚到旧版本
- 需要同时支持多个版本（向后兼容）

**场景3：版本迁移需求**
- 正在执行的流程需要平滑迁移到新版本
- 状态数据需要兼容新旧版本
- 需要支持版本间的数据迁移

---

## 二、LangGraph支持情况

### 2.1 LangGraph原生支持

**✅ 支持的特性**：

1. **状态管理**：
   - 使用 `Checkpointer` 持久化状态
   - 支持状态恢复和版本兼容

2. **动态路由**：
   - 条件边支持动态路由
   - 可以根据状态选择不同的执行路径

3. **多智能体协调**：
   - 支持多个Agent节点
   - 支持Supervisor模式

**❌ 不支持的特性**：

1. **多流程管理**：
   - ❌ 没有内置的多流程注册机制
   - ❌ 没有流程选择器（Workflow Selector）
   - ❌ 需要自己实现流程注册和路由

2. **版本管理**：
   - ❌ 没有内置的版本管理机制
   - ❌ 没有版本切换API
   - ❌ 没有状态迁移工具
   - ❌ 需要自己实现版本管理

3. **流程隔离**：
   - ❌ 不同流程共享同一个Checkpointer
   - ❌ 需要自己实现流程隔离（通过thread_id前缀等）

### 2.2 LangGraph实现多流程/多版本的方式

**方式1：手动管理多个图实例**

```python
# 创建多个图实例
router_graph_v1 = create_router_graph_v1(...)
router_graph_v2 = create_router_graph_v2(...)
medical_flow = create_medical_flow(...)
appointment_flow = create_appointment_flow(...)

# 手动选择使用哪个图
if request.flow_type == "medical":
    graph = medical_flow
elif request.flow_type == "appointment":
    graph = appointment_flow
else:
    graph = router_graph_v1
```

**优点**：简单直接  
**缺点**：需要手动管理，容易出错，不支持动态切换

**方式2：使用配置驱动的流程工厂**

```python
class FlowFactory:
    """流程工厂"""
    
    _flows: Dict[str, CompiledGraph] = {}
    
    @classmethod
    def create_flow(cls, flow_name: str, version: str = "latest"):
        """创建流程"""
        key = f"{flow_name}:{version}"
        if key not in cls._flows:
            cls._flows[key] = cls._build_flow(flow_name, version)
        return cls._flows[key]
```

**优点**：统一管理，支持版本  
**缺点**：需要自己实现，功能有限

**方式3：使用GraphVersionManager（参考热部署文档）**

```python:403:448:cursor_docs/LangGraph热部署技术方案.md
class GraphVersionManager:
    """图版本管理器"""
    
    def __init__(self):
        self.graph_versions: Dict[str, CompiledGraph] = {}
        self.current_version: str = "v1.0"
        self.version_config: Dict[str, dict] = {}
    
    def register_version(self, version: str, graph: CompiledGraph, config: dict):
        """注册图版本"""
        self.graph_versions[version] = graph
        self.version_config[version] = config
        print(f"✅ 图版本已注册: {version}")
    
    def switch_version(self, version: str):
        """切换图版本"""
        if version not in self.graph_versions:
            raise ValueError(f"图版本不存在: {version}")
        
        self.current_version = version
        print(f"✅ 已切换到图版本: {version}")
    
    def get_current_graph(self) -> CompiledGraph:
        """获取当前版本的图"""
        return self.graph_versions[self.current_version]
    
    def migrate_state(self, old_version: str, new_version: str, state: dict) -> dict:
        """迁移状态到新版本"""
        # 实现状态迁移逻辑
        # 确保新旧版本的状态兼容
        return state
```

**优点**：支持版本管理，可以切换版本  
**缺点**：需要自己实现，功能不完整

---

## 三、其他框架对比

### 3.1 Temporal

**简介**：Temporal是一个工作流编排框架，专注于长时间运行的工作流。

**多流程支持**：
- ✅ 支持多个Workflow定义
- ✅ 每个Workflow可以独立运行
- ✅ 支持Workflow选择器

**多版本支持**：
- ✅ **Worker Versioning**：官方支持多版本工作流
- ✅ 可以同时运行多个版本的Worker
- ✅ 支持版本切换和回滚
- ✅ 支持状态迁移

**示例代码**：

```python
# Temporal Worker Versioning
from temporalio import workflow

@workflow.defn
class MyWorkflowV1:
    @workflow.run
    async def run(self, input: str) -> str:
        # V1 逻辑
        return f"V1: {input}"

@workflow.defn
class MyWorkflowV2:
    @workflow.run
    async def run(self, input: str) -> str:
        # V2 逻辑
        return f"V2: {input}"

# 配置Worker版本
worker_config = WorkerConfig(
    task_queue="my-task-queue",
    workflows=[MyWorkflowV1, MyWorkflowV2],
    # 指定Worker版本
    build_id="v2.0",
    use_worker_versioning=True,
)
```

**优点**：
- ✅ 官方支持多版本
- ✅ 成熟的生产级框架
- ✅ 完善的版本管理机制
- ✅ 支持状态迁移

**缺点**：
- ❌ 需要额外的Temporal Server
- ❌ 学习曲线较陡
- ❌ 不是专门为LLM Agent设计的

### 3.2 Prefect

**简介**：Prefect是一个现代的工作流编排框架。

**多流程支持**：
- ✅ 支持多个Flow定义
- ✅ 每个Flow可以独立运行
- ✅ 支持Flow注册和发现

**多版本支持**：
- ⚠️ 通过不同的Worker/Environment支持多版本
- ⚠️ 需要手动管理版本
- ⚠️ 没有官方的版本管理机制

**示例代码**：

```python
from prefect import flow

@flow(name="my-flow-v1")
def my_flow_v1(input: str):
    # V1 逻辑
    return f"V1: {input}"

@flow(name="my-flow-v2")
def my_flow_v2(input: str):
    # V2 逻辑
    return f"V2: {input}"

# 使用不同的Worker运行不同版本
# Worker 1: 运行 v1
# Worker 2: 运行 v2
```

**优点**：
- ✅ 易于使用
- ✅ 支持多种部署方式
- ✅ 良好的监控和日志

**缺点**：
- ❌ 多版本支持较弱
- ❌ 不是专门为LLM Agent设计的

### 3.3 AgentGit

**简介**：AgentGit为多智能体系统提供Git-like的版本控制。

**多流程支持**：
- ✅ 支持多个工作流分支
- ✅ 支持工作流比较和探索

**多版本支持**：
- ✅ Git-like的版本控制
- ✅ 支持状态提交、回滚、分支
- ✅ 支持多轨迹探索

**优点**：
- ✅ 专门为多智能体系统设计
- ✅ Git-like的版本控制模型
- ✅ 支持多轨迹探索

**缺点**：
- ❌ 相对较新的框架
- ❌ 社区和文档可能不够完善
- ❌ 需要集成到现有系统

### 3.4 对比总结

| 框架 | 多流程支持 | 多版本支持 | LLM Agent专用 | 成熟度 | 学习曲线 |
|------|-----------|-----------|--------------|--------|---------|
| **LangGraph** | ❌ 需自己实现 | ❌ 需自己实现 | ✅ 是 | ⭐⭐⭐ | 低 |
| **Temporal** | ✅ 原生支持 | ✅ Worker Versioning | ❌ 否 | ⭐⭐⭐⭐⭐ | 中 |
| **Prefect** | ✅ 原生支持 | ⚠️ 需手动管理 | ❌ 否 | ⭐⭐⭐⭐ | 低 |
| **AgentGit** | ✅ 支持 | ✅ Git-like | ✅ 是 | ⭐⭐ | 中 |

---

## 四、实现方案

### 4.1 方案一：基于LangGraph的自定义实现（推荐）

**适用场景**：继续使用LangGraph，需要多流程/多版本支持

#### 4.1.1 架构设计

```
┌─────────────────────────────────────────┐
│         FlowRegistry                     │
│  ┌───────────────────────────────────┐  │
│  │  FlowFactory                      │  │
│  │  - create_flow(name, version)     │  │
│  │  - register_flow(name, version)   │  │
│  └──────────────┬────────────────────┘  │
│                 │                        │
│  ┌──────────────▼────────────────────┐  │
│  │  FlowVersionManager                │  │
│  │  - switch_version()                 │  │
│  │  - migrate_state()                 │  │
│  │  - get_flow()                      │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

#### 4.1.2 实现代码

```python
"""
多流程与多版本管理实现
"""
from typing import Dict, Optional, List
from langgraph.graph import CompiledGraph
from langgraph.checkpoint.base import BaseCheckpointSaver
from domain.router.graph import create_router_graph


class FlowVersionManager:
    """流程版本管理器"""
    
    def __init__(self):
        # 存储所有流程版本: {flow_name: {version: CompiledGraph}}
        self.flows: Dict[str, Dict[str, CompiledGraph]] = {}
        # 当前活跃版本: {flow_name: version}
        self.current_versions: Dict[str, str] = {}
        # 流程配置: {flow_name: {version: config}}
        self.flow_configs: Dict[str, Dict[str, dict]] = {}
    
    def register_flow(
        self,
        flow_name: str,
        version: str,
        graph: CompiledGraph,
        config: Optional[dict] = None,
        set_as_current: bool = False
    ):
        """
        注册流程版本
        
        Args:
            flow_name: 流程名称（如：router, medical, appointment）
            version: 版本号（如：v1.0, v2.0, latest）
            graph: 编译后的图
            config: 流程配置（可选）
            set_as_current: 是否设置为当前版本
        """
        if flow_name not in self.flows:
            self.flows[flow_name] = {}
            self.flow_configs[flow_name] = {}
        
        self.flows[flow_name][version] = graph
        if config:
            self.flow_configs[flow_name][version] = config
        
        if set_as_current or flow_name not in self.current_versions:
            self.current_versions[flow_name] = version
        
        print(f"✅ 流程已注册: {flow_name}:{version}")
    
    def get_flow(
        self,
        flow_name: str,
        version: Optional[str] = None
    ) -> CompiledGraph:
        """
        获取流程
        
        Args:
            flow_name: 流程名称
            version: 版本号（可选，默认使用当前版本）
        
        Returns:
            CompiledGraph: 编译后的图
        """
        if flow_name not in self.flows:
            raise ValueError(f"流程不存在: {flow_name}")
        
        if version is None:
            version = self.current_versions.get(flow_name)
            if version is None:
                raise ValueError(f"流程 {flow_name} 没有设置当前版本")
        
        if version not in self.flows[flow_name]:
            raise ValueError(f"流程版本不存在: {flow_name}:{version}")
        
        return self.flows[flow_name][version]
    
    def switch_version(self, flow_name: str, version: str):
        """
        切换流程版本
        
        Args:
            flow_name: 流程名称
            version: 新版本号
        """
        if flow_name not in self.flows:
            raise ValueError(f"流程不存在: {flow_name}")
        
        if version not in self.flows[flow_name]:
            raise ValueError(f"流程版本不存在: {flow_name}:{version}")
        
        self.current_versions[flow_name] = version
        print(f"✅ 已切换流程版本: {flow_name} -> {version}")
    
    def list_flows(self) -> List[str]:
        """列出所有流程名称"""
        return list(self.flows.keys())
    
    def list_versions(self, flow_name: str) -> List[str]:
        """列出流程的所有版本"""
        if flow_name not in self.flows:
            return []
        return list(self.flows[flow_name].keys())
    
    def get_current_version(self, flow_name: str) -> Optional[str]:
        """获取流程的当前版本"""
        return self.current_versions.get(flow_name)
    
    def migrate_state(
        self,
        flow_name: str,
        old_version: str,
        new_version: str,
        state: dict
    ) -> dict:
        """
        迁移状态到新版本
        
        Args:
            flow_name: 流程名称
            old_version: 旧版本
            new_version: 新版本
            state: 旧版本的状态
        
        Returns:
            dict: 新版本的状态
        """
        # 获取迁移函数（如果存在）
        migration_key = f"{flow_name}:{old_version}:{new_version}"
        migration_func = getattr(self, f"_migrate_{migration_key}", None)
        
        if migration_func:
            return migration_func(state)
        
        # 默认：直接返回（假设状态兼容）
        # 实际使用时需要实现具体的迁移逻辑
        return state


class FlowFactory:
    """流程工厂"""
    
    def __init__(self, version_manager: FlowVersionManager):
        self.version_manager = version_manager
    
    def create_router_flow_v1(
        self,
        checkpointer: Optional[BaseCheckpointSaver] = None,
        pool: Optional = None,
        store: Optional = None
    ):
        """创建路由流程 V1.0"""
        graph = create_router_graph(
            checkpointer=checkpointer,
            pool=pool,
            store=store
        )
        
        self.version_manager.register_flow(
            flow_name="router",
            version="v1.0",
            graph=graph,
            config={
                "description": "初始路由流程",
                "agents": ["blood_pressure_agent", "appointment_agent"]
            },
            set_as_current=True
        )
        
        return graph
    
    def create_router_flow_v2(
        self,
        checkpointer: Optional[BaseCheckpointSaver] = None,
        pool: Optional = None,
        store: Optional = None
    ):
        """创建路由流程 V2.0（示例：添加新功能）"""
        # 这里可以创建不同版本的图
        # 例如：添加新的Agent节点、修改路由逻辑等
        graph = create_router_graph_v2(
            checkpointer=checkpointer,
            pool=pool,
            store=store
        )
        
        self.version_manager.register_flow(
            flow_name="router",
            version="v2.0",
            graph=graph,
            config={
                "description": "增强版路由流程",
                "agents": ["blood_pressure_agent", "appointment_agent", "diagnosis_agent"]
            },
            set_as_current=False  # 不自动切换
        )
        
        return graph


# 全局流程版本管理器
flow_version_manager = FlowVersionManager()
flow_factory = FlowFactory(flow_version_manager)
```

#### 4.1.3 API集成

```python
"""
在 app/api/routes.py 中集成多流程支持
"""
from fastapi import APIRouter, HTTPException, Request
from app.schemas.chat import ChatRequest, ChatResponse
from cursor_docs.flow_manager import flow_version_manager

router = APIRouter()

@router.post("/chat", response_model=ChatResponse)
async def chat(
    request: ChatRequest,
    app_request: Request
) -> ChatResponse:
    """
    聊天接口（支持多流程）
    """
    # 从请求中获取流程名称和版本（可选）
    flow_name = request.flow_name or "router"  # 默认使用router流程
    flow_version = request.flow_version  # 可选，默认使用当前版本
    
    # 获取对应的流程图
    try:
        graph = flow_version_manager.get_flow(flow_name, flow_version)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))
    
    # 构建初始状态
    initial_state = {
        "messages": messages,
        "current_intent": None,
        "current_agent": None,
        "need_reroute": True,
        "session_id": request.session_id,
        "user_id": request.user_id
    }
    
    # 执行流程图
    config = {
        "configurable": {
            "thread_id": f"{flow_name}:{request.session_id}"  # 添加流程前缀
        }
    }
    
    # ... 执行图并返回结果 ...


@router.post("/admin/flows/{flow_name}/switch")
async def switch_flow_version(
    flow_name: str,
    version: str
):
    """
    切换流程版本（管理员接口）
    """
    try:
        flow_version_manager.switch_version(flow_name, version)
        return {"status": "ok", "flow": flow_name, "version": version}
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@router.get("/admin/flows")
async def list_flows():
    """
    列出所有流程和版本
    """
    flows_info = {}
    for flow_name in flow_version_manager.list_flows():
        flows_info[flow_name] = {
            "versions": flow_version_manager.list_versions(flow_name),
            "current_version": flow_version_manager.get_current_version(flow_name)
        }
    return flows_info
```

#### 4.1.4 应用启动集成

```python
"""
在 app/main.py 中初始化多流程
"""
from cursor_docs.flow_manager import flow_version_manager, flow_factory

@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    # Startup
    print("正在启动应用...")
    
    # ... 初始化数据库、Checkpointer等 ...
    
    # 创建多个流程版本
    # V1.0
    flow_factory.create_router_flow_v1(
        checkpointer=checkpointer,
        pool=db_pool,
        store=store
    )
    
    # V2.0（可选，用于测试）
    # flow_factory.create_router_flow_v2(
    #     checkpointer=checkpointer,
    #     pool=db_pool,
    #     store=store
    # )
    
    # 存储到 app.state
    app.state.flow_version_manager = flow_version_manager
    
    print("应用启动完成")
    
    yield
    
    # Shutdown
    print("正在关闭应用...")
    # ... 清理资源 ...
```

### 4.2 方案二：迁移到Temporal（长期方案）

**适用场景**：需要企业级的多版本支持，愿意引入Temporal

**优点**：
- ✅ 官方支持Worker Versioning
- ✅ 成熟的生产级框架
- ✅ 完善的版本管理机制

**缺点**：
- ❌ 需要额外的Temporal Server
- ❌ 需要重构现有代码
- ❌ 学习曲线较陡

**实施步骤**：
1. 搭建Temporal Server
2. 将LangGraph流程转换为Temporal Workflow
3. 配置Worker Versioning
4. 实现状态迁移逻辑

### 4.3 方案三：混合方案

**适用场景**：短期使用LangGraph，长期考虑迁移

**策略**：
1. **短期**：使用方案一（自定义实现）
2. **中期**：完善版本管理功能
3. **长期**：评估是否需要迁移到Temporal

---

## 五、推荐方案

### 5.1 推荐：方案一（基于LangGraph的自定义实现）

**理由**：
1. ✅ **保持现有架构**：不需要重构，继续使用LangGraph
2. ✅ **满足基本需求**：可以支持多流程和多版本
3. ✅ **易于实现**：基于现有代码扩展
4. ✅ **灵活可控**：可以根据需求定制功能

**实施优先级**：
1. **Phase 1**：实现基础的FlowVersionManager
2. **Phase 2**：集成到API，支持流程选择
3. **Phase 3**：实现状态迁移机制
4. **Phase 4**：添加管理接口（切换版本、查看版本等）

### 5.2 实施建议

**1. 流程命名规范**：
```
router:v1.0          # 路由流程 v1.0
router:v2.0          # 路由流程 v2.0
medical:v1.0         # 医疗咨询流程 v1.0
appointment:v1.0      # 预约流程 v1.0
```

**2. 版本管理策略**：
- 使用语义化版本号（如：v1.0, v1.1, v2.0）
- 维护版本兼容性矩阵
- 提供版本迁移指南

**3. 状态隔离**：
- 使用 `thread_id` 前缀区分不同流程
- 格式：`{flow_name}:{session_id}`
- 确保不同流程的状态不会冲突

**4. 监控和日志**：
- 记录流程版本使用情况
- 监控版本切换事件
- 记录状态迁移操作

### 5.3 注意事项

1. **状态兼容性**：
   - 确保新旧版本的状态结构兼容
   - 提供状态迁移函数
   - 测试迁移逻辑

2. **性能考虑**：
   - 流程图实例可以缓存
   - 避免频繁创建和销毁
   - 考虑内存占用

3. **安全性**：
   - 版本切换接口需要权限控制
   - 防止未授权的版本切换
   - 记录所有管理操作

4. **测试**：
   - 测试多流程切换
   - 测试版本迁移
   - 测试状态兼容性

---

## 六、总结

### 6.1 结论

1. **LangGraph本身不支持多流程/多版本管理**，需要自己实现
2. **其他框架（如Temporal）有更好的支持**，但需要引入额外依赖
3. **推荐使用自定义实现**，基于LangGraph扩展，满足基本需求

### 6.2 实施路径

1. **短期**（1-2周）：
   - 实现 `FlowVersionManager`
   - 集成到现有API
   - 支持基础的流程选择

2. **中期**（1-2月）：
   - 完善版本管理功能
   - 实现状态迁移机制
   - 添加管理接口

3. **长期**（3-6月）：
   - 评估是否需要迁移到Temporal
   - 根据业务需求优化架构

---

**文档版本**：V1.0  
**创建时间**：2025-01-XX  
**维护者**：开发团队
