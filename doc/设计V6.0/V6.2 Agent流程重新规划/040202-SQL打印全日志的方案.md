# SQL打印全日志的方案（安全方案）

## 一、方案概述

### 1.1 目标

在SQL日志中输出实际执行的完整SQL语句（参数替换后的SQL），而不使用代码层面的字符串替换方式，确保安全性和准确性。

### 1.2 核心原则

**重要原则**：
- ❌ **不使用代码层面的字符串替换**：避免手动替换SQL中的占位符，这种方式不安全且容易出错
- ✅ **优先使用数据库原生支持**：使用数据库服务器或驱动提供的原生功能
- ✅ **确保安全性**：所有方案必须保证不会引入SQL注入风险

### 1.3 当前限制

**SQLAlchemy和数据库驱动的限制**：
- SQLAlchemy的事件监听器只能获取到**带占位符的SQL**和**参数**，无法直接获取实际执行的SQL
- psycopg3驱动在执行参数化查询时，参数替换是在数据库服务器端完成的，驱动层面无法获取替换后的SQL
- 这是**安全设计**：防止SQL注入攻击，参数化查询的参数不会与SQL语句拼接

---

## 二、可行方案分析

### 2.1 方案1：PostgreSQL数据库服务器日志（推荐）

#### 2.1.1 方案说明

使用PostgreSQL数据库服务器的日志功能，在数据库层面记录实际执行的SQL语句。

#### 2.1.2 实现方式

**配置PostgreSQL的`postgresql.conf`**：

```conf
# 记录所有SQL语句（包括参数替换后的完整SQL）
log_statement = 'all'  # 可选值：none, ddl, mod, all

# 记录SQL执行时间
log_duration = on

# 记录慢查询（超过指定时间的查询）
log_min_duration_statement = 1000  # 单位：毫秒，0表示记录所有查询

# 日志格式
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '

# 日志输出位置
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_rotation_age = 1d
log_rotation_size = 100MB
```

#### 2.1.3 优点

- ✅ **完全安全**：由数据库服务器记录，不涉及应用代码
- ✅ **准确可靠**：记录的是数据库实际执行的SQL
- ✅ **功能完整**：可以记录所有SQL语句、执行时间、慢查询等
- ✅ **不影响应用性能**：日志记录在数据库服务器端，不影响应用性能

#### 2.1.4 缺点

- ⚠️ **需要数据库服务器配置**：需要修改PostgreSQL配置文件
- ⚠️ **日志文件管理**：需要管理数据库服务器的日志文件
- ⚠️ **日志格式固定**：PostgreSQL的日志格式相对固定，不易自定义
- ⚠️ **需要访问数据库服务器**：应用无法直接读取数据库日志

#### 2.1.5 适用场景

- 生产环境：需要完整的SQL审计日志
- 调试环境：需要查看数据库实际执行的SQL
- 性能分析：需要分析慢查询和SQL执行模式

### 2.2 方案2：PostgreSQL pg_stat_statements扩展

#### 2.2.1 方案说明

使用PostgreSQL的`pg_stat_statements`扩展，记录SQL执行统计信息，包括实际执行的SQL语句。

#### 2.2.2 实现方式

**1. 启用扩展**：

```sql
-- 创建扩展
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- 配置参数（在postgresql.conf中）
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.track = 'all'  # 跟踪所有SQL
pg_stat_statements.max = 10000    # 最多记录10000条SQL
```

**2. 查询统计信息**：

```sql
-- 查看实际执行的SQL语句
SELECT 
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 100;
```

#### 2.2.3 优点

- ✅ **记录实际SQL**：`query`字段包含参数替换后的实际SQL
- ✅ **性能统计**：提供详细的执行统计信息
- ✅ **不影响应用**：扩展在数据库服务器端运行

#### 2.2.4 缺点

- ⚠️ **不是实时日志**：是统计信息，不是实时日志
- ⚠️ **需要查询数据库**：需要通过SQL查询获取信息
- ⚠️ **需要数据库权限**：需要访问`pg_stat_statements`视图的权限
- ⚠️ **数据会累积**：需要定期清理或重置统计信息

#### 2.2.5 适用场景

- 性能分析：分析SQL执行模式和性能瓶颈
- SQL审计：查看实际执行的SQL语句
- 慢查询分析：识别执行时间较长的SQL

### 2.3 方案3：使用SQLAlchemy的compile()方法（有限支持）

#### 2.3.1 方案说明

在事件监听器中，尝试使用SQLAlchemy的`compile()`方法获取完整SQL，但**仅适用于部分场景**。

#### 2.3.2 实现方式

```python
@event.listens_for(engine.sync_engine, "after_cursor_execute")
def receive_after_cursor_execute(conn, cursor, statement, parameters, context, executemany):
    """SQL执行后事件监听器"""
    # 尝试从context中获取SQLAlchemy语句对象
    if context and hasattr(context, 'statement'):
        try:
            # 使用compile方法获取完整SQL
            compiled = context.statement.compile(
                dialect=engine.dialect,
                compile_kwargs={"literal_binds": True}
            )
            full_sql = str(compiled)
        except Exception:
            # 如果无法编译，使用原始SQL
            full_sql = statement
    else:
        # 如果没有context，使用原始SQL
        full_sql = statement
    
    # 记录日志
    sql_logger.info(
        "SQL executed successfully",
        extra={
            "sql": statement,  # 原始SQL（带占位符）
            "sql_full": full_sql,  # 完整SQL（如果可用）
            "parameters": parameters
        }
    )
```

#### 2.3.3 限制

- ⚠️ **仅适用于ORM查询**：只对通过SQLAlchemy ORM生成的查询有效
- ⚠️ **不适用于原生SQL**：对于使用`text()`或`execute()`执行的原生SQL无效
- ⚠️ **context可能为空**：某些情况下`context`可能为`None`
- ⚠️ **类型限制**：`literal_binds=True`只支持基本类型，复杂类型可能无法正确处理

#### 2.3.4 适用场景

- 开发环境：调试ORM生成的SQL语句
- 有限场景：仅适用于ORM查询，不适用于所有SQL

### 2.4 方案4：应用层日志 + 参数分离（当前方案）

#### 2.4.1 方案说明

在日志中同时记录SQL语句和参数，不进行字符串替换，由日志查看工具或人工分析时组合。

#### 2.4.2 实现方式

```python
@event.listens_for(engine.sync_engine, "after_cursor_execute")
def receive_after_cursor_execute(conn, cursor, statement, parameters, context, executemany):
    """SQL执行后事件监听器"""
    sql_logger.info(
        "SQL executed successfully",
        extra={
            "sql": statement,  # 原始SQL（带占位符）
            "parameters": parameters,  # 参数（字典或列表）
            "duration_ms": duration_ms
        }
    )
```

#### 2.4.3 优点

- ✅ **完全安全**：不进行任何字符串替换
- ✅ **信息完整**：同时记录SQL和参数，可以手动组合
- ✅ **简单可靠**：实现简单，不会出错

#### 2.4.4 缺点

- ⚠️ **不够直观**：需要手动组合SQL和参数才能看到完整SQL
- ⚠️ **工具依赖**：需要日志查看工具支持参数替换显示

#### 2.4.5 适用场景

- 所有场景：作为基础方案，适用于所有环境
- 配合工具：配合日志查看工具，工具端进行参数替换显示

---

## 三、推荐方案

### 3.1 方案选择建议

根据使用场景选择：

| 场景 | 推荐方案 | 说明 |
|------|---------|------|
| **生产环境** | 方案1（PostgreSQL服务器日志） | 安全、可靠、完整 |
| **性能分析** | 方案2（pg_stat_statements） | 提供详细统计信息 |
| **开发调试** | 方案4（应用层日志+参数分离） | 简单、安全 |
| **ORM查询调试** | 方案3（compile方法） | 仅适用于ORM查询 |

### 3.2 混合方案（推荐）

**组合使用多个方案**：

1. **应用层**：使用方案4，记录SQL和参数（当前已实现）
2. **数据库层**：配置方案1，启用PostgreSQL服务器日志
3. **性能分析**：使用方案2，定期查询`pg_stat_statements`

**优点**：
- ✅ 应用层日志：便于应用开发人员查看
- ✅ 数据库层日志：提供完整的SQL审计
- ✅ 性能统计：提供SQL性能分析数据

---

## 四、实施建议

### 4.1 短期方案（立即可用）

**保持当前实现**（方案4）：
- 在日志中同时记录SQL语句和参数
- 不进行字符串替换
- 使用日志查看工具或人工分析时组合

**优点**：
- ✅ 已实现，无需修改
- ✅ 完全安全
- ✅ 信息完整

### 4.2 中期方案（推荐实施）

**配置PostgreSQL服务器日志**（方案1）：
1. 修改PostgreSQL的`postgresql.conf`配置
2. 启用`log_statement = 'all'`
3. 配置日志文件管理
4. 定期查看数据库日志文件

**优点**：
- ✅ 获取实际执行的SQL
- ✅ 完全安全
- ✅ 不影响应用性能

### 4.3 长期方案（可选）

**启用pg_stat_statements扩展**（方案2）：
1. 安装并启用`pg_stat_statements`扩展
2. 定期查询统计信息
3. 开发工具或脚本分析SQL性能

**优点**：
- ✅ 提供SQL性能统计
- ✅ 可以查看实际执行的SQL
- ✅ 便于性能优化

---

## 五、总结

### 5.1 核心结论

1. **SQLAlchemy和数据库驱动层面无法直接获取实际执行的SQL**
   - 这是安全设计，防止SQL注入
   - 参数替换在数据库服务器端完成

2. **推荐使用PostgreSQL数据库服务器日志**
   - 安全、可靠、完整
   - 记录的是数据库实际执行的SQL

3. **当前方案（应用层日志+参数分离）是安全的**
   - 不进行字符串替换
   - 信息完整，可以手动组合

### 5.2 安全原则

- ❌ **不使用代码层面的字符串替换**：不安全且容易出错
- ✅ **使用数据库原生功能**：安全、可靠
- ✅ **保持参数化查询**：防止SQL注入

### 5.3 实施优先级

1. **高优先级**：保持当前方案（应用层日志+参数分离）
2. **中优先级**：配置PostgreSQL服务器日志
3. **低优先级**：启用pg_stat_statements扩展（如需要性能分析）

---

## 六、参考资料

### 6.1 PostgreSQL日志配置

- [PostgreSQL日志配置文档](https://www.postgresql.org/docs/current/runtime-config-logging.html)
- `log_statement`: 控制记录哪些SQL语句
- `log_duration`: 记录SQL执行时间
- `log_min_duration_statement`: 记录慢查询

### 6.2 pg_stat_statements扩展

- [pg_stat_statements文档](https://www.postgresql.org/docs/current/pgstatstatements.html)
- 提供SQL执行统计信息
- 包含实际执行的SQL语句

### 6.3 SQLAlchemy事件系统

- [SQLAlchemy事件系统文档](https://docs.sqlalchemy.org/en/20/core/events.html)
- `before_cursor_execute`: SQL执行前事件
- `after_cursor_execute`: SQL执行后事件
