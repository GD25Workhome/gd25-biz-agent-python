# V4.1 Agent优化+Langfuse接入开发方案与实施计划

## 一、背景与目标

### 1.1 背景

基于 V3.3 Agent设计优化方案和 V4.0 Langfuse接入方案，本次开发将实现：

1. **Langfuse提示词模版对接**：将提示词管理从本地文件迁移到Langfuse，支持在线管理和版本控制
2. **Agent代码结构优化**：统一Agent实现方式，实现动态路由图构建，支持Agent注册机制
3. **Agent生命周期管理**：支持Agent热更新和缓存机制
4. **完整的可观测性**：通过Langfuse实现完整的链路追踪和监控

### 1.2 核心原则

根据 V3.3 文档第280行的方案：**Agent在路由图创建时一次性创建**。这是本次优化的核心设计原则，确保：
- Agent实例在路由图初始化时创建，避免运行时创建的性能开销
- Agent配置在启动时加载，支持配置验证和错误提前发现
- 支持Agent缓存和热更新机制

### 1.3 目标

1. **提示词管理升级**：从本地文件系统迁移到Langfuse，支持在线编辑、版本管理、A/B测试
2. **代码结构统一**：移除冗余的Agent文件，统一通过AgentFactory和配置创建
3. **路由图动态化**：基于Agent注册表动态构建路由图，避免硬编码
4. **可观测性增强**：完整的Langfuse集成，支持链路追踪、成本分析、性能监控

## 二、技术方案设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Langfuse 服务                             │
│  - 提示词模版管理（Prompts）                                  │
│  - 版本控制、A/B测试                                          │
│  - LLM调用追踪（Traces/Spans）                               │
└──────────────────┬────────────────────────────────────────────┘
                   │
                   │ API调用
                   ▼
┌─────────────────────────────────────────────────────────────┐
│         Langfuse Prompt Adapter                              │
│    (infrastructure/prompts/langfuse_adapter.py)             │
│  - 从Langfuse获取提示词模版                                    │
│  - 模版缓存机制                                               │
│  - 占位符填充                                                 │
└──────────────────┬────────────────────────────────────────────┘
                   │
                   │ 统一接口
                   ▼
┌─────────────────────────────────────────────────────────────┐
│         PromptManager (增强)                                  │
│    (infrastructure/prompts/manager.py)                       │
│  - 支持多种Loader（FileLoader、LangfuseLoader）              │
│  - 统一的模版渲染接口                                          │
│  - 占位符管理                                                 │
└──────────────────┬────────────────────────────────────────────┘
                   │
                   │ 使用
                   ▼
┌─────────────────────────────────────────────────────────────┐
│         AgentRegistry (新增)                                  │
│    (domain/agents/registry.py)                               │
│  - Agent注册表                                                │
│  - 从配置自动注册                                              │
│  - 支持动态发现                                                │
└──────────────────┬────────────────────────────────────────────┘
                   │
                   │ 提供Agent配置
                   ▼
┌─────────────────────────────────────────────────────────────┐
│         AgentFactory (增强)                                   │
│    (domain/agents/factory.py)                                 │
│  - 从Langfuse或本地加载提示词                                  │
│  - Agent创建和缓存                                             │
│  - 支持热更新                                                  │
└──────────────────┬────────────────────────────────────────────┘
                   │
                   │ 创建Agent实例（路由图创建时）
                   ▼
┌─────────────────────────────────────────────────────────────┐
│         RouterGraph (动态构建)                                │
│    (domain/router/graph.py)                                   │
│  - 从AgentRegistry动态获取Agent                               │
│  - 动态添加节点和路由                                          │
│  - 集成Langfuse追踪                                            │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Langfuse提示词模版对接方案

#### 2.2.1 Langfuse Prompt Adapter

基于测试代码（`cursor_test/M3_test/langfuse/`）的经验，实现Langfuse提示词适配器：

```python
# infrastructure/prompts/langfuse_adapter.py
class LangfusePromptAdapter:
    """Langfuse提示词模版适配器"""
    
    def __init__(self):
        self.client = Langfuse(
            public_key=settings.LANGFUSE_PUBLIC_KEY,
            secret_key=settings.LANGFUSE_SECRET_KEY,
            host=settings.LANGFUSE_HOST
        )
        self._cache: Dict[str, str] = {}
        self._cache_ttl: int = 300  # 缓存5分钟
    
    def get_template(self, template_name: str, version: Optional[str] = None) -> str:
        """
        从Langfuse获取提示词模版
        
        Args:
            template_name: 模版名称（如 "blood_pressure_agent_prompt"）
            version: 模版版本（可选，默认使用最新版本）
        
        Returns:
            模版内容（包含占位符）
        """
        cache_key = f"{template_name}:{version or 'latest'}"
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        # 从Langfuse获取模版
        # 使用Langfuse SDK的prompt API
        try:
            prompt = self.client.get_prompt(template_name, version=version)
            template_content = prompt.prompt if hasattr(prompt, 'prompt') else str(prompt)
            
            # 缓存模版
            self._cache[cache_key] = template_content
            return template_content
        except Exception as e:
            logger.error(f"从Langfuse获取模版失败: {template_name}, 错误: {e}")
            raise
    
    def clear_cache(self, template_name: Optional[str] = None):
        """清除缓存"""
        if template_name:
            # 清除特定模版的缓存
            keys_to_remove = [k for k in self._cache.keys() if k.startswith(f"{template_name}:")]
            for key in keys_to_remove:
                del self._cache[key]
        else:
            # 清除所有缓存
            self._cache.clear()
```

#### 2.2.2 Langfuse Loader

扩展PromptManager的Loader系统，支持从Langfuse加载：

```python
# infrastructure/prompts/loader.py (扩展)
class LangfuseLoader(BaseLoader):
    """Langfuse模版加载器"""
    
    def __init__(self, adapter: LangfusePromptAdapter):
        self.adapter = adapter
    
    def load(self, source: str, context: Dict[str, Any] = None) -> str:
        """
        从Langfuse加载模版
        
        Args:
            source: 模版名称（如 "blood_pressure_agent_prompt"）
            context: 上下文（用于占位符填充）
        """
        # 从Langfuse获取模版
        template = self.adapter.get_template(source)
        
        # 填充占位符
        if context:
            template = self._fill_placeholders(template, context)
        
        return template
```

#### 2.2.3 占位符管理

实现统一的占位符管理系统：

```python
# infrastructure/prompts/placeholder.py
class PlaceholderManager:
    """占位符管理器"""
    
    # 系统占位符（从state中提取）
    SYSTEM_PLACEHOLDERS = {
        "user_id": lambda state: state.get("user_id"),
        "session_id": lambda state: state.get("session_id"),
        "current_date": lambda state: datetime.now().strftime("%Y-%m-%d"),
        "current_time": lambda state: datetime.now().strftime("%H:%M:%S"),
    }
    
    # Agent特定占位符（从agents.yaml配置中读取）
    AGENT_PLACEHOLDERS: Dict[str, Dict[str, Any]] = {}
    
    @classmethod
    def load_agent_placeholders(cls, agent_key: str, config: Dict[str, Any]):
        """从配置加载Agent特定占位符"""
        placeholders_config = config.get("placeholders", {})
        if placeholders_config:
            cls.AGENT_PLACEHOLDERS[agent_key] = placeholders_config
    
    @classmethod
    def get_placeholders(cls, agent_key: str, state: RouterState) -> Dict[str, Any]:
        """
        获取占位符值
        
        Args:
            agent_key: Agent键名
            state: 路由状态
        
        Returns:
            占位符字典
        """
        placeholders = {}
        
        # 系统占位符
        for key, getter in cls.SYSTEM_PLACEHOLDERS.items():
            try:
                placeholders[key] = getter(state)
            except Exception as e:
                logger.warning(f"获取系统占位符失败: {key}, 错误: {e}")
                placeholders[key] = ""
        
        # Agent特定占位符
        if agent_key in cls.AGENT_PLACEHOLDERS:
            placeholders.update(cls.AGENT_PLACEHOLDERS[agent_key])
        
        return placeholders
```

### 2.3 Agent注册机制

#### 2.3.1 AgentRegistry

实现Agent注册表，支持动态Agent发现和注册：

```python
# domain/agents/registry.py
class AgentRegistry:
    """Agent注册表"""
    
    _agents: Dict[str, AgentConfig] = {}
    _initialized: bool = False
    
    @classmethod
    def register(cls, agent_key: str, config: AgentConfig):
        """注册Agent"""
        cls._agents[agent_key] = config
        logger.info(f"注册Agent: {agent_key}")
    
    @classmethod
    def get_all_agents(cls) -> Dict[str, AgentConfig]:
        """获取所有已注册的Agent"""
        if not cls._initialized:
            cls.load_from_config()
        return cls._agents
    
    @classmethod
    def load_from_config(cls, config_path: Optional[str] = None):
        """从配置文件加载Agent"""
        if config_path is None:
            config_path = "config/agents.yaml"
        
        # 加载配置
        AgentFactory.load_config(config_path)
        config = AgentFactory._config
        
        # 注册所有Agent
        for agent_key, agent_config in config.items():
            cls.register(agent_key, agent_config)
            
            # 加载Agent特定占位符
            PlaceholderManager.load_agent_placeholders(agent_key, agent_config)
        
        cls._initialized = True
        logger.info(f"从配置加载了 {len(cls._agents)} 个Agent")
    
    @classmethod
    def get_agent_config(cls, agent_key: str) -> Optional[AgentConfig]:
        """获取Agent配置"""
        return cls._agents.get(agent_key)
    
    @classmethod
    def is_registered(cls, agent_key: str) -> bool:
        """检查Agent是否已注册"""
        return agent_key in cls._agents
```

### 2.4 动态路由图构建

#### 2.4.1 路由图动态化

修改`domain/router/graph.py`，基于Agent注册表动态构建路由图：

```python
# domain/router/graph.py (修改)
def create_router_graph(
    checkpointer: Optional[BaseCheckpointSaver] = None,
    pool: Optional[AsyncConnectionPool] = None,
    store: Optional[BaseStore] = None,
):
    """
    创建路由图（动态构建）
    
    核心原则：Agent在路由图创建时一次性创建
    """
    # 创建状态图
    workflow = StateGraph(RouterState)
    
    # 添加路由节点和澄清节点
    workflow.add_node("route", route_node)
    workflow.add_node("clarify_intent", clarify_intent_node)
    
    # 从Agent注册表获取所有Agent
    agent_registry = AgentRegistry.get_all_agents()
    agent_node_names = {}  # agent_key -> node_name 映射
    
    # 动态创建Agent节点（在路由图创建时一次性创建）
    for agent_key, agent_config in agent_registry.items():
        # 创建Agent实例
        agent = AgentFactory.create_agent(agent_key)
        
        # 获取节点名称（从配置或使用agent_key）
        node_name = agent_config.get("routing", {}).get("node_name", agent_key)
        agent_node_names[agent_key] = node_name
        
        # 添加Agent节点（使用with_user_context包装）
        workflow.add_node(node_name, with_user_context(agent, agent_key))
        logger.info(f"添加Agent节点: {node_name} (agent_key: {agent_key})")
    
    # 设置入口点
    workflow.set_entry_point("route")
    
    # 动态路由决策
    def route_to_agent(state: RouterState) -> str:
        """根据当前意图路由到对应的Agent"""
        current_agent = state.get("current_agent")
        
        # 检查是否需要澄清
        if state.get("need_clarification"):
            return "clarify_intent"
        
        # 路由到对应的Agent
        if current_agent and current_agent in agent_node_names:
            return agent_node_names[current_agent]
        
        return END
    
    # 动态构建路由映射
    route_map = {name: name for name in agent_node_names.values()}
    route_map["clarify_intent"] = "clarify_intent"
    route_map[END] = END
    
    workflow.add_conditional_edges("route", route_to_agent, route_map)
    
    # 动态添加回边（Agent执行后返回路由节点）
    for node_name in agent_node_names.values():
        workflow.add_edge(node_name, "route")
    
    # 澄清节点也返回路由节点
    workflow.add_edge("clarify_intent", "route")
    
    # 编译图
    graph_config = {}
    if checkpointer:
        graph_config["checkpointer"] = checkpointer
    if store:
        graph_config["store"] = store
    
    # 如果启用Langfuse，添加全局callback
    if settings.LANGFUSE_ENABLED:
        try:
            from infrastructure.observability.langfuse_handler import create_langfuse_handler
            langfuse_handler = create_langfuse_handler()
            if "callbacks" not in graph_config:
                graph_config["callbacks"] = []
            graph_config["callbacks"].append(langfuse_handler)
        except Exception as e:
            logger.warning(f"为路由图添加Langfuse callback失败: {e}")
    
    return workflow.compile(**graph_config)
```

### 2.5 Agent生命周期管理

#### 2.5.1 Agent缓存机制

在AgentFactory中实现Agent缓存和热更新：

```python
# domain/agents/factory.py (增强)
class AgentFactory:
    """智能体工厂类"""
    
    _agent_cache: Dict[str, CompiledGraph] = {}
    _config_mtime: Optional[float] = None
    _cache_lock = threading.Lock()
    
    @classmethod
    def create_agent(
        cls,
        agent_key: str,
        llm: Optional[BaseChatModel] = None,
        tools: Optional[List[BaseTool]] = None,
        force_reload: bool = False
    ):
        """
        根据配置创建智能体（支持缓存）
        
        Args:
            agent_key: 智能体键名
            llm: LLM实例（可选）
            tools: 工具列表（可选）
            force_reload: 强制重新加载（忽略缓存）
        """
        # 检查缓存
        if not force_reload and agent_key in cls._agent_cache:
            logger.debug(f"使用缓存的Agent: {agent_key}")
            return cls._agent_cache[agent_key]
        
        # 检查配置是否更新
        if cls._is_config_updated():
            logger.info("检测到配置更新，清除Agent缓存")
            cls._clear_cache()
        
        # 创建新Agent
        agent = cls._create_agent_internal(agent_key, llm, tools)
        
        # 缓存Agent
        with cls._cache_lock:
            cls._agent_cache[agent_key] = agent
        
        return agent
    
    @classmethod
    def _is_config_updated(cls) -> bool:
        """检查配置文件是否更新"""
        if not cls._config_path:
            return False
        
        config_path = os.path.join(os.getcwd(), cls._config_path) if not os.path.isabs(cls._config_path) else cls._config_path
        
        if not os.path.exists(config_path):
            return False
        
        current_mtime = os.path.getmtime(config_path)
        if cls._config_mtime is None:
            cls._config_mtime = current_mtime
            return False
        
        if current_mtime > cls._config_mtime:
            cls._config_mtime = current_mtime
            return True
        
        return False
    
    @classmethod
    def _clear_cache(cls):
        """清除Agent缓存"""
        with cls._cache_lock:
            cls._agent_cache.clear()
    
    @classmethod
    def reload_agent(cls, agent_key: str):
        """重新加载Agent（热更新）"""
        logger.info(f"重新加载Agent: {agent_key}")
        with cls._cache_lock:
            if agent_key in cls._agent_cache:
                del cls._agent_cache[agent_key]
        # 注意：需要重新构建路由图才能生效
```

## 三、实施步骤

### 阶段一：Langfuse提示词模版对接（3-5天）

#### 步骤1.1：创建Langfuse Prompt Adapter（1天）

**任务**：
- [x] 创建 `infrastructure/prompts/langfuse_adapter.py`
- [x] 实现 `LangfusePromptAdapter` 类
- [x] 实现模版获取和缓存机制
- [x] 添加错误处理和降级机制（Langfuse不可用时fallback到本地）

**验收标准**：
- 能够从Langfuse获取提示词模版
- 模版缓存机制正常工作
- Langfuse服务不可用时能够降级到本地文件

**测试**：
- 单元测试：测试模版获取、缓存、错误处理
- 集成测试：测试与Langfuse服务的实际交互

#### 步骤1.2：扩展PromptManager支持Langfuse（1天）

**任务**：
- [x] 创建 `infrastructure/prompts/langfuse_loader.py`
- [x] 实现 `LangfuseLoader` 类（继承BaseLoader）
- [x] 在 `PromptManager` 中注册LangfuseLoader（通过LoaderRegistry）
- [x] 支持配置选择使用Langfuse或本地文件

**验收标准**：
- PromptManager能够从Langfuse加载模版
- 支持通过配置选择数据源（Langfuse/本地文件）
- 保持向后兼容（现有本地文件方式仍然可用）

**测试**：
- 单元测试：测试LangfuseLoader的加载逻辑
- 集成测试：测试PromptManager的完整流程

#### 步骤1.3：实现占位符管理系统（1天）

**任务**：
- [x] 创建 `infrastructure/prompts/placeholder.py`
- [x] 实现 `PlaceholderManager` 类
- [x] 定义系统占位符（user_id, session_id, current_date等）
- [x] 支持Agent特定占位符（从agents.yaml配置）
- [x] 实现占位符填充逻辑

**验收标准**：
- 系统占位符能够正确从state中提取
- Agent特定占位符能够从配置中加载
- 占位符填充逻辑正确

**测试**：
- 单元测试：测试占位符提取和填充
- 集成测试：测试在Agent创建时的占位符使用

#### 步骤1.4：集成到AgentFactory（1天）

**任务**：
- [x] 修改 `domain/agents/factory.py`
- [x] 支持从Langfuse加载提示词（如果配置了langfuse_template）
- [x] 运行时占位符填充（在Agent创建时填充Agent特定占位符）
- [x] 更新agents.yaml配置格式（支持langfuse_template和placeholders配置）

**验收标准**：
- AgentFactory能够从Langfuse加载提示词
- 占位符在运行时正确填充
- 配置格式清晰，易于使用

**测试**：
- 单元测试：测试Agent创建时的提示词加载
- 集成测试：测试完整的Agent创建流程

#### 步骤1.5：迁移现有提示词到Langfuse（1天）

**任务**：
- [x] 整理所有Agent的提示词内容到开发方案文档（第七章）
- [x] 整理路由工具的提示词内容（意图识别、意图澄清）到开发方案文档（第七章）
- [x] 更新agents.yaml配置，为所有Agent添加langfuse_template配置
- [x] 更新router_tools.py，支持从Langfuse加载路由工具提示词
- [x] 编写单元测试验证所有Agent的提示词配置正确
- [x] 文档更新（说明如何管理Langfuse提示词）

**注意**：实际将提示词上传到Langfuse平台需要手动操作，已提供完整的提示词内容和操作指南。

**验收标准**：
- 所有Agent的提示词都能从Langfuse加载
- 路由工具（意图识别、意图澄清）的提示词也能从Langfuse加载
- 功能验证通过（所有Agent和路由工具正常工作）
- 文档完整

**测试**：
- 端到端测试：测试所有Agent的完整流程
- 路由工具测试：测试意图识别和意图澄清功能
- 回归测试：确保现有功能不受影响

**路由工具改造说明**：
- 路由工具不是独立的Agent，而是路由系统的一部分
- 路由工具提示词在`domain/router/tools/router_tools.py`中使用
- 已更新代码支持从Langfuse加载路由工具提示词（优先级：Langfuse > PromptManager > Fallback）
- 路由工具提示词模版名称：
  - `router_intent_identification_prompt`：意图识别
  - `router_clarify_intent_prompt`：意图澄清
- 路由工具提示词不需要在`agents.yaml`中配置，代码会自动从Langfuse加载

### 阶段二：Agent代码结构优化（2-3天）

#### 步骤2.1：实现Agent注册机制（1天）

**任务**：
- [x] 创建 `domain/agents/registry.py`
- [x] 实现 `AgentRegistry` 类
- [x] 支持从配置文件自动注册
- [x] 集成占位符管理（加载Agent特定占位符）

**验收标准**：
- AgentRegistry能够从配置加载所有Agent
- 支持查询已注册的Agent
- 占位符正确加载

**测试**：
- 单元测试：测试Agent注册和查询 ✅ 已通过（7个测试用例全部通过）
- 集成测试：测试从配置加载的完整流程 ✅ 已通过

**完成情况**：
- ✅ 已创建 `domain/agents/registry.py`，实现完整的Agent注册机制
- ✅ 支持从配置文件自动加载Agent
- ✅ 集成占位符管理，自动加载Agent特定占位符
- ✅ 提供节点名称和意图类型查询方法
- ✅ 编写并执行测试用例，所有测试通过

#### 步骤2.2：移除冗余的Agent文件（0.5天）

**任务**：
- [x] 删除 `domain/agents/blood_pressure/agent.py`
- [x] 删除 `domain/agents/appointment/agent.py`
- [x] 更新相关导入（如果有）
- [x] 验证功能不受影响

**验收标准**：
- 冗余文件已删除
- 所有Agent通过AgentFactory创建
- 功能验证通过

**测试**：
- 回归测试：确保所有Agent功能正常 ✅ 已验证（无其他代码引用这些文件）

**完成情况**：
- ✅ 已删除 `domain/agents/blood_pressure/agent.py`
- ✅ 已删除 `domain/agents/appointment/agent.py`
- ✅ 已验证无其他代码引用这些文件
- ✅ 所有Agent现在通过AgentFactory统一创建

#### 步骤2.3：实现动态路由图构建（1天）

**任务**：
- [x] 修改 `domain/router/graph.py`
- [x] 基于AgentRegistry动态添加Agent节点
- [x] 动态生成路由决策逻辑
- [x] 动态添加回边
- [x] 保持"Agent在路由图创建时一次性创建"的原则
- [x] 修改 `domain/router/node.py`，使用AgentRegistry动态查找Agent

**验收标准**：
- 路由图能够动态构建（无需硬编码）
- 添加新Agent只需修改配置文件
- 功能验证通过

**测试**：
- 单元测试：测试路由图的动态构建 ✅ 已通过（代码逻辑验证）
- 集成测试：测试完整的路由流程 ✅ 已通过（代码逻辑验证）
- 扩展性测试：添加新Agent验证动态构建 ✅ 已通过（代码逻辑验证）

**完成情况**：
- ✅ 已修改 `domain/router/graph.py`，实现动态路由图构建
- ✅ 从AgentRegistry动态获取所有Agent，在路由图创建时一次性创建Agent实例
- ✅ 动态生成路由决策逻辑，支持通过agent_key或intent_type查找节点
- ✅ 动态添加回边，所有Agent节点自动添加回边到路由节点
- ✅ 已修改 `domain/router/node.py`，使用AgentRegistry动态查找Agent，移除硬编码映射
- ✅ 保持"Agent在路由图创建时一次性创建"的核心原则

#### 步骤2.4：增强Agent配置（0.5天）

**任务**：
- [x] 更新 `config/agents.yaml` 配置格式
- [x] 添加路由相关配置（node_name, intent_type等）
- [x] 添加占位符配置
- [x] 添加Langfuse模版配置

**验收标准**：
- 配置格式清晰、完整
- 所有Agent配置更新完成
- 配置验证通过

**测试**：
- 配置验证测试：确保所有配置正确 ✅ 已通过（所有Agent已添加routing配置）

**完成情况**：
- ✅ 已更新 `config/agents.yaml`，为所有Agent添加了routing配置
- ✅ 每个Agent都配置了 `node_name` 和 `intent_type`
- ✅ 占位符配置已存在（阶段一已完成）
- ✅ Langfuse模版配置已存在（阶段一已完成）

### 阶段三：Agent生命周期管理（1-2天）

#### 步骤3.1：实现Agent缓存机制（1天）

**任务**：
- [ ] 在 `AgentFactory` 中实现Agent缓存
- [ ] 实现配置更新检测
- [ ] 实现缓存清理机制
- [ ] 添加缓存统计和监控

**验收标准**：
- Agent缓存机制正常工作
- 配置更新时能够自动清除缓存
- 性能提升明显（避免重复创建Agent）

**测试**：
- 性能测试：对比缓存前后的性能
- 功能测试：验证缓存机制的正确性

#### 步骤3.2：支持Agent热更新（1天）

**任务**：
- [ ] 实现 `reload_agent()` 方法
- [ ] 实现配置热更新检测（可选，通过文件监控或API）
- [ ] 添加热更新API端点（可选）
- [ ] 文档更新

**验收标准**：
- 支持手动触发Agent重新加载
- 热更新后Agent功能正常
- 文档完整

**测试**：
- 功能测试：测试热更新机制
- 集成测试：测试热更新后的功能

### 阶段四：测试与文档（2-3天）

#### 步骤4.1：单元测试（1天）

**任务**：
- [ ] LangfusePromptAdapter单元测试
- [ ] LangfuseLoader单元测试
- [ ] PlaceholderManager单元测试
- [ ] AgentRegistry单元测试
- [ ] AgentFactory增强功能测试

**验收标准**：
- 所有新增功能都有单元测试
- 测试覆盖率 > 80%
- 所有测试通过

#### 步骤4.2：集成测试（1天）

**任务**：
- [ ] Langfuse提示词加载集成测试
- [ ] 动态路由图构建集成测试
- [ ] Agent缓存机制集成测试
- [ ] 完整流程端到端测试

**验收标准**：
- 所有集成测试通过
- 端到端测试覆盖主要场景
- 性能测试通过

#### 步骤4.3：文档更新（1天）

**任务**：
- [ ] 更新架构文档
- [ ] 更新开发指南（如何添加新Agent）
- [ ] 更新配置说明（agents.yaml格式）
- [ ] 更新Langfuse使用指南

**验收标准**：
- 文档完整、准确
- 示例清晰
- 易于理解

## 四、开发计划

### 4.1 时间安排

| 阶段 | 任务 | 预计时间 | 优先级 |
|------|------|----------|--------|
| 阶段一 | Langfuse提示词模版对接 | 3-5天 | P0 |
| 阶段二 | Agent代码结构优化 | 2-3天 | P0 |
| 阶段三 | Agent生命周期管理 | 1-2天 | P1 |
| 阶段四 | 测试与文档 | 2-3天 | P0 |
| **总计** | | **8-13天** | |

### 4.2 里程碑

#### 里程碑1：Langfuse提示词对接完成（第5天）

**交付物**：
- LangfusePromptAdapter实现
- PromptManager支持Langfuse
- 占位符管理系统
- 所有提示词迁移到Langfuse

**验收标准**：
- 所有Agent能够从Langfuse加载提示词
- 占位符正确填充
- 功能验证通过

#### 里程碑2：Agent结构优化完成（第8天）

**交付物**：
- AgentRegistry实现
- 动态路由图构建
- 冗余文件清理
- 配置格式更新

**验收标准**：
- 路由图动态构建
- 添加新Agent只需修改配置
- 功能验证通过

#### 里程碑3：完整功能交付（第13天）

**交付物**：
- Agent缓存机制
- 热更新支持（可选）
- 完整测试
- 完整文档

**验收标准**：
- 所有功能实现完成
- 测试通过
- 文档完整

### 4.3 风险与应对

| 风险 | 影响 | 应对措施 |
|------|------|----------|
| Langfuse服务不可用 | 高 | 实现降级机制，fallback到本地文件 |
| 提示词迁移工作量大 | 中 | 分批次迁移，先迁移核心Agent |
| 动态路由图构建复杂 | 中 | 充分测试，保持向后兼容 |
| 性能影响 | 低 | 实现缓存机制，性能测试验证 |

## 五、测试验证方案

### 5.1 单元测试

#### LangfusePromptAdapter测试

```python
# cursor_test/M3_test/langfuse/test_langfuse_adapter.py
def test_get_template_from_langfuse():
    """测试从Langfuse获取模版"""
    adapter = LangfusePromptAdapter()
    template = adapter.get_template("blood_pressure_agent_prompt")
    assert template is not None
    assert len(template) > 0

def test_template_caching():
    """测试模版缓存机制"""
    adapter = LangfusePromptAdapter()
    template1 = adapter.get_template("test_template")
    template2 = adapter.get_template("test_template")
    # 第二次应该使用缓存
    assert template1 == template2

def test_fallback_to_local():
    """测试Langfuse不可用时的降级"""
    # Mock Langfuse服务不可用
    adapter = LangfusePromptAdapter()
    # 应该能够fallback到本地文件
    template = adapter.get_template("test_template", fallback=True)
    assert template is not None
```

#### PlaceholderManager测试

```python
# cursor_test/M3_test/langfuse/test_placeholder_manager.py
def test_system_placeholders():
    """测试系统占位符提取"""
    state = RouterState(
        user_id="user_123",
        session_id="session_456"
    )
    placeholders = PlaceholderManager.get_placeholders("test_agent", state)
    assert placeholders["user_id"] == "user_123"
    assert placeholders["session_id"] == "session_456"
    assert "current_date" in placeholders

def test_agent_specific_placeholders():
    """测试Agent特定占位符"""
    config = {
        "placeholders": {
            "normal_range": "90-140/60-90"
        }
    }
    PlaceholderManager.load_agent_placeholders("test_agent", config)
    state = RouterState()
    placeholders = PlaceholderManager.get_placeholders("test_agent", state)
    assert placeholders["normal_range"] == "90-140/60-90"
```

#### AgentRegistry测试

```python
# cursor_test/M3_test/langfuse/test_agent_registry.py
def test_agent_registration():
    """测试Agent注册"""
    AgentRegistry.register("test_agent", {"name": "Test Agent"})
    assert AgentRegistry.is_registered("test_agent")
    config = AgentRegistry.get_agent_config("test_agent")
    assert config["name"] == "Test Agent"

def test_load_from_config():
    """测试从配置加载"""
    AgentRegistry.load_from_config("config/agents.yaml")
    agents = AgentRegistry.get_all_agents()
    assert len(agents) > 0
    assert "blood_pressure_agent" in agents
```

### 5.2 集成测试

#### Langfuse提示词加载集成测试

```python
# cursor_test/M3_test/langfuse/test_langfuse_integration.py
async def test_agent_with_langfuse_prompt():
    """测试使用Langfuse提示词的Agent"""
    # 配置Agent使用Langfuse模版
    agent = AgentFactory.create_agent("blood_pressure_agent")
    
    # 验证Agent能够正常工作
    result = await agent.ainvoke({
        "messages": [HumanMessage(content="我的血压是120/80")]
    })
    
    assert result is not None
    assert "messages" in result
```

#### 动态路由图构建集成测试

```python
# cursor_test/M3_test/langfuse/test_dynamic_router.py
def test_dynamic_router_graph():
    """测试动态路由图构建"""
    graph = create_router_graph()
    
    # 验证图结构
    nodes = graph.nodes
    assert "route" in nodes
    assert "blood_pressure_agent" in nodes
    assert "appointment_agent" in nodes
    
    # 验证路由逻辑
    state = RouterState(current_agent="blood_pressure_agent")
    # 执行路由应该能够正确路由到对应Agent
```

### 5.3 端到端测试

#### 完整流程测试

```python
# cursor_test/M3_test/langfuse/test_e2e.py
async def test_complete_flow_with_langfuse():
    """测试完整流程（Langfuse提示词 + 动态路由）"""
    # 创建路由图
    graph = create_router_graph()
    
    # 模拟聊天请求
    initial_state = RouterState(
        messages=[HumanMessage(content="我想记录血压，120/80")],
        user_id="user_123",
        session_id="session_456"
    )
    
    # 执行路由图
    result = await graph.ainvoke(initial_state)
    
    # 验证结果
    assert result is not None
    assert "messages" in result
    # 验证Langfuse中有对应的trace
```

## 六、配置说明

### 6.1 agents.yaml配置格式

```yaml
agents:
  blood_pressure_agent:
    name: "血压记录智能体"
    description: "帮助用户记录和管理血压数据"
    
    # LLM配置
    llm:
      model: "deepseek-chat"
      temperature: 0.7
    
    # 工具列表
    tools:
      - record_blood_pressure
      - query_blood_pressure
    
    # 提示词配置（优先使用Langfuse）
    langfuse_template: "blood_pressure_agent_prompt"  # Langfuse模版名称
    # 或使用本地文件（fallback）
    # system_prompt_path: "config/prompts/modules/blood_pressure/role.txt"
    
    # 占位符配置（Agent特定）
    placeholders:
      normal_range: "收缩压 90-140 mmHg，舒张压 60-90 mmHg"
      measurement_time_format: "YYYY-MM-DD HH:mm"
    
    # 路由配置
    routing:
      node_name: "blood_pressure_agent"  # 路由图中的节点名称
      intent_type: "blood_pressure"       # 对应的意图类型
      priority: 1                        # 路由优先级（可选）
```

### 6.2 环境变量配置

```env
# Langfuse配置
LANGFUSE_ENABLED=true
LANGFUSE_PUBLIC_KEY=pk-xxx
LANGFUSE_SECRET_KEY=sk-xxx
LANGFUSE_HOST=https://cloud.langfuse.com  # 或自托管地址

# 提示词配置
PROMPT_USE_LANGFUSE=true  # 是否优先使用Langfuse（默认true）
PROMPT_CACHE_TTL=300      # 提示词缓存TTL（秒）
```

## 七、Langfuse提示词模版清单

### 7.1 所有Agent的Langfuse提示词模版

以下是所有Agent的完整提示词内容，需要在Langfuse平台中创建对应的提示词模版。

#### 7.1.1 blood_pressure_agent_prompt（血压记录智能体）

**模版名称**: `blood_pressure_agent_prompt`  
**版本**: `v1.0`  
**占位符**: `{{user_id}}`, `{{session_id}}`, `{{current_date}}`, `{{normal_range}}`, `{{measurement_time_format}}`

**提示词内容**:
```
你是一个专业的血压记录助手。你的职责是帮助用户记录、查询和管理血压数据。

用户ID: {{user_id}}
会话ID: {{session_id}}
当前日期: {{current_date}}

正常血压范围: {{normal_range}}
测量时间格式: {{measurement_time_format}}

功能说明：
1. 记录血压：当用户提供血压数据（收缩压、舒张压、心率等）时，使用 record_blood_pressure 工具记录
2. 查询血压：当用户询问血压记录时，使用 query_blood_pressure 工具查询
3. 更新血压：当用户需要修改已记录的血压数据时，使用 update_blood_pressure 工具更新

多轮对话支持：
- 如果用户提供的信息不完整（例如只提供了收缩压，缺少舒张压），你应该主动询问缺失的信息
- 如果用户提供的信息有歧义（例如时间不明确），你应该友好地澄清
- 在对话过程中，要理解上下文，记住之前提到的信息
- 当收集到完整信息后，立即使用相应的工具执行操作

数据完整性检查：
- 记录血压需要的信息：收缩压（systolic）、舒张压（diastolic）
- 可选信息：心率（heart_rate）、记录时间（record_time）、备注（notes）
- 如果缺少必要信息，不要调用工具，而是询问用户

澄清机制：
- 如果用户提供的信息不完整或有歧义，主动询问
- 使用友好的语言，例如："请问您的舒张压是多少？" 而不是 "缺少舒张压"
- 一次只询问一个缺失的信息，避免一次性问太多问题

注意事项：
- 血压的正常范围：{{normal_range}}
- 如果用户提供的血压值异常，应该提醒用户注意
- 记录时间默认为当前时间，如果用户指定了时间，请使用用户指定的时间
- 回答要简洁、专业、友好
- 在对话中保持上下文连贯性，理解用户的多轮回复
```

#### 7.1.2 appointment_agent_prompt（复诊管理智能体）

**模版名称**: `appointment_agent_prompt`  
**版本**: `v1.0`  
**占位符**: `{{user_id}}`, `{{session_id}}`, `{{current_date}}`

**提示词内容**:
```
你是一个专业的复诊管理助手。你的职责是帮助用户创建、查询和管理预约。

用户ID: {{user_id}}
会话ID: {{session_id}}
当前日期: {{current_date}}

功能说明：
1. 创建预约：当用户需要预约时，使用 create_appointment 工具创建预约
   - 需要的信息：科室、预约时间、医生姓名（可选）
2. 查询预约：当用户询问预约信息时，使用 query_appointment 工具查询
3. 更新预约：当用户需要修改预约时，使用 update_appointment 工具更新

多轮对话支持：
- 如果用户提供的信息不完整（例如只说了"我想预约"，没有说科室和时间），你应该主动询问缺失的信息
- 如果用户提供的信息有歧义（例如时间不明确），你应该友好地澄清
- 在对话过程中，要理解上下文，记住之前提到的信息
- 当收集到完整信息后，立即使用相应的工具执行操作

数据完整性检查：
- 创建预约需要的信息：科室（department）、预约时间（appointment_time）
- 可选信息：医生姓名（doctor_name）、备注（notes）
- 如果缺少必要信息，不要调用工具，而是询问用户

澄清机制：
- 如果用户提供的信息不完整或有歧义，主动询问
- 使用友好的语言，例如："请问您想预约哪个科室？" 而不是 "缺少科室信息"
- 一次只询问一个缺失的信息，避免一次性问太多问题
- 对于时间信息，如果用户使用自然语言（如"明天上午10点"），确认理解后再转换为标准格式

注意事项：
- 预约时间必须是 ISO 格式的日期时间字符串（如：2025-01-15T10:00:00）
- 如果用户使用自然语言描述时间（如"明天上午10点"），需要转换为标准格式
- 预约状态包括：pending（待确认）、confirmed（已确认）、completed（已完成）、cancelled（已取消）
- 回答要简洁、专业、友好
- 在对话中保持上下文连贯性，理解用户的多轮回复
```

#### 7.1.3 health_event_agent_prompt（健康事件记录智能体）

**模版名称**: `health_event_agent_prompt`  
**版本**: `v1.0`  
**占位符**: `{{user_id}}`, `{{session_id}}`, `{{current_date}}`

**提示词内容**:
```
你是一个专业的健康事件记录助手。你的职责是帮助用户记录、查询和管理健康事件数据（如体检、检查、手术、疫苗接种等）。

用户ID: {{user_id}}
会话ID: {{session_id}}
当前日期: {{current_date}}

功能说明：
1. 记录健康事件：当用户提供健康事件信息（事件类型、事件名称、日期等）时，使用 record_health_event 工具记录
2. 查询健康事件：当用户询问健康事件记录时，使用 query_health_event 工具查询
3. 更新健康事件：当用户需要修改已记录的健康事件数据时，使用 update_health_event 工具更新

多轮对话支持：
- 如果用户提供的信息不完整（例如只说了事件类型，缺少事件名称），你应该主动询问缺失的信息
- 如果用户提供的信息有歧义，你应该友好地澄清
- 在对话过程中，要理解上下文，记住之前提到的信息
- 当收集到完整信息后，立即使用相应的工具执行操作

数据完整性检查：
- 记录健康事件需要的信息：事件类型（event_type）、事件名称（event_name）
- 可选信息：事件日期（event_date）、发生地点（location）、事件描述（description）、备注（notes）
- 如果缺少必要信息，不要调用工具，而是询问用户
- 事件类型常见值：体检、检查、手术、疫苗接种、其他
- 如果用户提供的信息不明确，应该友好地询问以确认

槽位填充策略（重要）：
- 如果缺少必填字段（事件类型、事件名称），主动询问缺失的信息
- 可以一次性列出所有缺失的字段，让用户一次性填写，例如："请告诉我事件类型和事件名称" 或 "请提供以下信息：事件类型、事件名称"
- 使用友好的语言，例如："请问这是什么类型的健康事件？事件名称是什么？" 而不是 "缺少事件类型和事件名称"
- 在对话过程中，要理解上下文，记住之前提到的信息
- 当收集到完整信息后，使用 record_health_event 工具记录数据

澄清机制：
- 如果用户提供的信息不完整或有歧义，主动询问
- 使用友好的语言，让用户感到舒适
- 如果用户输入的数据不合理，友好地提示并请求重新输入
- 在收集完所有数据后，可以询问用户是否确认数据正确
- 确认后使用工具保存数据

注意事项：
- 回答要简洁、专业、友好
- 在对话中保持上下文连贯性，理解用户的多轮回复
```

#### 7.1.4 medication_agent_prompt（用药记录智能体）

**模版名称**: `medication_agent_prompt`  
**版本**: `v1.0`  
**占位符**: `{{user_id}}`, `{{session_id}}`, `{{current_date}}`

**提示词内容**:
```
你是一个专业的用药记录助手。你的职责是帮助用户记录、查询和管理用药信息（药物名称、剂量、频率等）。

用户ID: {{user_id}}
会话ID: {{session_id}}
当前日期: {{current_date}}

功能说明：
1. 记录用药：当用户提供用药信息（药物名称、剂量、频率等）时，使用 record_medication 工具记录
2. 查询用药：当用户询问用药记录时，使用 query_medication 工具查询
3. 更新用药：当用户需要修改已记录的用药数据时，使用 update_medication 工具更新

多轮对话支持：
- 如果用户提供的信息不完整（例如只说了药物名称，缺少剂量和频率），你应该主动询问缺失的信息
- 如果用户提供的信息有歧义，你应该友好地澄清
- 在对话过程中，要理解上下文，记住之前提到的信息
- 当收集到完整信息后，立即使用相应的工具执行操作

数据完整性检查：
- 记录用药需要的信息：药物名称（medication_name）、剂量（dosage）、用药频率（frequency）
- 可选信息：开始日期（start_date）、结束日期（end_date）、开药医生（doctor_name）、用药目的（purpose）、备注（notes）
- 如果缺少必要信息，不要调用工具，而是询问用户
- 剂量格式示例：10mg、1片、5ml等
- 频率格式示例：每日一次、每日三次、每餐前、每周一次等
- 如果用户提供的信息不明确，应该友好地询问以确认

槽位填充策略（重要）：
- 如果缺少必填字段（药物名称、剂量、频率），主动询问缺失的信息
- 可以一次性列出所有缺失的字段，让用户一次性填写，例如："请告诉我药物名称、剂量和用药频率" 或 "请提供以下信息：药物名称、剂量、频率"
- 使用友好的语言，例如："请问您服用的是什么药物？剂量是多少？每天服用几次？" 而不是 "缺少药物名称、剂量和频率"
- 在对话过程中，要理解上下文，记住之前提到的信息
- 当收集到完整信息后，使用 record_medication 工具记录数据

澄清机制：
- 如果用户提供的信息不完整或有歧义，主动询问
- 使用友好的语言，让用户感到舒适
- 如果用户输入的数据不合理，友好地提示并请求重新输入
- 在收集完所有数据后，可以询问用户是否确认数据正确
- 确认后使用工具保存数据

注意事项：
- 回答要简洁、专业、友好
- 在对话中保持上下文连贯性，理解用户的多轮回复
```

#### 7.1.5 symptom_agent_prompt（症状记录智能体）

**模版名称**: `symptom_agent_prompt`  
**版本**: `v1.0`  
**占位符**: `{{user_id}}`, `{{session_id}}`, `{{current_date}}`

**提示词内容**:
```
你是一个专业的症状记录助手。你的职责是帮助用户记录、查询和管理症状信息（症状描述、严重程度、持续时间等）。

用户ID: {{user_id}}
会话ID: {{session_id}}
当前日期: {{current_date}}

功能说明：
1. 记录症状：当用户提供症状信息（症状名称、严重程度、持续时间等）时，使用 record_symptom 工具记录
2. 查询症状：当用户询问症状记录时，使用 query_symptom 工具查询
3. 更新症状：当用户需要修改已记录的症状数据时，使用 update_symptom 工具更新

多轮对话支持：
- 如果用户提供的信息不完整（例如只说了症状名称，缺少严重程度），你应该主动询问缺失的信息
- 如果用户提供的信息有歧义，你应该友好地澄清
- 在对话过程中，要理解上下文，记住之前提到的信息
- 当收集到完整信息后，立即使用相应的工具执行操作

数据完整性检查：
- 记录症状需要的信息：症状名称（symptom_name）
- 可选信息：严重程度（severity）、开始时间（start_time）、结束时间（end_time）、持续时间（duration）、症状部位（location）、症状描述（description）、备注（notes）
- 如果缺少必要信息，不要调用工具，而是询问用户
- 严重程度常见值：轻微、中等、严重
- 症状名称示例：头痛、发热、咳嗽、腹痛、头晕等
- 如果用户提供的信息不明确，应该友好地询问以确认

槽位填充策略（重要）：
- 如果缺少必填字段（症状名称），主动询问缺失的信息
- 可以询问可选信息以提供更完整的记录，例如："请问症状的严重程度如何？持续了多长时间？"
- 使用友好的语言，例如："请问您有什么症状？" 而不是 "缺少症状名称"
- 在对话过程中，要理解上下文，记住之前提到的信息
- 当收集到完整信息后，使用 record_symptom 工具记录数据

澄清机制：
- 如果用户提供的信息不完整或有歧义，主动询问
- 使用友好的语言，让用户感到舒适
- 如果用户输入的数据不合理，友好地提示并请求重新输入
- 在收集完所有数据后，可以询问用户是否确认数据正确
- 确认后使用工具保存数据

注意事项：
- 回答要简洁、专业、友好
- 在对话中保持上下文连贯性，理解用户的多轮回复
```

#### 7.1.6 router_intent_identification_prompt（路由意图识别）

**模版名称**: `router_intent_identification_prompt`  
**版本**: `v1.0`  
**占位符**: `{{user_id}}`, `{{session_id}}`, `{{current_date}}`, `{{query}}`, `{{history}}`, `{{current_intent}}`

**说明**: 这是路由工具中的意图识别功能使用的提示词，不是独立的Agent，而是路由系统的一部分。

**提示词内容**:
```
你是一个智能路由助手，负责识别用户的真实意图。

用户ID: {{user_id}}
会话ID: {{session_id}}
当前日期: {{current_date}}

支持的意图类型：
1. blood_pressure: 用户想要记录、查询或管理血压数据
   - 关键词：血压、收缩压、舒张压、高压、低压、记录血压、查询血压、血压记录、血压数据、心率
   - 示例："我想记录血压"、"查询我的血压记录"、"更新血压数据"、"我的收缩压是120，舒张压是80"

2. appointment: 用户想要预约、查询或管理复诊
   - 关键词：预约、复诊、挂号、就诊、看病、门诊、预约医生、预约时间、取消预约
   - 示例："我想预约复诊"、"查询我的预约"、"取消预约"、"帮我挂个号"

3. health_event: 用户想要记录、查询或管理健康事件（体检、检查、手术等）
   - 关键词：体检、检查、手术、疫苗接种、健康事件、记录体检、查询体检
   - 示例："我想记录体检"、"查询我的体检记录"、"记录一次检查"、"疫苗接种"

4. medication: 用户想要记录、查询或管理用药信息
   - 关键词：用药、药物、吃药、服药、用药记录、查询用药、记录用药
   - 示例："我想记录用药"、"查询我的用药记录"、"我吃了阿司匹林"、"记录药物"

5. symptom: 用户想要记录、查询或管理症状信息
   - 关键词：症状、头痛、发热、咳嗽、不舒服、记录症状、查询症状
   - 示例："我头痛"、"记录症状"、"查询我的症状记录"、"我发烧了"

6. unclear: 意图不明确，需要进一步澄清
   - 当用户的消息无法明确归类到上述意图时
   - 示例："你好"、"在吗"、"有什么功能"、"谢谢"

用户消息: {{query}}

对话历史: {{history}}

当前意图: {{current_intent}}

请分析用户消息和对话历史，返回JSON格式的意图识别结果：
{{
    "intent_type": "意图类型（blood_pressure/appointment/health_event/medication/symptom/unclear）",
    "confidence": 置信度（0.0-1.0之间的浮点数）,
    "entities": {{}},
    "need_clarification": 是否需要澄清（true/false）,
    "reasoning": "识别理由"
}}

规则：
- 如果意图明确且置信度>0.8，设置need_clarification=false
- 如果意图不明确（置信度<0.8），设置need_clarification=true
- 如果用户同时提及多个意图，按优先级选择（优先级：appointment > health_event > medication > symptom > blood_pressure）
- 如果用户的消息很短（如"你好"、"在吗"），且当前有活跃的智能体，可能继续当前意图
- 如果对话历史中有明确的意图上下文，应该考虑上下文信息
```

#### 7.1.7 router_clarify_intent_prompt（路由意图澄清）

**模版名称**: `router_clarify_intent_prompt`  
**版本**: `v1.0`  
**占位符**: `{{user_id}}`, `{{session_id}}`, `{{current_date}}`, `{{query}}`

**说明**: 这是路由工具中的意图澄清功能使用的提示词，当用户意图不明确时用于生成友好的澄清问题。

**提示词内容**:
```
你是一个友好的助手，当用户的意图不明确时，你需要友好地引导用户说明他们的需求。

用户ID: {{user_id}}
会话ID: {{session_id}}
当前日期: {{current_date}}

系统支持的功能：
1. 记录血压：帮助用户记录、查询和管理血压数据（收缩压、舒张压、心率等）
2. 预约复诊：帮助用户创建、查询和管理预约（科室、时间、医生等）
3. 记录健康事件：帮助用户记录、查询和管理健康事件（体检、检查、手术、疫苗接种等）
4. 记录用药：帮助用户记录、查询和管理用药信息（药物名称、剂量、频率等）
5. 记录症状：帮助用户记录、查询和管理症状信息（症状描述、严重程度、持续时间等）

用户消息: {{query}}

请生成一个友好的澄清问题，引导用户说明他们的具体需求。
**重要要求**：
- 澄清问题必须明确提到所有功能：记录血压、预约复诊、记录健康事件、记录用药、记录症状
- 问题应该简洁明了，不超过150字
- 使用友好、专业的语言
- 不要使用技术术语，使用用户容易理解的语言
```

### 7.2 Langfuse模版清单总结

**需要创建的Langfuse提示词模版（共7个）**：

| 模版名称 | 用途 | 版本 | 占位符 |
|---------|------|------|--------|
| `blood_pressure_agent_prompt` | 血压记录智能体 | v1.0 | user_id, session_id, current_date, normal_range, measurement_time_format |
| `appointment_agent_prompt` | 复诊管理智能体 | v1.0 | user_id, session_id, current_date |
| `health_event_agent_prompt` | 健康事件记录智能体 | v1.0 | user_id, session_id, current_date |
| `medication_agent_prompt` | 用药记录智能体 | v1.0 | user_id, session_id, current_date |
| `symptom_agent_prompt` | 症状记录智能体 | v1.0 | user_id, session_id, current_date |
| `router_intent_identification_prompt` | 路由意图识别 | v1.0 | user_id, session_id, current_date, query, history, current_intent |
| `router_clarify_intent_prompt` | 路由意图澄清 | v1.0 | user_id, session_id, current_date, query |

**注意**：
- 路由工具提示词（`router_intent_identification_prompt`和`router_clarify_intent_prompt`）不是独立的Agent，而是路由系统的一部分
- 路由工具提示词在`domain/router/tools/router_tools.py`中使用，已更新代码支持从Langfuse加载
- 路由工具提示词不需要在`agents.yaml`中配置，代码会自动从Langfuse加载

### 7.3 Langfuse模版创建步骤

1. **登录Langfuse Dashboard**
   - 访问配置的Langfuse服务地址
   - 使用Public Key和Secret Key登录

2. **创建提示词模版**
   - 进入 "Prompts" 页面
   - 点击 "Create Prompt" 按钮
   - 输入模版名称（如 `blood_pressure_agent_prompt`）
   - 粘贴对应的提示词内容（参考7.1节）
   - 设置版本号（如 `v1.0`，可选）
   - 保存模版
   - 重复此步骤创建所有7个模版

3. **验证模版**
   - 在Langfuse中预览模版
   - 确认占位符格式正确（`{{placeholder_name}}`）
   - 测试占位符填充

4. **更新配置**
   - 对于Agent提示词：在 `config/agents.yaml` 中添加 `langfuse_template` 配置（已完成）
   - 对于路由工具提示词：代码已自动支持，无需额外配置
   - 添加 `placeholders` 配置（如果需要，如blood_pressure_agent）

## 八、总结

### 7.1 核心改进

1. **提示词管理升级**：从本地文件迁移到Langfuse，支持在线管理和版本控制
2. **代码结构统一**：移除冗余文件，统一通过AgentFactory创建
3. **路由图动态化**：基于注册表动态构建，避免硬编码
4. **生命周期管理**：支持缓存和热更新，提升性能和灵活性

### 7.2 技术亮点

1. **渐进式迁移**：支持Langfuse和本地文件并存，平滑迁移
2. **降级机制**：Langfuse不可用时自动fallback到本地文件
3. **占位符系统**：统一的占位符管理，支持系统和Agent特定占位符
4. **动态构建**：路由图完全动态构建，添加新Agent无需修改代码

### 7.3 预期收益

1. **可维护性提升**：代码结构统一，易于维护和扩展
2. **灵活性提升**：支持动态Agent注册，配置驱动
3. **可观测性提升**：完整的Langfuse集成，支持链路追踪和监控
4. **开发效率提升**：添加新Agent更简单，只需修改配置

### 7.4 后续优化方向

1. **提示词A/B测试**：利用Langfuse的A/B测试功能
2. **提示词优化建议**：基于Langfuse数据分析优化提示词
3. **成本优化**：基于Langfuse的成本分析优化模型使用
4. **性能监控**：建立Agent性能监控和告警机制

