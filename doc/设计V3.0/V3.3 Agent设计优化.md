# V3.3 Agent设计优化方案

## 一、代码当前现状

### 1.1 Agent代码结构现状

#### 1.1.1 目录结构
当前 `domain/agents/` 目录结构如下：
```
domain/agents/
├── __init__.py
├── factory.py                    # Agent工厂类
├── blood_pressure/
│   ├── __init__.py
│   └── agent.py                  # 血压Agent工厂函数（仅调用AgentFactory）
└── appointment/
    ├── __init__.py
    └── agent.py                  # 预约Agent工厂函数（仅调用AgentFactory）
```

#### 1.1.2 Agent实现方式
1. **统一工厂模式**：
   - 所有Agent都通过 `AgentFactory.create_agent()` 统一创建
   - 使用 LangGraph 的 `create_react_agent` 创建 ReAct Agent
   - Agent配置统一在 `config/agents.yaml` 中管理

2. **部分Agent有独立文件**：
   - `blood_pressure/agent.py` 和 `appointment/agent.py` 存在，但仅包含简单的工厂函数
   - 这些文件实际上只是对 `AgentFactory.create_agent()` 的简单封装
   - 新添加的Agent（health_event、medication、symptom）没有对应的独立文件

3. **Agent创建流程**：
   ```python
   # 当前实现（domain/agents/factory.py）
   @classmethod
   def create_agent(cls, agent_key: str, ...):
       # 1. 从配置加载Agent配置
       agent_config = cls._config.get(agent_key)
       
       # 2. 创建LLM实例
       llm = get_llm(...)
       
       # 3. 从工具注册表获取工具
       tools = [TOOL_REGISTRY[name] for name in tool_names]
       
       # 4. 加载系统提示词（优先使用PromptManager）
       system_prompt = prompt_manager.render(agent_key, context={})
       
       # 5. 创建ReAct Agent
       return create_react_agent(model=llm, tools=tools, prompt=system_prompt)
   ```

#### 1.1.3 路由图中的Agent使用
在 `domain/router/graph.py` 中，Agent节点是硬编码添加的：
```python
# 硬编码添加Agent节点
blood_pressure_agent = AgentFactory.create_agent("blood_pressure_agent")
workflow.add_node("blood_pressure_agent", with_user_context(blood_pressure_agent, "blood_pressure_agent"))

appointment_agent = AgentFactory.create_agent("appointment_agent")
workflow.add_node("appointment_agent", with_user_context(appointment_agent, "appointment_agent"))

# ... 其他Agent类似
```

路由决策也是硬编码的：
```python
def route_to_agent(state: RouterState) -> str:
    if current_agent == "blood_pressure_agent":
        return "blood_pressure_agent"
    elif current_agent == "appointment_agent":
        return "appointment_agent"
    # ... 硬编码所有Agent
```

### 1.2 提示词管理现状

#### 1.2.1 提示词管理系统
当前已有 `PromptManager` 类（`infrastructure/prompts/manager.py`），支持：
- 模块化提示词管理（`config/prompts/modules/`）
- 模板加载和渲染
- 版本管理
- 缓存机制

#### 1.2.2 提示词加载方式
在 `AgentFactory.create_agent()` 中，提示词加载逻辑：
```python
# 优先使用PromptManager
try:
    prompt_manager = cls._get_prompt_manager()
    system_prompt = prompt_manager.render(agent_key=agent_key, context={})
except (FileNotFoundError, ValueError) as e:
    # 回退到原有方式：从YAML配置或文件加载
    system_prompt = agent_config.get("system_prompt", "")
    prompt_path = agent_config.get("system_prompt_path")
    if prompt_path and os.path.exists(prompt_path):
        with open(prompt_path, "r", encoding="utf-8") as f:
            system_prompt = f.read()
```

#### 1.2.3 提示词存储方式
1. **YAML配置中内联**（旧方式）：
   ```yaml
   blood_pressure_agent:
     system_prompt: |
       你是一个专业的血压记录助手...
   ```

2. **独立文件**（过渡方式）：
   ```yaml
   blood_pressure_agent:
     system_prompt_path: "config/prompts/blood_pressure_prompt.txt"
   ```

3. **模块化提示词**（新方式）：
   ```yaml
   health_event_agent:
     system_prompt_path: "config/prompts/modules/health_event/role.txt"
   ```
   模块化提示词目录结构：
   ```
   config/prompts/modules/
   ├── health_event/
   │   ├── role.txt
   │   ├── function_description.txt
   │   ├── clarification.txt
   │   ├── data_validation.txt
   │   ├── few_shot_examples.txt
   │   ├── notes.txt
   │   └── response_format.txt
   ```

#### 1.2.4 Langfuse集成现状
根据 `doc/设计V4.0/Langfuse接入方案.md`，已有Langfuse接入方案，但：
- 主要用于LLM调用追踪和可观测性
- **尚未实现提示词模版管理功能**
- 提示词仍然存储在本地文件系统中

### 1.3 路由图编排现状

#### 1.3.1 路由图构建
在 `domain/router/graph.py` 的 `create_router_graph()` 函数中：
- Agent节点是硬编码添加的
- 每个Agent都需要手动调用 `workflow.add_node()`
- 路由决策函数 `route_to_agent()` 中硬编码了所有Agent的判断逻辑
- Agent执行后的回边也是硬编码的

#### 1.3.2 用户上下文注入
通过 `with_user_context()` 函数包装Agent节点，注入用户上下文：
```python
def with_user_context(agent_node, agent_name: str):
    async def _run(state: RouterState) -> RouterState:
        # 从state中提取user_id
        user_id = state.get("user_id")
        # 通过RunnableConfig注入到工具中
        config = {"configurable": {"user_id": user_id}}
        # 调用Agent
        result = await agent_node.ainvoke(state, config=config)
        return result
    return _run
```

### 1.4 其他问题

#### 1.4.1 Agent生命周期管理
- Agent在路由图创建时一次性创建，无法动态更新
- 无法支持Agent的热更新（修改配置后需要重启服务）

#### 1.4.2 Agent配置管理
- 配置分散在 `config/agents.yaml` 中
- 没有配置验证机制
- 没有配置版本管理

#### 1.4.3 Agent监控和调试
- 缺乏统一的Agent执行监控
- 无法追踪Agent的执行性能
- 调试困难，需要查看日志才能了解Agent执行情况

---

## 二、分析

### 2.1 Agent代码结构问题分析

#### 2.1.1 设计不一致
**问题**：
- 部分Agent有独立的目录和文件（`blood_pressure/agent.py`、`appointment/agent.py`），但实际只是简单的工厂函数封装
- 新添加的Agent（health_event、medication、symptom）没有对应的独立文件
- 这种不一致性导致代码结构混乱，难以维护

**影响**：
- 开发者不清楚是否应该为新Agent创建独立文件
- 代码结构不统一，影响可维护性
- 无法扩展Agent特定的功能（如自定义节点、特殊处理逻辑等）

#### 2.1.2 缺乏统一的Agent接口
**问题**：
- 所有Agent都直接使用 `create_react_agent` 创建，没有统一的基类或接口
- 无法定义Agent的通用行为（如错误处理、日志记录、性能监控等）
- 无法支持不同类型的Agent（如ReAct Agent、Plan-and-Execute Agent等）

**影响**：
- 无法统一管理Agent的行为
- 扩展新类型的Agent困难
- 代码重复，缺乏抽象

#### 2.1.3 路由图硬编码问题
**问题**：
- Agent节点在路由图中硬编码添加
- 添加新Agent需要修改 `graph.py` 的多个地方
- 路由决策逻辑硬编码，不够灵活

**影响**：
- 添加新Agent需要修改核心路由代码
- 容易出错（忘记添加节点、忘记添加路由逻辑等）
- 无法支持动态Agent注册

### 2.2 提示词管理问题分析

#### 2.2.1 提示词存储方式混乱
**问题**：
- 同时存在三种提示词存储方式：YAML内联、独立文件、模块化文件
- 不同Agent使用不同的存储方式，不统一
- 缺乏统一的提示词管理策略

**影响**：
- 提示词管理混乱，难以维护
- 无法统一进行提示词优化和版本管理
- 迁移到Langfuse困难

#### 2.2.2 未对接Langfuse提示词模版
**问题**：
- 虽然已有Langfuse接入方案，但主要用于可观测性
- 提示词仍然存储在本地文件系统
- 无法利用Langfuse的提示词版本管理、A/B测试等功能

**影响**：
- 无法进行提示词的在线管理和优化
- 无法进行A/B测试对比不同提示词效果
- 提示词版本管理困难
- 无法利用Langfuse的提示词优化建议

#### 2.2.3 占位符管理不完善
**问题**：
- 当前提示词系统支持占位符（通过 `context` 参数），但：
  - 占位符定义不明确
  - 占位符的填充逻辑分散在各处
  - 没有统一的占位符管理机制

**影响**：
- 占位符使用不规范
- 难以追踪占位符的来源和用途
- 占位符变更影响范围不明确

### 2.3 路由图编排问题分析

#### 2.3.1 硬编码导致的可维护性问题
**问题**：
- Agent节点添加、路由决策、回边设置都是硬编码
- 添加新Agent需要修改多个地方

**影响**：
- 维护成本高
- 容易出错
- 无法支持动态Agent注册

#### 2.3.2 缺乏Agent注册机制
**问题**：
- 没有统一的Agent注册机制
- 无法动态发现和注册Agent

**影响**：
- 添加新Agent需要手动修改代码
- 无法支持插件化的Agent扩展

### 2.4 其他问题分析

#### 2.4.1 Agent生命周期管理
**问题**：
- Agent在路由图创建时一次性创建
- 无法支持Agent的热更新

**影响**：
- 修改Agent配置需要重启服务
- 无法支持动态配置更新

#### 2.4.2 缺乏统一的监控和调试机制
**问题**：
- 缺乏统一的Agent执行监控
- 无法追踪Agent的执行性能
- 调试困难

**影响**：
- 难以发现Agent性能问题
- 调试效率低
- 无法进行Agent性能优化

---

## 三、建议

### 3.1 Agent代码结构优化建议

#### 3.1.1 统一Agent实现方式
**建议**：采用统一的Agent实现方式，有两种方案：

**方案A：完全基于配置（推荐）**
- 移除所有Agent的独立文件（`blood_pressure/agent.py`、`appointment/agent.py`等）
- 所有Agent都通过 `AgentFactory` 从配置创建
- 保持代码简洁，易于维护

**方案B：统一Agent基类**
- 定义统一的 `BaseAgent` 基类
- 每个Agent可以有独立的实现类（如果需要自定义行为）
- 提供默认的ReAct Agent实现

**推荐方案A**，因为：
- 当前所有Agent都是ReAct Agent，行为一致
- 配置驱动更灵活，易于维护
- 减少代码复杂度

#### 3.1.2 引入Agent注册机制
**建议**：实现Agent注册机制，支持动态Agent发现和注册：

```python
# domain/agents/registry.py
class AgentRegistry:
    """Agent注册表"""
    _agents: Dict[str, AgentConfig] = {}
    
    @classmethod
    def register(cls, agent_key: str, config: AgentConfig):
        """注册Agent"""
        cls._agents[agent_key] = config
    
    @classmethod
    def get_all_agents(cls) -> Dict[str, AgentConfig]:
        """获取所有已注册的Agent"""
        return cls._agents
    
    @classmethod
    def load_from_config(cls, config_path: str):
        """从配置文件加载Agent"""
        # 从agents.yaml加载配置并注册
```

#### 3.1.3 路由图动态构建
**建议**：基于Agent注册表动态构建路由图：

```python
# domain/router/graph.py
def create_router_graph(...):
    workflow = StateGraph(RouterState)
    
    # 动态添加Agent节点
    agent_registry = AgentRegistry.get_all_agents()
    for agent_key, agent_config in agent_registry.items():
        agent = AgentFactory.create_agent(agent_key)
        node_name = agent_key  # 或从配置中获取
        workflow.add_node(node_name, with_user_context(agent, agent_key))
    
    # 动态路由决策
    def route_to_agent(state: RouterState) -> str:
        current_agent = state.get("current_agent")
        if current_agent and current_agent in agent_registry:
            return current_agent
        return END
    
    # 动态添加回边
    for agent_key in agent_registry.keys():
        workflow.add_edge(agent_key, "route")
```

### 3.2 Langfuse提示词模版对接建议

#### 3.2.1 架构设计
**建议**：实现Langfuse提示词模版管理，架构如下：

```
┌─────────────────────────────────────────────────────────┐
│                  Langfuse 服务                          │
│  - 提示词模版管理                                        │
│  - 版本控制                                              │
│  - A/B测试                                              │
└──────────────────┬──────────────────────────────────────┘
                   │
                   │ API调用（获取模版）
                   ▼
┌─────────────────────────────────────────────────────────┐
│            Langfuse Prompt Adapter                      │
│  (infrastructure/prompts/langfuse_adapter.py)          │
│  - 从Langfuse获取模版                                    │
│  - 模版缓存                                              │
│  - 占位符填充                                            │
└──────────────────┬──────────────────────────────────────┘
                   │
                   │ 提供统一接口
                   ▼
┌─────────────────────────────────────────────────────────┐
│              PromptManager (增强)                        │
│  - 支持多种Loader（FileLoader、LangfuseLoader）         │
│  - 统一的模版渲染接口                                    │
│  - 占位符管理                                            │
└──────────────────┬──────────────────────────────────────┘
                   │
                   │ 使用
                   ▼
┌─────────────────────────────────────────────────────────┐
│              AgentFactory                                │
│  - 通过PromptManager获取提示词                           │
└─────────────────────────────────────────────────────────┘
```

#### 3.2.2 实现方案

**步骤1：创建Langfuse Prompt Adapter**

```python
# infrastructure/prompts/langfuse_adapter.py
from typing import Dict, Any, Optional
from langfuse import Langfuse
from app.core.config import settings

class LangfusePromptAdapter:
    """Langfuse提示词模版适配器"""
    
    def __init__(self):
        self.client = Langfuse(
            public_key=settings.LANGFUSE_PUBLIC_KEY,
            secret_key=settings.LANGFUSE_SECRET_KEY,
            host=settings.LANGFUSE_HOST
        )
        self._cache: Dict[str, str] = {}
    
    def get_template(self, template_name: str, version: Optional[str] = None) -> str:
        """
        从Langfuse获取提示词模版
        
        Args:
            template_name: 模版名称（如 "blood_pressure_agent_prompt"）
            version: 模版版本（可选，默认使用最新版本）
        
        Returns:
            模版内容（包含占位符）
        """
        cache_key = f"{template_name}:{version or 'latest'}"
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        # 从Langfuse获取模版
        # 注意：需要根据Langfuse API实现
        template = self._fetch_template_from_langfuse(template_name, version)
        
        self._cache[cache_key] = template
        return template
    
    def _fetch_template_from_langfuse(self, template_name: str, version: Optional[str]) -> str:
        """从Langfuse获取模版（需要根据Langfuse API实现）"""
        # TODO: 实现Langfuse API调用
        pass
```

**步骤2：扩展PromptManager支持Langfuse Loader**

```python
# infrastructure/prompts/loader.py (扩展)
class LangfuseLoader(BaseLoader):
    """Langfuse模版加载器"""
    
    def __init__(self, adapter: LangfusePromptAdapter):
        self.adapter = adapter
    
    def load(self, source: str, context: Dict[str, Any] = None) -> str:
        """
        从Langfuse加载模版
        
        Args:
            source: 模版名称（如 "blood_pressure_agent_prompt"）
            context: 上下文（用于占位符填充）
        """
        # 从Langfuse获取模版
        template = self.adapter.get_template(source)
        
        # 填充占位符
        if context:
            template = self._fill_placeholders(template, context)
        
        return template
```

**步骤3：占位符管理**

```python
# infrastructure/prompts/placeholder.py
class PlaceholderManager:
    """占位符管理器"""
    
    # 定义系统占位符
    SYSTEM_PLACEHOLDERS = {
        "user_id": lambda state: state.get("user_id"),
        "session_id": lambda state: state.get("session_id"),
        "current_date": lambda state: datetime.now().strftime("%Y-%m-%d"),
        "current_time": lambda state: datetime.now().strftime("%H:%M:%S"),
        # ... 其他系统占位符
    }
    
    # Agent特定占位符（在agents.yaml中配置）
    AGENT_PLACEHOLDERS = {
        "blood_pressure_agent": {
            "normal_range": "收缩压 90-140 mmHg，舒张压 60-90 mmHg",
            # ... 其他Agent特定占位符
        }
    }
    
    @classmethod
    def get_placeholders(cls, agent_key: str, state: RouterState) -> Dict[str, Any]:
        """
        获取占位符值
        
        Args:
            agent_key: Agent键名
            state: 路由状态
        
        Returns:
            占位符字典
        """
        placeholders = {}
        
        # 系统占位符
        for key, getter in cls.SYSTEM_PLACEHOLDERS.items():
            placeholders[key] = getter(state)
        
        # Agent特定占位符
        if agent_key in cls.AGENT_PLACEHOLDERS:
            placeholders.update(cls.AGENT_PLACEHOLDERS[agent_key])
        
        return placeholders
```

**步骤4：在AgentFactory中使用**

```python
# domain/agents/factory.py (修改)
@classmethod
def create_agent(cls, agent_key: str, ...):
    # ... 其他代码 ...
    
    # 获取系统提示词
    prompt_manager = cls._get_prompt_manager()
    
    # 从Langfuse获取模版（如果配置了）
    agent_config = cls._config.get(agent_key)
    langfuse_template = agent_config.get("langfuse_template")
    
    if langfuse_template:
        # 使用Langfuse模版
        system_prompt = prompt_manager.render_from_langfuse(
            template_name=langfuse_template,
            agent_key=agent_key,
            context={}  # 占位符在运行时填充
        )
    else:
        # 使用本地模版（现有方式）
        system_prompt = prompt_manager.render(agent_key=agent_key, context={})
```

**步骤5：运行时占位符填充**

```python
# domain/router/graph.py (修改with_user_context)
def with_user_context(agent_node, agent_name: str):
    async def _run(state: RouterState) -> RouterState:
        # 获取占位符值
        from infrastructure.prompts.placeholder import PlaceholderManager
        placeholders = PlaceholderManager.get_placeholders(agent_name, state)
        
        # 如果Agent使用Langfuse模版，需要在运行时填充占位符
        # 注意：这需要在Agent执行前更新系统提示词
        # 可以通过修改messages中的SystemMessage实现
        
        # ... 其他代码 ...
    return _run
```

#### 3.2.3 配置管理

在 `config/agents.yaml` 中配置Langfuse模版：

```yaml
agents:
  blood_pressure_agent:
    # ... 其他配置 ...
    # 使用Langfuse模版
    langfuse_template: "blood_pressure_agent_prompt"
    # 或使用本地模版（兼容现有方式）
    # system_prompt_path: "config/prompts/modules/blood_pressure/role.txt"
    
    # 占位符配置（可选）
    placeholders:
      normal_range: "收缩压 90-140 mmHg，舒张压 60-90 mmHg"
```

#### 3.2.4 迁移策略

1. **阶段一：并行支持**
   - 同时支持Langfuse模版和本地模版
   - 通过配置选择使用哪种方式
   - 逐步迁移Agent到Langfuse

2. **阶段二：统一管理**
   - 所有提示词模版迁移到Langfuse
   - 本地文件作为fallback或缓存

3. **阶段三：完全切换**
   - 移除本地提示词文件
   - 完全使用Langfuse管理提示词

### 3.3 路由图编排优化建议

#### 3.3.1 基于配置的动态路由图构建
**建议**：从Agent注册表动态构建路由图，避免硬编码：

```python
# domain/router/graph.py
def create_router_graph(...):
    workflow = StateGraph(RouterState)
    
    # 从注册表获取所有Agent
    agent_registry = AgentRegistry.get_all_agents()
    agent_node_names = {}
    
    # 动态添加Agent节点
    for agent_key, agent_config in agent_registry.items():
        agent = AgentFactory.create_agent(agent_key)
        node_name = agent_config.get("node_name", agent_key)
        agent_node_names[agent_key] = node_name
        workflow.add_node(node_name, with_user_context(agent, agent_key))
    
    # 动态路由决策
    def route_to_agent(state: RouterState) -> str:
        current_agent = state.get("current_agent")
        if current_agent and current_agent in agent_node_names:
            return agent_node_names[current_agent]
        # 处理澄清节点
        if state.get("need_clarification"):
            return "clarify_intent"
        return END
    
    # 动态添加条件边
    route_map = {name: name for name in agent_node_names.values()}
    route_map["clarify_intent"] = "clarify_intent"
    route_map[END] = END
    
    workflow.add_conditional_edges("route", route_to_agent, route_map)
    
    # 动态添加回边
    for node_name in agent_node_names.values():
        workflow.add_edge(node_name, "route")
```

#### 3.3.2 Agent配置增强
**建议**：在 `config/agents.yaml` 中增加路由相关配置：

```yaml
agents:
  blood_pressure_agent:
    # ... 现有配置 ...
    # 路由配置
    routing:
      node_name: "blood_pressure_agent"  # 路由图中的节点名称
      intent_type: "blood_pressure"      # 对应的意图类型
      priority: 1                        # 路由优先级（可选）
```

### 3.4 其他优化建议

#### 3.4.1 Agent生命周期管理
**建议**：支持Agent的热更新：

```python
# domain/agents/factory.py
class AgentFactory:
    _agent_cache: Dict[str, CompiledGraph] = {}
    _config_mtime: Optional[float] = None
    
    @classmethod
    def create_agent(cls, agent_key: str, ...):
        # 检查配置是否更新
        if cls._is_config_updated():
            cls._clear_cache()
        
        # 使用缓存或创建新Agent
        if agent_key in cls._agent_cache:
            return cls._agent_cache[agent_key]
        
        agent = cls._create_agent_internal(agent_key, ...)
        cls._agent_cache[agent_key] = agent
        return agent
    
    @classmethod
    def reload_agent(cls, agent_key: str):
        """重新加载Agent（热更新）"""
        if agent_key in cls._agent_cache:
            del cls._agent_cache[agent_key]
        # 清除路由图中的Agent节点（需要重新构建路由图）
```

#### 3.4.2 统一的监控和调试机制
**建议**：为Agent添加统一的监控和调试支持：

```python
# domain/agents/base.py (新增)
class AgentMonitor:
    """Agent监控器"""
    
    @staticmethod
    def wrap_agent(agent, agent_key: str):
        """包装Agent，添加监控"""
        async def monitored_agent(state, config=None):
            start_time = time.time()
            try:
                result = await agent.ainvoke(state, config=config)
                duration = time.time() - start_time
                # 记录监控数据
                logger.info(f"Agent {agent_key} 执行成功，耗时: {duration:.2f}s")
                return result
            except Exception as e:
                duration = time.time() - start_time
                logger.error(f"Agent {agent_key} 执行失败，耗时: {duration:.2f}s，错误: {str(e)}")
                raise
        return monitored_agent
```

#### 3.4.3 配置验证
**建议**：添加Agent配置验证：

```python
# domain/agents/validator.py (新增)
class AgentConfigValidator:
    """Agent配置验证器"""
    
    @staticmethod
    def validate(config: Dict[str, Any]) -> Tuple[bool, List[str]]:
        """
        验证Agent配置
        
        Returns:
            (是否有效, 错误列表)
        """
        errors = []
        
        # 验证必需字段
        required_fields = ["name", "tools"]
        for field in required_fields:
            if field not in config:
                errors.append(f"缺少必需字段: {field}")
        
        # 验证工具是否存在
        tools = config.get("tools", [])
        for tool_name in tools:
            if tool_name not in TOOL_REGISTRY:
                errors.append(f"工具不存在: {tool_name}")
        
        return len(errors) == 0, errors
```

---

## 四、实施计划

### 4.1 第一阶段：Agent代码结构统一（1-2天）

1. **移除冗余的Agent文件**
   - 删除 `domain/agents/blood_pressure/agent.py` 和 `appointment/agent.py`
   - 所有Agent统一通过 `AgentFactory` 创建

2. **实现Agent注册机制**
   - 创建 `domain/agents/registry.py`
   - 实现 `AgentRegistry` 类
   - 从 `config/agents.yaml` 自动注册Agent

3. **实现动态路由图构建**
   - 修改 `domain/router/graph.py`
   - 基于注册表动态添加Agent节点
   - 动态生成路由决策逻辑

### 4.2 第二阶段：Langfuse提示词模版对接（3-5天）

1. **创建Langfuse适配器**
   - 实现 `LangfusePromptAdapter`
   - 实现模版获取和缓存机制

2. **扩展PromptManager**
   - 添加 `LangfuseLoader`
   - 支持从Langfuse加载模版

3. **实现占位符管理**
   - 创建 `PlaceholderManager`
   - 定义系统占位符和Agent特定占位符
   - 实现占位符填充逻辑

4. **集成到AgentFactory**
   - 支持Langfuse模版配置
   - 运行时占位符填充

5. **迁移现有提示词**
   - 将现有提示词模版上传到Langfuse
   - 更新配置文件使用Langfuse模版

### 4.3 第三阶段：其他优化（2-3天）

1. **Agent生命周期管理**
   - 实现Agent缓存机制
   - 支持配置热更新

2. **监控和调试**
   - 实现Agent监控器
   - 添加性能追踪

3. **配置验证**
   - 实现配置验证器
   - 启动时验证所有Agent配置

### 4.4 测试和文档（1-2天）

1. **单元测试**
   - Agent注册机制测试
   - Langfuse适配器测试
   - 占位符管理测试

2. **集成测试**
   - 完整流程测试
   - 热更新测试

3. **文档更新**
   - 更新架构文档
   - 更新开发指南
   - 更新配置说明

---

## 五、总结

### 5.1 主要改进点

1. **统一Agent实现方式**：移除冗余文件，统一通过工厂和配置创建
2. **动态路由图构建**：基于注册表动态构建，避免硬编码
3. **Langfuse提示词管理**：对接Langfuse提示词模版，支持在线管理和优化
4. **占位符管理**：统一的占位符管理机制
5. **Agent生命周期管理**：支持热更新和缓存
6. **监控和调试**：统一的监控机制

### 5.2 预期收益

1. **可维护性提升**：代码结构统一，易于维护和扩展
2. **灵活性提升**：支持动态Agent注册，无需修改核心代码
3. **提示词管理优化**：利用Langfuse进行提示词版本管理和A/B测试
4. **开发效率提升**：添加新Agent更简单，配置驱动
5. **可观测性提升**：统一的监控和调试机制

### 5.3 风险与应对

1. **Langfuse依赖风险**：Langfuse服务不可用时，需要fallback到本地模版
2. **迁移风险**：现有提示词需要迁移到Langfuse，需要充分测试
3. **性能风险**：Langfuse API调用可能影响性能，需要缓存机制

---

## 六、附录

### 6.1 相关文档

- `doc/设计V4.0/Langfuse接入方案.md` - Langfuse接入方案
- `doc/设计V3.0/V3.1 Agent提示词/` - 提示词管理方案
- `cursor_docs/001代码链路-Agent执行路径与数据流转分析.md` - Agent执行路径分析

### 6.2 参考代码

- `domain/agents/factory.py` - Agent工厂
- `domain/router/graph.py` - 路由图构建
- `infrastructure/prompts/manager.py` - 提示词管理器
- `config/agents.yaml` - Agent配置文件
