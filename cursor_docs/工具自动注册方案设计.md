# 工具自动注册方案设计

## 一、当前注册机制分析

### 1.1 现状

当前系统采用**主动注册**的方式，需要在 `backend/domain/tools/__init__.py` 的 `init_tools()` 函数中手动导入并注册每个工具：

```python
def init_tools():
    """初始化工具注册表"""
    # 需要手动导入
    from backend.domain.tools.blood_pressure import (
        record_blood_pressure,
        query_blood_pressure,
        update_blood_pressure
    )
    
    # 需要手动注册
    tool_registry.register(record_blood_pressure)
    tool_registry.register(query_blood_pressure)
    tool_registry.register(update_blood_pressure)
```

### 1.2 存在的问题

1. **维护成本高**：每新增一个工具，都需要修改 `init_tools()` 函数
2. **容易遗漏**：忘记注册新工具会导致运行时警告
3. **代码重复**：导入和注册逻辑重复
4. **不符合 DRY 原则**：违反了"不要重复自己"的编程原则

---

## 二、自动注册方案设计

### 方案一：基于模块扫描的自动注册（推荐）

#### 2.1.1 方案原理

通过扫描 `backend/domain/tools/` 目录下的所有 Python 模块，自动发现使用 `@tool` 装饰器定义的函数，并自动注册到工具注册表。

#### 2.1.2 实现思路

```python
import inspect
import importlib
from pathlib import Path
from langchain_core.tools import BaseTool
from backend.domain.tools.registry import tool_registry

def auto_register_tools():
    """
    自动扫描并注册所有工具
    
    扫描逻辑：
    1. 遍历 backend/domain/tools/ 目录下的所有 .py 文件
    2. 排除 __init__.py、registry.py、context.py、wrapper.py 等系统文件
    3. 动态导入每个模块
    4. 检查模块中所有使用 @tool 装饰器的函数
    5. 自动注册到 tool_registry
    """
    tools_dir = Path(__file__).parent  # backend/domain/tools/
    excluded_files = {'__init__.py', 'registry.py', 'context.py', 'wrapper.py'}
    
    for py_file in tools_dir.glob('*.py'):
        if py_file.name in excluded_files:
            continue
        
        # 动态导入模块
        module_name = f"backend.domain.tools.{py_file.stem}"
        try:
            module = importlib.import_module(module_name)
            
            # 扫描模块中的所有对象
            for name, obj in inspect.getmembers(module):
                # 检查是否为工具（使用 @tool 装饰器的函数）
                if inspect.isfunction(obj) and hasattr(obj, 'name'):
                    # @tool 装饰器会给函数添加 'name' 属性
                    if isinstance(obj, BaseTool) or hasattr(obj, '__wrapped__'):
                        tool_registry.register(obj)
                        logger.info(f"自动注册工具: {obj.name}")
        except Exception as e:
            logger.warning(f"导入模块 {module_name} 失败: {e}")
```

#### 2.1.3 优点

- ✅ **完全自动化**：新增工具无需修改任何注册代码
- ✅ **零维护成本**：工具文件创建后自动被发现和注册
- ✅ **符合约定优于配置**：遵循 Python 模块约定
- ✅ **实现简单**：代码量少，易于理解

#### 2.1.4 缺点

- ⚠️ **性能开销**：启动时需要扫描所有模块（可接受，仅启动时执行一次）
- ⚠️ **依赖文件结构**：需要工具文件放在指定目录
- ⚠️ **可能误注册**：需要精确判断哪些是工具（可通过命名约定解决）

#### 2.1.5 改进版本：基于命名约定

```python
def auto_register_tools():
    """自动注册工具（基于命名约定）"""
    tools_dir = Path(__file__).parent
    excluded_files = {'__init__.py', 'registry.py', 'context.py', 'wrapper.py'}
    
    for py_file in tools_dir.glob('*.py'):
        if py_file.name in excluded_files:
            continue
        
        module_name = f"backend.domain.tools.{py_file.stem}"
        try:
            module = importlib.import_module(module_name)
            
            # 只注册符合命名约定的函数（以 _tool 结尾或使用 @tool 装饰器）
            for name, obj in inspect.getmembers(module, inspect.isfunction):
                # 检查是否为工具：1) 有 name 属性（@tool 装饰器添加） 2) 是 BaseTool 实例
                if (hasattr(obj, 'name') and 
                    (isinstance(obj, BaseTool) or 
                     hasattr(obj, '__wrapped__') and 
                     hasattr(obj.__wrapped__, '__annotations__'))):
                    tool_registry.register(obj)
                    logger.info(f"自动注册工具: {obj.name}")
        except Exception as e:
            logger.warning(f"导入模块 {module_name} 失败: {e}")
```

---

### 方案二：基于自定义装饰器的自动注册

#### 2.2.1 方案原理

创建一个自定义装饰器 `@register_tool`，在装饰函数时自动将其注册到工具注册表。

#### 2.2.2 实现思路

```python
# backend/domain/tools/decorator.py
from functools import wraps
from langchain_core.tools import tool
from backend.domain.tools.registry import tool_registry

def register_tool(func=None, *, auto_register=True):
    """
    工具注册装饰器
    
    用法：
        @register_tool
        async def my_tool(...):
            ...
    
    或者：
        @register_tool(auto_register=True)
        async def my_tool(...):
            ...
    """
    def decorator(f):
        # 先使用 @tool 装饰器
        tool_func = tool(f)
        
        # 自动注册到工具注册表
        if auto_register:
            tool_registry.register(tool_func)
        
        return tool_func
    
    if func is None:
        return decorator
    else:
        return decorator(func)
```

#### 2.2.3 使用方式

```python
# backend/domain/tools/blood_pressure.py
from backend.domain.tools.decorator import register_tool

@register_tool  # 自动注册，无需在 init_tools() 中手动注册
async def record_blood_pressure(...):
    """记录血压数据"""
    ...

@register_tool
async def query_blood_pressure(...):
    """查询血压记录"""
    ...
```

#### 2.2.4 优点

- ✅ **显式声明**：在工具定义处明确表示需要注册
- ✅ **灵活性高**：可以选择是否自动注册（`auto_register=False`）
- ✅ **向后兼容**：可以逐步迁移现有工具

#### 2.2.5 缺点

- ⚠️ **需要修改工具定义**：每个工具都需要添加装饰器
- ⚠️ **依赖导入顺序**：需要确保 `tool_registry` 在装饰时已初始化
- ⚠️ **可能重复注册**：如果模块被多次导入可能重复注册

#### 2.2.6 改进版本：防止重复注册

```python
def register_tool(func=None, *, auto_register=True):
    """工具注册装饰器（防止重复注册）"""
    def decorator(f):
        tool_func = tool(f)
        
        if auto_register:
            # 检查是否已注册
            if tool_registry.get_tool(tool_func.name) is None:
                tool_registry.register(tool_func)
            else:
                logger.debug(f"工具 {tool_func.name} 已注册，跳过")
        
        return tool_func
    
    if func is None:
        return decorator
    else:
        return decorator(func)
```

---

### 方案三：基于 Python Entry Points 的注册

#### 2.3.1 方案原理

使用 Python 的 `setuptools` 的 Entry Points 机制，在 `setup.py` 或 `pyproject.toml` 中声明工具入口点，系统启动时自动发现并注册。

#### 2.3.2 实现思路

**1. 在 `pyproject.toml` 中声明入口点：**

```toml
[project.entry-points."gd25.tools"]
record_blood_pressure = "backend.domain.tools.blood_pressure:record_blood_pressure"
query_blood_pressure = "backend.domain.tools.blood_pressure:query_blood_pressure"
update_blood_pressure = "backend.domain.tools.blood_pressure:update_blood_pressure"
```

**2. 在 `init_tools()` 中自动发现：**

```python
from importlib.metadata import entry_points

def auto_register_tools():
    """通过 Entry Points 自动注册工具"""
    try:
        # 获取所有注册的工具入口点
        tools = entry_points(group='gd25.tools')
        
        for tool_entry in tools:
            try:
                # 加载工具函数
                tool_func = tool_entry.load()
                # 注册工具
                tool_registry.register(tool_func)
                logger.info(f"通过 Entry Points 注册工具: {tool_entry.name}")
            except Exception as e:
                logger.error(f"加载工具 {tool_entry.name} 失败: {e}")
    except Exception as e:
        logger.error(f"读取 Entry Points 失败: {e}")
```

#### 2.3.3 优点

- ✅ **标准化**：使用 Python 标准机制
- ✅ **可扩展**：支持第三方插件注册工具
- ✅ **配置集中**：所有工具声明在一个地方

#### 2.3.4 缺点

- ⚠️ **需要配置文件**：需要在 `pyproject.toml` 中维护工具列表
- ⚠️ **不够自动化**：新增工具仍需修改配置文件
- ⚠️ **依赖 setuptools**：需要项目使用 setuptools 构建

---

### 方案四：基于元类的自动注册

#### 2.4.1 方案原理

定义工具基类，使用元类在类定义时自动注册工具实例。

#### 2.4.2 实现思路

```python
# backend/domain/tools/base.py
from langchain_core.tools import BaseTool
from backend.domain.tools.registry import tool_registry

class ToolMeta(type):
    """工具元类，自动注册工具"""
    def __new__(cls, name, bases, attrs):
        new_class = super().__new__(cls, name, bases, attrs)
        
        # 如果是工具类（继承自 BaseTool），自动注册
        if BaseTool in bases and hasattr(new_class, 'name'):
            instance = new_class()
            tool_registry.register(instance)
            logger.info(f"通过元类自动注册工具: {instance.name}")
        
        return new_class

class AutoRegisterTool(BaseTool, metaclass=ToolMeta):
    """自动注册的工具基类"""
    pass
```

#### 2.4.3 使用方式

```python
class RecordBloodPressureTool(AutoRegisterTool):
    name = "record_blood_pressure"
    description = "记录血压数据"
    
    def _run(self, ...):
        ...
```

#### 2.4.4 优点

- ✅ **面向对象**：适合复杂的工具实现
- ✅ **自动注册**：类定义时自动注册

#### 2.4.5 缺点

- ⚠️ **改变工具定义方式**：需要从函数改为类
- ⚠️ **代码复杂度高**：元类机制不易理解
- ⚠️ **不适用于当前项目**：当前项目使用函数式工具定义

---

### 方案五：基于导入钩子的自动注册

#### 2.5.1 方案原理

使用 Python 的导入钩子（Import Hooks）机制，在导入工具模块时自动注册工具。

#### 2.5.2 实现思路

```python
import sys
from importlib.abc import MetaPathFinder, Loader
from importlib.util import spec_from_loader

class ToolAutoRegisterLoader(Loader):
    """工具自动注册加载器"""
    def __init__(self, original_loader):
        self.original_loader = original_loader
    
    def create_module(self, spec):
        return self.original_loader.create_module(spec)
    
    def exec_module(self, module):
        # 先执行原始模块加载
        self.original_loader.exec_module(module)
        
        # 然后自动注册模块中的工具
        from backend.domain.tools.registry import tool_registry
        import inspect
        from langchain_core.tools import BaseTool
        
        for name, obj in inspect.getmembers(module):
            if inspect.isfunction(obj) and isinstance(obj, BaseTool):
                tool_registry.register(obj)
                logger.info(f"通过导入钩子自动注册工具: {obj.name}")

class ToolAutoRegisterFinder(MetaPathFinder):
    """工具自动注册查找器"""
    def find_spec(self, name, path, target=None):
        # 只处理 backend.domain.tools 下的模块
        if name.startswith('backend.domain.tools.'):
            # 获取原始查找器
            for finder in sys.meta_path:
                if finder != self:
                    spec = finder.find_spec(name, path, target)
                    if spec:
                        # 替换加载器
                        spec.loader = ToolAutoRegisterLoader(spec.loader)
                        return spec
        return None

# 注册导入钩子
sys.meta_path.insert(0, ToolAutoRegisterFinder())
```

#### 2.5.3 优点

- ✅ **完全透明**：对工具定义代码无侵入
- ✅ **自动化程度高**：导入即注册

#### 2.5.4 缺点

- ⚠️ **实现复杂**：导入钩子机制复杂
- ⚠️ **调试困难**：可能影响其他模块导入
- ⚠️ **性能影响**：每次导入都会执行注册逻辑

---

## 三、方案对比与推荐

### 3.1 方案对比表

| 方案 | 自动化程度 | 实现复杂度 | 维护成本 | 性能影响 | 推荐度 |
|------|-----------|-----------|----------|----------|--------|
| **方案一：模块扫描** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **方案二：自定义装饰器** | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **方案三：Entry Points** | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **方案四：元类** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| **方案五：导入钩子** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |

### 3.2 推荐方案

**推荐使用方案一（模块扫描）+ 方案二（自定义装饰器）的组合方案**：

1. **主要使用方案一**：自动扫描并注册所有工具，实现完全自动化
2. **可选使用方案二**：为需要特殊处理的工具提供显式注册装饰器

### 3.3 组合方案实现示例

```python
# backend/domain/tools/__init__.py
import inspect
import importlib
from pathlib import Path
from langchain_core.tools import BaseTool
from backend.domain.tools.registry import tool_registry

def auto_register_tools():
    """
    自动扫描并注册所有工具
    
    策略：
    1. 扫描 backend/domain/tools/ 目录下的所有模块
    2. 自动发现使用 @tool 装饰器的函数
    3. 自动注册到工具注册表
    """
    tools_dir = Path(__file__).parent
    excluded_files = {'__init__.py', 'registry.py', 'context.py', 'wrapper.py', 'decorator.py'}
    registered_tools = set()  # 防止重复注册
    
    for py_file in tools_dir.glob('*.py'):
        if py_file.name in excluded_files:
            continue
        
        module_name = f"backend.domain.tools.{py_file.stem}"
        try:
            module = importlib.import_module(module_name)
            
            # 扫描模块中的所有对象
            for name, obj in inspect.getmembers(module):
                # 检查是否为工具
                if _is_tool(obj):
                    tool_name = getattr(obj, 'name', name)
                    
                    # 防止重复注册
                    if tool_name not in registered_tools:
                        tool_registry.register(obj)
                        registered_tools.add(tool_name)
                        logger.info(f"自动注册工具: {tool_name}")
        except Exception as e:
            logger.warning(f"导入模块 {module_name} 失败: {e}")

def _is_tool(obj) -> bool:
    """
    判断对象是否为工具
    
    判断标准：
    1. 是函数
    2. 是 BaseTool 实例，或者
    3. 使用了 @tool 装饰器（有 name 属性且是 callable）
    """
    if not inspect.isfunction(obj) and not isinstance(obj, BaseTool):
        return False
    
    # 检查是否有 name 属性（@tool 装饰器会添加）
    if hasattr(obj, 'name'):
        return True
    
    # 检查是否是 BaseTool 实例
    if isinstance(obj, BaseTool):
        return True
    
    return False

# 初始化工具注册表
def init_tools():
    """初始化工具注册表（使用自动注册）"""
    auto_register_tools()
```

---

## 四、实施建议

### 4.1 迁移步骤

1. **第一步**：实现自动注册逻辑（方案一）
2. **第二步**：保留现有的手动注册代码作为备份
3. **第三步**：测试验证自动注册功能
4. **第四步**：移除手动注册代码
5. **第五步**：添加工具命名约定文档

### 4.2 注意事项

1. **工具命名规范**：建议工具函数名使用 `动词_名词` 格式，如 `record_blood_pressure`
2. **模块组织**：建议按业务领域组织工具文件，如 `blood_pressure.py`、`appointment.py`
3. **错误处理**：自动注册时应该捕获异常，避免一个工具注册失败影响其他工具
4. **日志记录**：记录所有自动注册的工具，便于调试和排查问题

### 4.3 向后兼容

- 保留 `init_tools()` 函数接口不变
- 内部实现改为自动注册
- 现有工具无需修改即可自动注册

---

## 五、总结

自动注册工具可以显著降低维护成本，提高开发效率。推荐使用**模块扫描方案**，它平衡了自动化程度、实现复杂度和维护成本，是最适合当前项目的方案。

通过实施自动注册机制，开发者只需要：
1. 在 `backend/domain/tools/` 目录下创建工具文件
2. 使用 `@tool` 装饰器定义工具函数
3. 系统启动时自动发现并注册

无需再手动修改 `init_tools()` 函数，真正实现了"约定优于配置"的开发体验。

